#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;
// initialise spotify connect last track ID
$redis->hSet('spotifyconnect', 'last_track_id', '');
// clear the spotify connect metadata queues
$redis->del('s_queue');
$redis->del('s_queue_fifo');
//
// some radio stations never supply metadata, add them to the array below (case insensitive)
//  or create a redis variable, e.g.: redis-cli set radio_skip_meta_strings '["BBC World Service","BBC Radio","Your String To Omit"]'
$radioSkipMetaStrings = array('BBC World Service', 'BBC Radio');
if ($redis->exists('radio_skip_meta_strings')) {
    $radioSkipMetaStrings = json_decode($redis->get('radio_skip_meta_strings'), true);
}
//
// --- WORKER MAIN LOOP --- //
while (true) {
    // connect to redis backend (pconnect reuses existing connections)
    $redis->pconnect('/run/redis/socket');
    // initialise variables
    $artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
    $artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
    // when coverart is switched off some background jobs are not required
    $coverartRequired = $redis->get('coverart');
    if (($redis->get('remoteSStime') != -1) || ($redis->hGet('local_browser', 'localSStime') != -1)) {
        // when a screensaver is switched on (value not = -1) the coverart routines are also required
        $coverartRequired = true;
    }
    if ($redis->get('remoteSSbigart') === 'album') {
        $bigartIsAlbum = true;
    } else {
        $bigartIsAlbum = false;
    }
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    runelog('rune_PL_wrk: open MPD local UNIX socket');
    $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
    if (!$socket) {
        $redis->close();
        sleep(5);
        continue;
    }
    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            $status = array();
            $newStatus = array();
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('----------------------------------- FORCE UPDATE MPD -----------------------------------');
                // sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                $status = array_merge($status, initialise_playback_array($redis, 'MPD'));
                $status['mainArtURL'] = $artUrl.'/none.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
            }
            $newStatus = _parseStatusResponse($redis, MpdStatus($socket));
            if (isset($newStatus) || is_array($newStatus)) {
                $status = array_merge($status, $newStatus);
                $status = ui_status($redis, $socket, $status);
                if (isset($status['radioname']) && $status['radioname']) {
                    $status['radio'] = true;
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                } else {
                    $status['radio'] = false;
                }
                // ui_render('playback', json_encode($status));
                // sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
            } else {
                // no status returned, assume mpd not yet ready
                if ($socket) {
                    closeMpdSocket($socket);
                }
                continue;
            }
            $newStatus = array();
            $status['actPlayer'] = $activePlayer;
            // start the job to retrieve extra metadata when coverart is enabled
            if ($coverartRequired) {
                // it may already be running, check first
                $retval = sysCmd('systemctl is-active rune_MPDEM_wrk')[0];
                if ($retval != 'active') {
                    sysCmd('systemctl start rune_MPDEM_wrk');
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
                }
            }
            // store next songid
            if (!isset($status['nextsongid']) || !$status['nextsongid']) {
                $status['nextsongid'] = 0;
            }
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            if (!isset($status['songid'])) {
                $status['songid'] = 0;
            }
            $redis->set('lastsongid', $status['songid']);
            // store the playlist length
            if (!isset($status['playlistlength'])) {
                $status['playlistlength'] = 0;
            }
            $status['volume'] = $redis->get('lastmpdvolume');
            $redis->set('pl_length', $status['playlistlength']);
            $redis->set('act_player_info', json_encode($status));
            ui_render('playback', json_encode($status));
            // sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
            // set the mpd volume to the last value set via the UI, if a value is available and volume control is enabled
            // the streaming services can change the alsa volume, we want to change it back to the last set value
            set_last_mpd_volume($redis);
            // $status = array_merge($status, array('currentartist' => '',
                // 'currentalbumartist' => '',
                // 'currentalbum' => '',
                // 'currentsong' => '',
                // 'file' => ''));
            // next line forces radio metadata, required when the radio is first in the queue
            //  a radio may already have completed its initial state change and may never change its state again
            //  the command queues an update to the UI to happen in 3 seconds, this will trigger a state change in 'monitorMpdState(..)' below
            sysCmdAsync($redis, '/srv/http/command/ui_update_async', 3);
            $saveRadio = 'x??x';
            $saveCurrentsong = '';
            $saveCurrentartist = '';
            $saveCurrentalbum = '';
            $saveFile = '';
            $saveChanged = '';
            $subscriptionCnt = 1;
            $mpdFixFile = '';
            do {
                //
                // idle LOOP
                //
                runelog('rune_PL_wrk: enter idle loop');
                // wait for a state change
                $newStatus = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$newStatus || !is_array($newStatus)) {
                    // call close MPD socket to clean up the socket
                    if ($socket) {
                        closeMpdSocket($socket);
                    }
                    break;
                }
                if ($redis->get('activePlayer') != 'MPD') {
                    // no longer MPD, just break the loop
                    if ($socket) {
                        closeMpdSocket($socket);
                    }
                    break;
                }
                // we use the mpd subscribe and unsubscribe to channels to trigger an idle interrupt, this triggers two transactions, we
                //  need to react once
                if (($newStatus['changed'] == 'subscription:OK') && ($newStatus['changed'] == $saveChanged)) {
                    // the subscription changed type come in 3's or 4's after each other, process the first one and skip any others
                    //  which follow sequentially
                    if ($subscriptionCnt-- > 0) {
                        continue;
                    } else {
                        // process every second one
                        $subscriptionCnt = 1;
                    }
                } else if (strpos(' '.$newStatus['changed'], 'subscription')) {
                    // when any other type of 'changed' event happens together with a subscription always process it, but set
                    //  the saved changed value as if it happened alone
                    $saveChanged = 'subscription:OK';
                } else {
                    $saveChanged = $newStatus['changed'];
                }
                // store next songid
                if (!isset($newStatus['nextsongid']) || !$newStatus['nextsongid']) {
                    $newStatus['nextsongid'] = 0;
                }
                $redis->set('nextsongid', $newStatus['nextsongid']);
                // store "lastsongid"
                if (!isset($newStatus['songid'])) {
                    $newStatus['songid'] = 0;
                }
                if (isset($newStatus['song'])) {
                    $redis->set('mpd_playback_lastnumber', $newStatus['song']+1);
                } else if (!$redis->get('mpd_playback_lastnumber')) {
                    $redis->set('mpd_playback_lastnumber', 1);
                }
                $redis->set('lastsongid', $newStatus['songid']);
                // store playlist length
                if (!isset($newStatus['playlistlength'])) {
                    $newStatus['playlistlength'] = 0;
                }
                $redis->set('pl_length', $newStatus['playlistlength']);
                //
                // runelog('---------status data------------',$newStatus);
                $newStatus = ui_status($redis, $socket, $newStatus);
                // debug
                // echo "Radioname: ".$newStatus['radioname'].", changed: ".$newStatus['changed'].", playlistlength: ".$newStatus['playlistlength'].", currentsong: ".$newStatus['currentsong']."\n";
                runelog('$newStatus', "Radioname: ".$newStatus['radioname'].", changed: ".$newStatus['changed'].", playlistlength: ".$newStatus['playlistlength'].", currentsong: ".$newStatus['currentsong']);
                // runelog('---------status data(2)------------', $newStatus);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync($redis, 'ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}
                //
                // set the radio flag and the radioname if required
                if (isset($newStatus['radioname']) && $newStatus['radioname']) {
                    // radioname is set, current file (url) is a radio url
                    // currentalbum is set to the radio name
                    $newStatus['radio'] = true;
                } else {
                    $newStatus['radioname'] = '';
                    $newStatus['radio'] = false;
                }
                // the redis variable 'act_player_info' also gets modified in the script rune_MPDEM_wrk, refresh it here
                //  also update the variable, this acts as a sort of optimistic lock
                //  updates of 'act_player_info' in this script have priority over updates carried out in rune_MPDEM_wrk
                //  the updates of act_player_info are tracked in rune_MPDEM_wrk which acts appropriately
                $retval = $redis->get('act_player_info');
                $redis->set('act_player_info', $retval);
                $status = json_decode($retval, true);
                unset($retval);
                //
                // tweaks to only retrieve radio information after a second metadata record
                // some radio stations only send one metadata record (repeatedly), so really there is actually no metadata supplied
                $mpdChangeSong = true;
                if ($newStatus['radio']) {
                    // its a radio
                    $newStatus['time'] = 100;
                    if (($newStatus['file'] != $saveFile) || ($newStatus['state'] == 'stop')) {
                        // it is a radio and it is not the same as the last radio, so this is the first information from the webradio
                        // when the radio is stopped also clear the main UI
                        // $saveFile = $newStatus['file'];
                        $saveRadio = $newStatus['radio'];
                        $newStatus['currentsong'] = '...';
                        $newStatus['currentartist'] = 'Webradio';
                        $newStatus['currentalbumartist'] = 'Webradio';
                        $newStatus['currentalbum'] = $newStatus['radioname'];
                        $newStatus['currentcomposer'] = '...';
                        $newStatus['song_lyrics'] = ' ';
                        $newStatus['artist_bio_summary'] = ' ';
                        $newStatus['artist_similar'] = ' ';
                        $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                        $newStatus['bigArtURL'] = $artUrl.'/none.png';
                        $newStatus['smallArtURL'] = $artUrl.'/none.png';
                        $newStatus['elapsed'] = 0;
                        $newStatus['song_percent'] = 0;
                        $status = $newStatus;
                        $mpdChangeSong = false;
                    } else if ($newStatus['currentsong'] === '') {
                        // skip records when no metadata is passed
                        $newStatus['currentsong'] = $saveCurrentsong;
                        $mpdChangeSong = false;
                    } else if (!strpos(' '.$newStatus['currentsong'], ' - ')) {
                        // it is a radio and there is no space-hyphen-space in the song name, this indicates an information message and not an artist/album string
                        // $saveFile = $newStatus['file'];
                        $saveRadio = $newStatus['radio'];
                        $newStatus['currentartist'] = 'Webradio';
                        $newStatus['currentalbumartist'] = 'Webradio';
                        $newStatus['currentalbum'] = $newStatus['radioname'];
                        $newStatus['currentcomposer'] = '...';
                        $newStatus['song_lyrics'] = ' ';
                        $newStatus['artist_bio_summary'] = ' ';
                        $newStatus['artist_similar'] = ' ';
                        $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                        $newStatus['bigArtURL'] = $artUrl.'/none.png';
                        $newStatus['smallArtURL'] = $artUrl.'/none.png';
                        $status = $newStatus;
                        $mpdChangeSong = false;
                    } else {
                        foreach ($radioSkipMetaStrings as $radioSkipMetaString) {
                            if ((strpos(strtolower(' '.$newStatus['currentsong']), strtolower(trim($radioSkipMetaString)))) ||
                                    (strpos(strtolower(' '.$newStatus['radioname']), strtolower(trim($radioSkipMetaString))))) {
                                // it is a radio which we always omit from metadata search
                                // $saveFile = $newStatus['file'];
                                $saveRadio = $newStatus['radio'];
                                $newStatus['currentartist'] = 'Webradio';
                                $newStatus['currentalbumartist'] = 'Webradio';
                                $newStatus['currentalbum'] = $newStatus['radioname'];
                                $newStatus['currentcomposer'] = '...';
                                $newStatus['song_lyrics'] = ' ';
                                $newStatus['artist_bio_summary'] = ' ';
                                $newStatus['artist_similar'] = ' ';
                                $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                                $newStatus['bigArtURL'] = $artUrl.'/none.png';
                                $newStatus['smallArtURL'] = $artUrl.'/none.png';
                                $status = $newStatus;
                                $mpdChangeSong = false;
                                break;
                            }
                        }
                    }
                } else if (isset($newStatus['file']) && ((strtolower(substr($newStatus['file'], 0, 5)) == 'alsa:') || (strtolower(substr($newStatus['file'], 0, 5)) == 'cdda:'))) {
                    // its an alsa hw source or a CD source
                    //  there is no metadata available
                    $newStatus['currentalbumartist'] = $newStatus['currentartist'];
                    if (strtolower(substr($newStatus['file'], 0, 5)) == 'alsa:') {
                        // // its an alsa hw source
                        // if (!$hwSource) {
                            // // its a new hw source
                            // $hwSource = $newStatus['file'];
                        // }
                        $newStatus['currentartist'] = 'Hardware Source';
                        $newStatus['time'] = 100;
                        $hwCard = trim(get_between_data($newStatus['file'], 'hw:', ','));
                        $hwCardInfo = sysCmd('arecord -l -c '.$hwCard.' | grep -i "card '.$hwCard.'" | xargs')[0];
                        $hwCardDesc = trim(get_between_data($hwCardInfo, '[', ']'));
                        $newStatus['currentsong'] = $hwCardDesc;
                        $newStatus['currentalbum'] = $newStatus['file'];
                        $rateParts = explode(':', $newStatus['audio']);
                        if ((count($rateParts) == 3) && $rateParts[0] && $rateParts[1] && $rateParts[2]) {
                            $newStatus['bitrate'] = $rateParts[0] * $rateParts[1] * $rateParts[2] / 1000;
                            if (strlen($newStatus['bitrate']) > 3) {
                                $newStatus['bitrate'] = round($newStatus['bitrate']);
                            }
                        } else {
                            $newStatus['bitrate'] = 1536;
                        }
                        unset($hwCard, $hwCardInfo, $hwCardDesc, $rateParts);
                    } else {
                        // // its a cd source, track number may be available
                        // if (!$cdSource) {
                            // // its a new cd track
                            // $cdSource = $newStatus['file'];
                        // }
                        $newStatus['currentartist'] = 'CD Source';
                        $cdDeviceParts = explode('/', $newStatus['file']);
                        $cdTrack = end($cdDeviceParts);
                        if (isset($cdTrack) && $cdTrack) {
                            $newStatus['currentsong'] = 'CD Track #'.$cdTrack;
                        } else {
                            $newStatus['currentsong'] = 'CD All Tracks';
                        }
                        $newStatus['currentalbum'] = $newStatus['file'];
                        $rateParts = explode(':', $newStatus['audio']);
                        if ((count($rateParts) == 3) && $rateParts[0] && $rateParts[1] && $rateParts[2]) {
                            $newStatus['bitrate'] = $rateParts[0] * $rateParts[1] * $rateParts[2] / 1000;
                            if (strlen($newStatus['bitrate']) > 3) {
                                $newStatus['bitrate'] = round($newStatus['bitrate']);
                            }
                        } else {
                            $newStatus['bitrate'] = 1411;
                        }
                        unset($cdDeviceParts, $cdTrack, $rateParts);
                    }
                    $newStatus['currentcomposer'] = '...';
                    $newStatus['song_lyrics'] = ' ';
                    $newStatus['artist_bio_summary'] = ' ';
                    $newStatus['artist_similar'] = ' ';
                    $newStatus['mainArtURL'] = $artUrl.'/none.png';
                    $newStatus['bigArtURL'] = $artUrl.'/none.png';
                    $newStatus['smallArtURL'] = $artUrl.'/none.png';
                    $status = $newStatus;
                    $mpdChangeSong = false;
                } else {
                // if (!$newStatus['radio']) {
                    // its not a radio, a alsa hw source nor a hardware CD source, try fixing the display data from cached values
                    if ($newStatus['file'] &&
                            (($newStatus['file'] != $mpdFixFile))
                            || (!isset($status['mainArtURL']))
                            || ($status['mainArtURL'] == $artUrl.'/radio.png')
                            || ($status['mainArtURL'] == $artUrl.'/none.png')
                            || ($status['mainArtURL'] == $artUrl.'/black.png')
                            || (trim($status['artist_bio_summary']) == '')
                            || (trim($status['song_lyrics']) == '')
                            ) {
                        // for this file we have not fixed the MPD info
                        if ($coverartRequired) {
                            // coverart is switched on, so fit it
                            $newStatus = ui_mpd_fix($redis, $newStatus);
                        }
                        $mpdFixFile = $newStatus['file'];
                    } else {
                        // the UI remembers the last values
                        unset($newStatus['bitrate'], $newStatus['audio_sample_rate'], $newStatus['audio_sample_depth'], $newStatus['mainArtURL']);
                    }
                }
                //
                // determine what has been returned by MPD, it could be a new song or some sort of status change
                // the current $status will be filled with extra information for each new song, this information is not delivered by MPD,
                //  and it should not be lost, the routines which create this extra information are time consuming and should only be run
                //  when when a new song is detected
                if (($newStatus['radio'] === $saveRadio) && ($newStatus['currentsong'] === $saveCurrentsong) && ($newStatus['file'] === $saveFile)) {
                    // same song, just replace specific parts of $status
                    unset($newStatus['currentartist'],
                        $newStatus['currentalbumartist'],
                        $newStatus['currentalbum'],
                        $newStatus['currentsong'],
                        $newStatus['currentcomposer'],
                        $newStatus['file'],
                        $newStatus['fileext'],
                        $status['updating_db']);
                    $status = array_merge($status, $newStatus);
                    $mpdChangeSong = false;
                } else {
                    // radio is toggled, new radio station or new song, replace status
                    $status = array_merge($status, $newStatus);
                    if (!$newStatus['radio'] && !$mpdChangeSong) {
                        // don't switch the changed song status for radios when it is already set to false
                        $mpdChangeSong = true;
                    }
                    $saveRadio = $status['radio'];
                    $saveCurrentsong = $status['currentsong'];
                    if (!$status['radio'] || ($status['state'] != 'stop')) {
                        // don't update saveFile for stopped radios, this keeps the UI cleared for stopped radios
                        $saveFile = $status['file'];
                    }
                    $status['song_lyrics'] = ' ';
                    if (($status['currentartist'] != $saveCurrentartist) || ($status['currentartist'] == '') || ($status['currentartist'] == 'Webradio')) {
                        $status['artist_bio_summary'] = ' ';
                        $status['artist_similar'] = ' ';
                        $status['bigArtURL'] = $artUrl.'/none.png';
                        $status['smallArtURL'] = $artUrl.'/none.png';
                    }
                    $saveCurrentartist = $status['currentartist'];
                    if (($status['currentalbum'] != $saveCurrentalbum) || ($status['currentalbum'] == '') || ($status['currentalbum'] == 'Webradio')) {
                        if ($status['radio']) {
                            $status['mainArtURL'] = $artUrl.'/radio.png';
                        } else {
                            $status['mainArtURL'] = $artUrl.'/none.png';
                        }
                    }
                    $saveCurrentalbum = $status['currentalbum'];
                }
                //
                $newStatus = array();
                //
                // decode radio song name and determine the metadata and albumart
                // $rts = 0;
                if ($mpdChangeSong && $status['radio'] && (!isset($status['currentartist']) || !$status['currentartist'])) {
                    runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                    if (isset($status['currentsong']) && $status['currentsong'] && $coverartRequired) {
                        // $rts = time();
                        runelog('rune_PL_wrk: radio currentsong = ', $status['currentsong']);
                        // update the active player information before trying to decode the radio metadata and albumart
                        $redis->set('act_player_info', json_encode($status));
                        $retval = wrk_get_webradio_art($redis, $status['currentsong']);
                        if ($redis->get('activePlayer') != 'MPD') {
                            // no longer MPD, just break the loop
                            break;
                        }
                    } else {
                        // currentsong has no value or coverart is switched off
                        $retval = false;
                        $status['currentsong'] = '';
                    }
                    // it takes ages to determine the radio art, refresh the status to update the elapsed time
                    $status = ui_status($redis, $socket, $status);
                    $status['fileext'] = '';
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                    $status['bigArtURL'] = $artUrl.'/none.png';
                    $status['smallArtURL'] = $artUrl.'/none.png';
                    $status['currentalbum'] = $status['radioname'];
                    $status['currentalbumartist'] = '';
                    $status['currentartist'] = '';
                    if ($retval) {
                        // ui_notify($redis, 'Radio success ', $rts.' seconds, change status '.$status['changed']);
                        if ($retval['song']) {
                            $status['currentsong'] = $retval['song'];
                        }
                        if ($retval['song_lyrics']) {
                            $status['song_lyrics'] = $retval['song_lyrics'];
                        }
                        if ($retval['artist']) {
                            $status['currentartist'] = $retval['artist'];
                            $status['currentalbumartist'] = $retval['artist'];
                        }
                        if ($retval['artist_bio_summary']) {
                            $status['artist_bio_summary'] = $retval['artist_bio_summary'];
                        }
                        if ($retval['artist_similar']) {
                            $status['artist_similar'] = $retval['artist_similar'];
                        }
                        if ($retval['album_arturl_large']) {
                            // when 'album_arturl_large' is set, 'album_arturl_medium' and 'album_arturl_small' are also set
                            // album art sourced from discogs is escaped, always remove with stripcslashes
                            if ($bigartIsAlbum) {
                                $status['mainArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                $status['bigArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                            } else {
                                $status['mainArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                $status['smallArtURL'] = trim(stripcslashes($retval['album_arturl_small']));
                            }
                        }
                        if ($retval['artist_arturl']) {
                            if ($bigartIsAlbum) {
                                if (strpos(' '.$retval['artist_arturl'], '/none.png')) {
                                    $status['smallArtURL'] = trim(stripcslashes($retval['album_arturl_small']));
                                } else {
                                    $status['smallArtURL'] = trim(stripcslashes($retval['artist_arturl']));
                                }
                            } else {
                                if (strpos(' '.$retval['artist_arturl'], '/none.png')) {
                                    $status['bigArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                } else {
                                    $status['bigArtURL'] = trim(stripcslashes($retval['artist_arturl']));
                                }
                            }
                        }
                    } else {
                        // ui_notify($redis, 'Radio fail ', $rts.' seconds, change status '.$status['changed']);
                    }
                    if (!$status['currentartist']) {
                        $status['currentartist'] = 'Streaming';
                        $status['currentalbumartist'] = 'Streaming';
                    }
                    if (!$status['currentsong']) {
                        $status['currentsong'] = 'Radio';
                    }
                }
                // this is a catchall when the main art url is not set or incorrectly set for radio
                if (!isset($status['mainArtURL']) || !trim($status['mainArtURL'])) {
                    $status['mainArtURL'] = $artUrl.'/none.png';
                } else if (isset($status['mainArtURL']) && strpos(' '.$status['mainArtURL'], '/black.png')) {
                    $status['mainArtURL'] = $artUrl.'/none.png';
                }
                if (isset($status['radio']) && $status['radio'] && strpos(' '.$status['mainArtURL'], '/none.png')) {
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                }
                if (strpos(' '.$status['changed'], 'mixer') && $redis->get('volume')) {
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }
                $status['actPlayer'] = $activePlayer;
                // always save the current $status
                $redis->set('act_player_info', json_encode($status));

                // Global Random
                if ($redis->hGet('globalrandom', 'enable') && isset($status['state']) && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // post $status to the UI
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                if ($redis->hGet('globalrandom', 'enable') && (!isset($status['state']) || ($status['state'] === 'play')) && ($status['nextsongid'] === 0)) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                // start the job to retrieve extra metadata when coverart is enabled
                if ($coverartRequired) {
                    sysCmd('pgrep rune_MPDEM_wrk || systemctl start rune_MPDEM_wrk');
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
                }
                // debug information
                if (isset($socket['sockVarName']) && isset($socket['description'])) {
                    $sockVarName = $socket['sockVarName'];
                    global $$sockVarName;
                    $errorcode = socket_last_error($$sockVarName);
                    // when no error $errorcode = 0 (false)
                    runelog('MPD last socket error for '.$socket['description'].' = ', $errorcode.' ('.socket_strerror($errorcode).')');
                } else {
                    $errorcode = true;
                    runelog('MPD last socket error for unknown socket = ', 'Unspecified error');
                }
                // clean up the metadata, async and at low priority
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/clean_music_metadata_async.php');
            } while ((!$errorcode) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            //
            // Airplay
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Airplay'));
            }
            $airplay_timeout = $redis->hGet('airplay', 'timeout');
            $airplay_timeout_count = $airplay_timeout;
            $sleepUntilTime = microtime(true)+2;
            do {
                // sometimes shareport sync fails to terminate properly, the code fixes it, timing out after a specified time when nothing is playing.
                if (is_playing($redis)) {
                    runelog('rune_PL_wrk: Airplay is playing');
                    $airplay_timeout_count = $airplay_timeout;
                } else {
                    runelog('rune_PL_wrk: Airplay is not playing');
                    $airplay_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Airplay timeout count', $airplay_timeout_count);
                if ($airplay_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Airplay timeout initiated');
                    wrk_stopPlayer($redis);
                    $airplay_timeout_count = $airplay_timeout;
                    break;
                }
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            //
            // Spotify Connect
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Spotify connect'));
            }
            $redis->hSet('spotifyconnect', 'last_track_id', '');
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            $sleepUntilTime = microtime(true)+2;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                if (is_playing($redis)) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis);
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
            $redis->hSet('spotifyconnect', 'last_track_id', '');
        } else if ($activePlayer === 'Bluetooth') {
            //
            // Bluetooth
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                // $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE Bluetooth ----------------------------------');
                $status = initialise_playback_array($redis, 'Bluetooth');
                ui_render('playback', json_encode($status));
                $redis->set('act_player_info', json_encode($status));
                $audio = $status['audio'];
                $btDeviceName = $status['currentalbum'];
                $audio_channels = $status['audio_channels'];
                $audio_sample_depth = $status['audio_sample_depth'];
                $audio_sample_rate = intval($status['audio_sample_rate'] * 1000);
                $btDeviceName = $status['currentalbum'];
            }
            $bluetooth_timeout = $redis->hGet('bluetooth', 'timeout');
            $bluetooth_timeout_count = $bluetooth_timeout;
            $local_volume_control = $redis->hGet('bluetooth', 'local_volume_control');
            $status['local_volume_control'] = 0;
            $status['state'] = '';
            $bitrate = '~190';
            $sleepUntilTime = microtime(true)+2;
            $checkAudioCnt = 2;
            $checkVolumeCnt = 2;
            $state = '';
            $time = 120;
            $elapsed = 0;
            $song_percent = 0;
            $elapsedTimestamp = microtime(true);
            $volume = preg_replace('/[^0-9]/', '', sysCmd('mpc volume | xargs')[0]);
            $btDeviceName = '';
            do {
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('rune_PL_wrk: Bluetooth idle loop');
                // get a list of bluealsa pcms for input
                $pcmInfo = wrk_btcfg($redis, 'auto_volume');
                // test for something playing
                if (is_playing($redis) || (isset($pcmInfo['input']['running']) && $pcmInfo['input']['running'])) {
                    runelog('rune_PL_wrk: Bluetooth is playing');
                    $redis->hSet('bluetooth', 'initialising', 0);
                    $bluetooth_timeout_count = $bluetooth_timeout;
                    if ($state == 'play') {
                        if ($checkVolumeCnt-- <= 0) {
                            $elapsed = round(microtime(true) - $status['time_last_elapsed']);
                            if ($elapsed == 0) {
                                $song_percent = 0;
                            } else {
                                $song_percent = min(100, round((100 * $elapsed) / $time));
                            }
                            $redis->set('bluetoothrefresh', 0);
                            // repeat after 60 cycles (= 120 seconds)
                            $checkVolumeCnt = 60;
                        } else {
                            unset($elapsed, $song_percent, $status['elapsed'], $status['song_percent']);
                        }
                    } else {
                        $elapsed = 0;
                        $song_percent = 0;
                        $status['time_last_elapsed'] = microtime(true);
                    }
                    $state = 'play';
                    if (isset($pcmInfo['input']['running']) && $pcmInfo['input']['running']) {
                        if ($pcmInfo['input']['channels'] == 1) {
                            $audio_channels = 'Mono';
                        } else if ($pcmInfo['input']['channels'] == 2) {
                            $audio_channels = 'Stereo';
                        } else {
                            $audio_channels = 'Multichannel';
                        }
                        $audio_sample_depth = preg_replace('/[^0-9]/', '', $pcmInfo['input']['format']);
                        $audio_sample_rate = $pcmInfo['input']['sampling'];
                        $audio = $audio_sample_rate.':'.$audio_sample_depth.':'.$audio_channels_number;
                        $bitrate = '~190';
                        if (($redis->hGet('bluetooth', 'local_volume_control') != 'd')) {
                            $volume = round(($pcmInfo['input']['volume'] * 100) / 127);
                        } else {
                            $acard = json_decode($redis->hGet('acards', $redis->get('ao')), true);
                            if (isset($acard['mixer_control']) && $acard['mixer_control']) {
                                $card = get_between_data($acard['device'], ':', ',');
                                $mixerControl = $acard['mixer_control'];
                                $volume = sysCmd('amixer -c '.$card.' sget '.$mixerControl.' | grep "%" | xargs')[0];
                                $volume = get_between_data($volume, ' [', '%] ');
                            } else {
                                $volume = round(($pcmInfo['input']['volume'] * 100) / 127);
                            }
                        }
                    } else if ($checkAudioCnt-- <= 0) {
                        // a value of 5 for $checkAudioCnt means that this code is run every 10 seconds since the do loop has a 2 second cycle
                        $checkAudioCnt = 5;
                        if (($redis->hGet('bluetooth', 'local_volume_control') != 'd')) {
                            $volume = preg_replace('/[^0-9]/', '', sysCmd('mpc volume | xargs')[0]);
                        } else {
                            $acard = json_decode($redis->hGet('acards', $redis->get('ao')), true);
                            if (isset($acard['mixer_control']) && $acard['mixer_control']) {
                                $card = get_between_data($acard['device'], ':', ',');
                                $mixerControl = $acard['mixer_control'];
                                $volume = sysCmd('amixer -c '.$card.' sget '.$mixerControl.' | grep "%" | xargs')[0];
                                $volume = get_between_data($volume, ' [', '%] ');
                            } else {
                                $volume = preg_replace('/[^0-9]/', '', sysCmd('mpc volume | xargs')[0]);
                            }
                        }
                        $playing = trim(sysCmd('grep -vihs closed /proc/asound/card?/pcm?p/sub?/hw_params | xargs')[0]);
                        if ($playing) {
                            $audio_channels_number = preg_replace('/[^0-9]/', '', get_between_data($playing, 'channels: ', ' '));
                            if ($audio_channels_number == 1) {
                                $audio_channels = 'Mono';
                            } else if ($audio_channels_number == 2) {
                                $audio_channels = 'Stereo';
                            } else {
                                $audio_channels = 'Multichannel';
                            }
                            $audio_sample_depth = intval(preg_replace('/[^0-9]/', '', get_between_data($playing, 'format: ', ' ')));
                            $audio_sample_rate = intval(preg_replace('/[^0-9]/', '', get_between_data($playing, 'rate: ', ' ')));
                            $audio = $audio_sample_rate.':'.$audio_sample_depth.':'.$audio_channels_number;
                            $bitrate = '~190';
                        }
                    }
                    $local_volume_control = $redis->hGet('bluetooth', 'local_volume_control');
                    if (!isset($btDeviceName) || !$btDeviceName || ($btDeviceName == '-')) {
                        $btDeviceArray = wrk_btcfg($redis, 'status');
                        foreach ($btDeviceArray as $btDevice) {
                            if ($btDevice['connected'] && $btDevice['source']) {
                                $btDeviceName = $btDevice['name'];
                                break;
                            }
                        }
                        if (!isset($btDeviceName) || !$btDeviceName) {
                            $btDeviceName = '-';
                        }
                    }
                } else if ($redis->hGet('bluetooth', 'initialising')) {
                    runelog('rune_PL_wrk: Bluetooth is initialising');
                    $state = 'stop';
                    $elapsed = 0;
                    $song_percent = 0;
                    $status['time_last_elapsed'] = microtime(true);
                    $bluetooth_timeout_count = $bluetooth_timeout;
                } else {
                    runelog('rune_PL_wrk: Bluetooth is not playing');
                    $state = 'stop';
                    $elapsed = 0;
                    $song_percent = 0;
                    $status['time_last_elapsed'] = microtime(true);
                    $bluetooth_timeout_count -= 2;
                }
                if ($bluetooth_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Bluetooth timeout initiated');
                    wrk_stopPlayer($redis);
                    continue;
                }
                if (
                        ($audio != $status['audio']) ||
                        ($btDeviceName != $status['currentalbum']) ||
                        ($state != $status['state']) ||
                        ($local_volume_control != $status['local_volume_control']) ||
                        ($volume != $status['volume']) ||
                        ($time != $status['time']) ||
                        (isset($elapsed))
                        ) {
                    $status['state'] = $state;
                    $status['audio'] = $audio;
                    $status['audio_channels'] = $audio_channels;
                    $status['audio_sample_depth'] = $audio_sample_depth;
                    $status['audio_sample_rate'] = round($audio_sample_rate/1000, 1);
                    $status['currentalbum'] = $btDeviceName;
                    $status['currentsong'] = 'Streaming';
                    $status['bitrate'] = $bitrate;
                    $status['local_volume_control'] = $local_volume_control;
                    $status['volume'] = $volume;
                    $status['time'] = $time;
                    if (isset($elapsed)) {
                        $status['elapsed'] = $elapsed;
                        if (isset($song_percent)) {
                            $status['song_percent'] = $song_percent;
                        }
                    }
                    ui_render('playback', json_encode($status));
                    $redis->set('act_player_info', json_encode($status));
                }
                runelog('rune_PL_wrk: Bluetooth timeout count', $bluetooth_timeout_count);
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'Bluetooth');
            unset($status['local_volume_control']);
            sleep(1);
        } else {
            $forceupdate = 1;
            sleep(1);
        }
        $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
    sleep(1);
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!

