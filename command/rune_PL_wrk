#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/var/www/app/libs/runeaudio.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;

// --- WORKER MAIN LOOP --- //
while (1) {
    // Connect to Redis backend
    $redis = new Redis();
    $redis->pconnect('/run/redis/socket');
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    if ($activePlayer === 'MPD') {
        runelog('rune_PL_wrk: open MPD local UNIX socket');
        $socket = openMpdSocket('/run/mpd/socket', 0);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    } else if ($activePlayer === 'Spotify') {
        runelog('rune_PL_wrk: open SPOP socket');
        $socket = openSpopSocket('localhost', 6602, 1);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    }

    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect") && ($activePlayer !== "Snapcast")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                ui_update($redis, $socket, 0);
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
            }
            $status = array();
            $status = _parseStatusResponse($redis, MpdStatus($socket));
            // store next songid
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            $redis->set('lastsongid', $status['songid']);
            $redis->set('pl_length', $status['playlistlength']);
            // set the mpd volume if a value is available
            if ((!empty($redis->get('lastmpdvolume'))) && ($redis->hGet('mpdconf', 'mixer_type') != 'disabled')) {
                $lastmpdvolume = $redis->get('lastmpdvolume');
                $retries_volume = 20;
                do {
                    sleep(2);
                    // retry until MPD is up and returns the requested volume
                    $retval = sysCmd('mpc volume | grep "volume:" | cut -d ":" -f 2 | cut -d "%" -f 1');
                    $mpdvolume = trim($retval[0]);
                    unset($retval);
                    if ($lastmpdvolume == $mpdvolume) {
                        // make sure the UI has the correct value
                        sysCmd('mpc volume '.$mpdvolume);
                    } else if ($mpdvolume == 'n/a') {
                        // something wrong, mismatch between redis and mpd 'disabled' values
                        $retries_volume = 0;
                    } else {
                        // set the mpd volume, do a soft increase/decrease
                        $setvolume = $mpdvolume-round((($mpdvolume-$lastmpdvolume)/2), 0, PHP_ROUND_HALF_UP);
                        $retval = sysCmd('mpc volume '.$setvolume.' | grep "volume:" | cut -d ":" -f 2 | cut -d "%" -f 1');
                        $mpdvolume = trim($retval[0]);
                        unset($retval);
                    }
                } while (($lastmpdvolume != $mpdvolume) && (--$retries_volume > 0));
            }
            do {
                // idle LOOP
                runelog('rune_PL_wrk: enter idle loop');
                $status = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$status) {
                    break;
                }

                // store next songid
                $redis->set('nextsongid', $status['nextsongid']);
                // store "lastsongid"
                $redis->set('lastsongid', $status['songid']);
                $redis->set('pl_length', $status['playlistlength']);

                // runelog('---------status data------------',$status);
                $status = ui_status($socket, $status);
                runelog('---------status data(2)------------',$status);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync('ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}

                // EXPERIMENTAL decode radio song name and artist
                // curl -s -f --connect-timeout 5 -m 10 --retry 2 http://ws.audioscrobbler.com/2.0/?method=track.search&track=annie%20lennox%20why&api_key=ba8ad00468a50732a3860832eaed0882&format=json&limit=1
                runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                if (!is_null($status['radioname'])) {
                    $redis->hSet('lyrics', 'radio', 1);
                    $redis->hSet('lyrics', 'art', 'assets/img/cover-radio.jpg');
                    $redis->hSet('lyrics', 'arturl', '127.0.0.1/assets/img/cover-radio.jpg');
                    $status['currentalbum'] = $status['radioname'];
                    if (!is_null($status['currentsong']) && is_null($status['currentartist']) && $redis->hGet('service','internet')) {
                        $url = 'http://ws.audioscrobbler.com/2.0/?method=track.search&track='.$status['currentsong'].'&api_key='.$lastfm_apikey.'&format=json&limit=1';
                        $retval = json_decode(curlGet($url, $proxy), true);
                        if ($retval['results']['trackmatches']['track'][0]['name'] != '') {
                            $status['currentsong'] = $retval['results']['trackmatches']['track'][0]['name'];
                            $status['currentartist'] = $retval['results']['trackmatches']['track'][0]['artist'];
                        }
                        if ($retval['results']['trackmatches']['track'][0]['image'][3]['#text'] != '') {
                            $redis->hSet('lyrics','arturl', $retval['results']['trackmatches']['track'][0]['image'][3]['#text']);
                            $redis->hSet('lyrics','art', '');
                        }
                        unset($retval);
                        if (!is_null($status['currentsong']) && !is_null($status['currentartist'])) {
                            $url = 'http://ws.audioscrobbler.com/2.0/?method=track.getinfo&track='.$status['currentsong'].'&artist='.$status['currentartist'].'&api_key='.$lastfm_apikey.'&format=json';
                            $retval = json_decode(curlGet($url, $proxy), true);
                            if ($retval['track']['album']['image'][3]['#text'] != '') {
                                $redis->hSet('lyrics','arturl', $retval['track']['album']['image'][3]['#text']);
                                $redis->hSet('lyrics','art', '');
                            }
                            unset($retval);
                        }
                    }
                    if (is_null($status['currentartist'])) {
                        $status['currentartist'] = 'Streaming';
                    }
                    if (is_null($status['currentsong'])) {
                        $status['currentsong'] = 'Radio';
                    }
                } else {
                    $redis->hSet('lyrics', 'radio', 0);
                    $redis->hSet('lyrics', 'art', '');
                    $redis->hSet('lyrics', 'arturl', '');
                }

                // store information for lyrics and info
                if ( $status['currentartist'] == 'Streaming' && $status['currentsong'] == 'Radio' ) {
                    $redis->hSet('lyrics', 'currentartist', '');
                    $redis->hSet('lyrics', 'currentsong', '');
                    $redis->hSet('lyrics', 'currentalbum', '');
                } else {
                    $redis->hSet('lyrics', 'currentartist', lyricsStringClean($status['currentartist'], 'artist'));
                    $redis->hSet('lyrics', 'currentsong', lyricsStringClean($status['currentsong']));
                    $redis->hSet('lyrics', 'currentalbum', lyricsStringClean($status['currentalbum']));
                }

                if ($status['changed'] === 'mixer') {
                    //$redis->set('current_volume', $status['volume']);
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }

                // Global Random
                if (($redis->get('globalrandom') === '1') && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // save JSON response for extensions
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                If (($redis->get('globalrandom') === '1') && ($status['state'] === 'play') && ($redis->get('nextsongid') === '')) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                $status['actPlayer'] = "MPD";
                $redis->set('act_player_info', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('MPD last socket error = ', $errorcode);
                if (($redis->get('activePlayer') == 'MPD') && ($redis->hGet('spotifyconnect', 'track_id') == '')) {
                    $retval = sysCmd('mpc volume | grep "volume:" | cut -d ":" -f 2 | cut -d "%" -f 1');
                    $lastmpdvolume = preg_replace('/[^0-9]/', '', $retval[0]);
                    if (!empty($lastmpdvolume)) {
                        $redis->set('lastmpdvolume', $lastmpdvolume);
                    }
                    unset($retval);
                }
            } while (($errorcode === 0) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } elseif ($activePlayer === 'Spotify') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $status = array();
            do {
                $status = monitorSpopState($socket);
                $status['playlist'] = $redis->hGet('spotify', 'plversion');
                ui_render('playback', json_encode($status));
                runelog('rune_PL_wrk: UI JSON', $status);
                runelog('rune_PL_wrk: close SPOP socket');

                // store information for lyrics and info
                $redis->hSet('lyrics', 'currentartist', lyricsStringClean($status['currentartist'], 'artist'));
                $redis->hSet('lyrics', 'currentsong', lyricsStringClean($status['currentsong']));
                $redis->hSet('lyrics', 'currentalbum', lyricsStringClean($status['currentalbum']));

                // save JSON response for extensions
                $status['actPlayer'] = "Spotify";
                $redis->set('act_player_info', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('Spotify last socket error = ', $errorcode);
            } while  (($errorcode === 0) && ($redis->get('activePlayer') === 'Spotify'));
            closeSpopSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
                sysCmd('rm -f /srv/http/tmp/airplay/airplay-cover.*');
                $redis->hSet('lyrics', 'art', '/srv/http/tmp/airplay/airplay-default.png');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $redis->hSet('lyrics', 'audio', $status['audio']);
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "play";
                $status['time'] = "0";
                $redis->hSet('lyrics', 'time', $status['time']);
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentartist'] = "Airplay";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $redis->hSet('lyrics', 'artist', $status['currentartist']);
                $redis->hSet('lyrics', 'album', $status['currentalbum']);
                $redis->hSet('lyrics', 'song', $status['currentsong']);
                $status['actPlayer'] = "Airplay";
                $status['radioname'] = null;
                $status['OK'] = null;
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            do {
                sleep(2);
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
                // delete any existing cover art
                sysCmd('rm -f /srv/http/tmp/spotify-connect/spotify-connect-cover.*');
                $redis->hSet('lyrics', 'art', '/srv/http/tmp/spotify-connect/spotify-connect-default.png');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $redis->hSet('lyrics', 'audio', $status['audio']);
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "stop";
                $status['time'] = "0";
                $redis->hSet('lyrics', 'time', $status['time']);
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentartist'] = "SpotifyConnect";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $redis->hSet('lyrics', 'artist', $status['currentartist']);
                $redis->hSet('lyrics', 'album', $status['currentalbum']);
                $redis->hSet('lyrics', 'song', $status['currentsong']);
                $status['actPlayer'] = "SpotifyConnect";
                $status['radioname'] = null;
                $status['OK'] = null;
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                $playing = reset(sysCmd('cat /proc/asound/card*/pcm*p/sub*/hw_params | grep -c -i -v closed'));
                // $playing contains 0 or false when nothing is playing, otherwise a positive number like 7 (=true)
                runelog('rune_PL_wrk: $playing:', $playing);
                // if (($redis->hGet('spotifyconnect', 'event') != 'stop') || $playing) {
                if ($playing) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis, 'SpotifyConnect');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                sleep(2);
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
    } else if ($activePlayer === 'Snapcast') {
            if ($forceupdate !== 0) {
                    $forceupdate = 0;
                    runelog('---------------------------- FORCE UPDATE Snapcast ----------------------------------');
		    $redis->hSet('lyrics', 'art', '/srv/http/assets/img/snapcast.png');
//				$status = array();
                    if (!empty($redis->get('lastmpdvolume'))) {
                            $status['volume'] = $redis->get('lastmpdvolume');
                    }
                    $status['audio'] = "48000:16:2";
                    $status['audio_sample_rate'] = "48";
                    $status['audio_sample_depth'] = "16";
                    $status['bitrate'] = "1411";
                    $status['audio_channels'] = "Stereo";
                    $status['random'] = "0";
                    $status['single'] = "0";
                    $status['consume'] = "0";
                    $status['playlist'] = "";
                    $status['playlistlength'] = "";
                    $status['state'] = "play";
                    $status['time'] = "0";
                    $status['elapsed'] = "0";
                    $status['song_percent'] = "100";
                    $status['currentartist'] = "Snapcast";
                    $status['currentalbum'] = $redis->get('snapcast_host');
                    $status['currentsong'] = "-----";
                    $status['actPlayer'] = "Snapcast";
                    $status['radioname'] = null;
                    $status['OK'] = null;
                    // save JSON response for extensions
                    $redis->set('act_player_info', json_encode($status));
                    ui_render('playback', json_encode($status));
                    sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                    sysCmdAsync('/var/www/command/ui_update_async');
            }
            sleep(1);
    } else {
        $forceupdate = 1;
        sleep(1);
    }  
    $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!
