#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;
// initialise spotify connect last track ID
$redis->hSet('spotifyconnect', 'last_track_id', '');
// clear the spotify connect metadata queues
$redis->del('s_queue');
$redis->del('s_queue_fifo');

// --- WORKER MAIN LOOP --- //
while (true) {
    // connect to redis backend (pconnect reuses existing connections)
    $redis->pconnect('/run/redis/socket');
    // initialise variables
    $artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
    $artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
    if ($redis->get('remoteSSbigart') === 'album') {
        $bigartIsAlbum = true;
    } else {
        $bigartIsAlbum = false;
    }
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    // if ($activePlayer === 'MPD') {
        runelog('rune_PL_wrk: open MPD local UNIX socket');
        //$socket = openMpdSocket('/run/mpd/socket', 0);
        $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    // } else if ($activePlayer === 'Spotify') {
        // runelog('rune_PL_wrk: open SPOP socket');
        // $socket = openSpopSocket('localhost', 6602, 1);
        // if (!$socket) {
            // $redis->close();
            // sleep(5);
            // continue;
        // }
    // }

    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            $status = array();
            $newStatus = array();
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('----------------------------------- FORCE UPDATE MPD -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                $status = array_merge($status, initialise_playback_array($redis, 'MPD'));
                sysCmdAsync('/srv/http/command/ui_update_async 0', 0);
            }
            $newStatus = _parseStatusResponse($redis, MpdStatus($socket));
            if (isset($newStatus) || is_array($newStatus)) {
                $status = array_merge($status, $newStatus);
            }
            $newStatus = array();
            $status['actPlayer'] = $activePlayer;
            $redis->set('act_player_info', json_encode($status));
            ui_render('playback', json_encode($status));
            // store next songid
            if (!isset($status['nextsongid']) || !$status['nextsongid']) {
                $status['nextsongid'] = 0;
            }
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            if (!isset($status['songid'])) {
                $status['songid'] = 0;
            }
            $redis->set('lastsongid', $status['songid']);
            // store the playlist length
            if (!isset($status['playlistlength'])) {
                $status['playlistlength'] = 0;
            }
            $redis->set('pl_length', $status['playlistlength']);
            // set the mpd volume to the last value set via the UI, if a value is available and volume control is enabled
            // the streaming services can change the alsa volume, we want to change it back to the last set value
            set_last_mpd_volume($redis);
            $status = array_merge($status, array('currentartist' => '',
                'currentalbumartist' => '',
                'currentalbum' => '',
                'currentsong' => '',
                'file' => ''));
            $saveRadio = 'x';
            $saveCurrentsong = '';
            $saveFile = '';
            $status['mainArtURL'] = $artUrl.'/none.png';
            $status['smallArtURL'] = $artUrl.'/black.png';
            $status['bigArtURL'] = $artUrl.'/black.png';
            sysCmdAsync('/srv/http/command/ui_update_async', 0);
            do {
                //
                // idle LOOP
                //
                runelog('rune_PL_wrk: enter idle loop');
                $newStatus = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$newStatus || !is_array($newStatus)) {
                    // call close MPD socket to clean up the socket
                    closeMpdSocket($socket);
                    break;
                }
                if ($redis->get('activePlayer') != 'MPD') {
                    // no longer MPD, just break the loop
                    break;
                }
                // store next songid
                if (!isset($newStatus['nextsongid']) || !$newStatus['nextsongid']) {
                    $newStatus['nextsongid'] = 0;
                }
                $redis->set('nextsongid', $newStatus['nextsongid']);
                // store "lastsongid"
                if (!isset($newStatus['songid'])) {
                    $newStatus['songid'] = 0;
                }
                if (isset($newStatus['song'])) {
                    $redis->set('mpd_playback_lastnumber', $newStatus['song']+1);
                } else if (!$redis->get('mpd_playback_lastnumber')) {
                    $redis->set('mpd_playback_lastnumber', 1);
                }
                $redis->set('lastsongid', $newStatus['songid']);
                // store playlist length
                if (!isset($newStatus['playlistlength'])) {
                    $newStatus['playlistlength'] = 0;
                }
                $redis->set('pl_length', $newStatus['playlistlength']);

                // runelog('---------status data------------',$newStatus);
                $newStatus = ui_status($socket, $newStatus);
                // runelog('---------status data(2)------------',$newStatus);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync('ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}

                // make sure currentartist and file variables are set
                if (!isset($newStatus['currentartist'])) {
                    $newStatus['currentartist'] = '';
                }
                if (!isset($newStatus['file'])) {
                    $newStatus['file'] = '';
                }

                // set the radio flag and the radioname and currentalbum if required
                // webradio's sometimes act like they are just playing file as an url, in this case the currentalbum and radioname are not set
                // whenever the radioname is set, the currentalbum is also set to its value
                if ((!isset($newStatus['currentalbum']) || !$newStatus['currentalbum']) && (!isset($newStatus['radioname']) || !$newStatus['radioname'])) {
                    if (isset($radioUrl) && $radioUrl && ($radioUrl === $newStatus['file'])) {
                        // current file (url) is a radio url
                        $newStatus['currentalbum'] = $radioName;
                        $newStatus['radioname'] = $radioName;
                        $newStatus['radio'] = true;
                    } else {
                        // this routine checks whether the file (url) is a registered web radio and returns its name
                        $radioName = is_radioUrl($redis, $newStatus['file']);
                        if ($radioName) {
                            // current file (url) is a radio url
                            $radioUrl = $newStatus['file'];
                            $newStatus['currentalbum'] = $radioName;
                            $newStatus['radioname'] = $radioName;
                            $newStatus['radio'] = true;
                        } else {
                            $radioUrl = '';
                            $newStatus['radio'] = false;
                        }
                    }
                } else if (isset($newStatus['radioname']) && $newStatus['radioname']) {
                    // radioname is set, current file (url) is a radio url (this is how it should work)
                    $newStatus['radio'] = true;
                } else {
                    $newStatus['radio'] = false;
                }
                //
                // tweaks to only retrieve radio information after a second metadata record
                // some radio stations only send one metadata record (repeatedly), so really there is actually no metadata supplied
                if ($newStatus['radio']) {
                    // its a radio
                    if ($newStatus['file'] != $saveFile) {
                        // it is a radio and it is not the same as the last radio, so this is the first information from the webradio
                        $status = $newStatus;
                        $mpdChangeSong = false;
                        $saveRadio = $newStatus['radio'];
                        $saveCurrentsong = $newStatus['currentsong'];
                        $status['currentsong'] = $newStatus['currentsong'];
                        if ($status['currentsong'] === '') {
                            $status['currentsong'] = '...';
                        }
                        $status['currentartist'] = 'Webradio';
                        $status['currentalbumartist'] = 'Webradio';
                        $status['currentalbum'] = $newStatus['radioname'];
                        $status['currentcomposer'] = '...';
                        $saveFile = $newStatus['file'];
                        $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                        $newStatus['bigArtURL'] = $artUrl.'/none.png';
                        $newStatus['smallArtURL'] = $artUrl.'/none.png';
                    } else if ($newStatus['currentsong'] === '') {
                        // skip records when no metadata is passed
                        $newStatus['currentsong'] = $saveCurrentsong;
                        $mpdChangeSong = false;
                    }
                }
                //
                // determine what has been returned by MPD, it could be a new song or some sort of status change
                // the current $status will be filled with extra information for each new song, this information is not delivered by MPD,
                //  and it should not be lost, the routines which create this extra information are time consuming and should only be run
                //  when when a new song is detected
                if (($newStatus['radio'] === $saveRadio) && ($newStatus['currentsong'] === $saveCurrentsong) && ($newStatus['file'] === $saveFile)) {
                    // same song, just replace specific parts of $status
                    unset($newStatus['currentartist'],
                        $newStatus['currentalbumartist'],
                        $newStatus['currentalbum'],
                        $newStatus['currentsong'],
                        $newStatus['currentcomposer'],
                        $newStatus['file'],
                        $newStatus['fileext'],
                        $status['updating_db']);
                    $status = array_merge($status, $newStatus);
                    $mpdChangeSong = false;
                } else {
                    // it is not a radio or it is a new radio song, replace status
                    $status = $newStatus;
                    $mpdChangeSong = true;
                    $saveRadio = $newStatus['radio'];
                    $saveCurrentsong = $newStatus['currentsong'];
                    $saveFile = $newStatus['file'];
                }
                $newStatus = array();

                // decode radio song name and determine the metadata and albumart
                // $rts = 0;
                if ($mpdChangeSong && $status['radio'] && (!isset($status['currentartist']) || !$status['currentartist'])) {
                    runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                    if (isset($status['currentsong']) && $status['currentsong']) {
                        // $rts = time();
                        runelog('rune_PL_wrk: radio currentsong = ', $status['currentsong']);
                        $retval = wrk_get_webradio_art($redis, $status['currentsong']);
                        if ($redis->get('activePlayer') != 'MPD') {
                            // no longer MPD, just break the loop
                            break;
                        }
                        // $rts = time() - $rts;
                    } else {
                        $retval = false;
                        $status['currentsong'] = '';
                    }
                    $status['fileext'] = '';
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                    $status['bigArtURL'] = $artUrl.'/none.png';
                    $status['smallArtURL'] = $artUrl.'/none.png';
                    $status['currentalbum'] = $status['radioname'];
                    $status['currentalbumartist'] = '';
                    $status['currentartist'] = '';
                    if ($retval) {
                        // ui_notify('Radio success ', $rts.' seconds, change status '.$status['changed']);
                        if ($retval['song']) {
                            $status['currentsong'] = $retval['song'];
                        }
                        if ($retval['song_lyrics']) {
                            $status['song_lyrics'] = $retval['song_lyrics'];
                        }
                        if ($retval['artist']) {
                            $status['currentartist'] = $retval['artist'];
                            $status['currentalbumartist'] = $retval['artist'];
                        }
                        if ($retval['artist_bio_summary']) {
                            $status['artist_bio_summary'] = $retval['artist_bio_summary'];
                        }
                        if ($retval['artist_similar']) {
                            $status['artist_similar'] = $retval['artist_similar'];
                        }
                        if ($retval['artist_arturl']) {
                            if ($retval['artist_arturl'] == $artUrl.'/none.png') {
                                $retval['artist_arturl'] = stripcslashes($retval['album_arturl_medium']);
                            }
                            if ($bigartIsAlbum) {
                                $status['smallArtURL'] = $retval['artist_arturl'];
                            } else {
                                $status['bigArtURL'] = $retval['artist_arturl'];
                            }
                        }
                        if ($retval['album_arturl_large']) {
                            // when 'album_arturl_large' is set, 'album_arturl_medium' and 'album_arturl_small' are also set
                            // album art sourced from discogs is escaped, always remove with stripcslashes
                            if ($bigartIsAlbum) {
                                $status['mainArtURL'] = stripcslashes($retval['album_arturl_medium']);
                                $status['bigArtURL'] = stripcslashes($retval['album_arturl_medium']);
                            } else {
                                $status['mainArtURL'] = stripcslashes($retval['album_arturl_small']);
                                $status['smallArtURL'] = stripcslashes($retval['album_arturl_small']);
                            }
                        }
                    } else {
                        // ui_notify('Radio fail ', $rts.' seconds, change status '.$status['changed']);
                    }
                    if (!$status['currentartist']) {
                        $status['currentartist'] = 'Streaming';
                        $status['currentalbumartist'] = 'Streaming';
                    }
                    if (!$status['currentsong']) {
                        $status['currentsong'] = 'Radio';
                    }
                }
                if (strpos(' '.$status['changed'], 'mixer') && $redis->get('volume')) {
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }
                $status['actPlayer'] = $activePlayer;
                // always save the current $status
                $redis->set('act_player_info', json_encode($status));

                // Global Random
                if ($redis->hGet('globalrandom', 'enable') && isset($status['state']) && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // post $status to the UI
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                if ($redis->hGet('globalrandom', 'enable') && (!isset($status['state']) || ($status['state'] === 'play')) && ($status['nextsongid'] === 0)) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                // start the job to retrieve extra metadata
                // get the lock status
                $lock = $redis->get('lock_mpd_extra_metadata');
                runelog('lock status ', $lock);
                if (($lock === '0') || ($lock === '9')  || ($lock >= 9)) {
                    // start the job
                    sysCmdAsync('nice --adjustment=2 /srv/http/command/mpd_extra_metadata_async.php', 0);
                } else {
                    // just in case something goes wrong increment the lock value by 1
                    // when it reaches 9 (this should never happen) it will be processed as if there is no lock
                    $lock += 1;
                    $redis->set('lock_mpd_extra_metadata', $lock);
                }

                // debug information
                if (isset($socket['sockVarName']) && isset($socket['description'])) {
                    $sockVarName = $socket['sockVarName'];
                    global $$sockVarName;
                    $errorcode = socket_last_error($$sockVarName);
                    // when no error $errorcode = 0 (false)
                    runelog('MPD last socket error for '.$socket['description'].' = ', $errorcode.' ('.socket_strerror($errorcode).')');
                } else {
                    $errorcode = true;
                    runelog('MPD last socket error for unknown socket = ', 'Unspecified error');
                }
                // clean up the metadata, async and at low priority
                sysCmdAsync('nice --adjustment=10 /srv/http/command/clean_music_metadata_async.php');
            } while ((!$errorcode) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } elseif ($activePlayer === 'Spotify') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('----------------------------------- FORCE UPDATE Spotify -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                $status = array_merge($status, initialise_playback_array($redis, 'Spotify'));
                sysCmdAsync('/srv/http/command/ui_update_async', 0);
            }
            $status['radio'] = false;
            $status = array();
            do {
                $status = monitorSpopState($socket);
                $status['playlist'] = $redis->hGet('spotify', 'plversion');
                runelog('rune_PL_wrk: UI JSON', $status);
                runelog('rune_PL_wrk: close SPOP socket');
                // check the current player on each cycle
                $activePlayer = $redis->get('activePlayer');
                if ($activePlayer != 'Spotify') {
                    // call close Spotify socket to clean up the socket
                    closeSpopSocket($socket);
                    break;
                }
                // save JSON response for extensions
                $status['actPlayer'] = $activePlayer;
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('Spotify last socket error = ', $errorcode);
            } while  (($errorcode === 0) && ($redis->get('activePlayer') === 'Spotify'));
            closeSpopSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            //
            // Airplay
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Airplay'));
            }
            do {
                sleep(2);
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            //
            // Spotify Connect
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Spotify connect'));
            }
            $redis->hSet('spotifyconnect', 'last_track_id', '');
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            $sleepUntilTime = microtime(true)+2;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                $playing = sysCmd('cat /proc/asound/card*/pcm*p/sub*/hw_params | grep -civ closed')[0];
                // $playing contains 0 or false when nothing is playing, otherwise a positive number like 7 (=true)
                runelog('rune_PL_wrk: $playing:', $playing);
                if ($playing) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis, 'SpotifyConnect');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
            $redis->hSet('spotifyconnect', 'last_track_id', '');
        } else {
            $forceupdate = 1;
            sleep(1);
        }
        $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
    sleep(1);
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!

