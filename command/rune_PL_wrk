#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/var/www/app/libs/runeaudio.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;

// --- WORKER MAIN LOOP --- //
while (1) {
    // Connect to Redis backend
    $redis = new Redis();
    $redis->pconnect('/run/redis/socket');
    // initialise variables
    $artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
    $artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
    if ($redis->get('remoteSSbigart') === 'album') {
        $bigartIsAlbum = true;
    } else {
        $bigartIsAlbum = false;
    }
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    if ($activePlayer === 'MPD') {
        runelog('rune_PL_wrk: open MPD local UNIX socket');
        //$socket = openMpdSocket('/run/mpd/socket', 0);
        $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    } else if ($activePlayer === 'Spotify') {
        runelog('rune_PL_wrk: open SPOP socket');
        $socket = openSpopSocket('localhost', 6602, 1);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    }

    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                ui_update($redis, $socket, 0);
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
            }
            $status = array();
            $newStatus = array();
            $status = _parseStatusResponse($redis, MpdStatus($socket));
            if (!isset($status) || !is_array($status)) {
                $status = array();
            }
            // store next songid
            if (!isset($status['nextsongid']) || !$status['nextsongid']) {
                $status['nextsongid'] = 0;
            }
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            if (!isset($status['songid'])) {
                $status['songid'] = 0;
            }
            $redis->set('lastsongid', $status['songid']);
            // store the playlist length
            if (!isset($status['playlistlength'])) {
                $status['playlistlength'] = 0;
            }
            $redis->set('pl_length', $status['playlistlength']);
            // set the mpd volume to the last value set via the UI, if a value is available and volume control is enabled
            // the streaming services can change the alsa volume, we want to change it back to the last set value
            set_last_mpd_volume($redis);
            $status = array_merge($status, array('currentartist' => '',
                'currentalbumartist' => '',
                'currentalbum' => '',
                'currentsong' => '',
                'file' => ''));
            $saveRadio = 'x';
            $saveCurrentsong = '';
            $saveFile = '';
            $status['mainArtURL'] = $artUrl.'/none.png';
            $status['smallArtURL'] = $artUrl.'/mpd/black.png';
            $status['bigArtURL'] = $artUrl.'/mpd/black.png';
            do {
                // idle LOOP
                runelog('rune_PL_wrk: enter idle loop');
                $newStatus = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$newStatus || !is_array($newStatus)) {
                // if (!$newStatus) {
                    break;
                }
                // $monArray = monitorMpdState($redis, $socket);
                // // if we have lost the connection to mpd then break the loop
                // if (!$monArray) {
                    // break;
                // }
                // $status['currentartist'] = '';
                // $status['currentalbumartist'] = '';
                // $status['currentalbum'] = '';
                // $status['currentsong'] = '';
                // $status = array_merge($newStatus, $monArray);
                // store next songid
                if (!isset($newStatus['nextsongid']) || !$newStatus['nextsongid']) {
                    $newStatus['nextsongid'] = 0;
                }
                $redis->set('nextsongid', $newStatus['nextsongid']);
                // store "lastsongid"
                if (!isset($newStatus['songid'])) {
                    $newStatus['songid'] = 0;
                }
                $redis->set('lastsongid', $newStatus['songid']);
                // store playlist length
                if (!isset($newStatus['playlistlength'])) {
                    $newStatus['playlistlength'] = 0;
                }
                $redis->set('pl_length', $newStatus['playlistlength']);

                // runelog('---------status data------------',$newStatus);
                $newStatus = ui_status($socket, $newStatus);
                runelog('---------status data(2)------------',$newStatus);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync('ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}

                // make sure currentartist and file variables are set
                if (!isset($newStatus['currentartist'])) {
                    $newStatus['currentartist'] = '';
                }
                if (!isset($newStatus['file'])) {
                    $newStatus['file'] = '';
                }

                // set the radio flag and the radioname and currentalbum if required
                // webradio's sometimes act like they are just playing file as an url, in this case the currentalbum and radioname are not set
                // whenever the radioname is set, the currentalbum is also set to its value
                if ((!isset($newStatus['currentalbum']) || !$newStatus['currentalbum']) && (!isset($newStatus['radioname']) || !$newStatus['radioname'])) {
                    if (isset($radioUrl) && $radioUrl && ($radioUrl === $newStatus['file'])) {
                        // current file (url) is a radio url
                        $newStatus['currentalbum'] = $radioName;
                        $newStatus['radioname'] = $radioName;
                        $newStatus['radio'] = true;
                    } else {
                        // this routine checks whether the file (url) is a registered web radio and returns its name
                        $radioName = is_radioUrl($redis, $newStatus['file']);
                        if ($radioName) {
                            // current file (url) is a radio url
                            $radioUrl = $newStatus['file'];
                            $newStatus['currentalbum'] = $radioName;
                            $newStatus['radioname'] = $radioName;
                            $newStatus['radio'] = true;
                        } else {
                            $radioUrl = '';
                            $newStatus['radio'] = false;
                        }
                    }
                } else if (isset($newStatus['radioname']) && $newStatus['radioname']) {
                    // radioname is set, current file (url) is a radio url (this is how it should work)
                    $newStatus['radio'] = true;
                } else {
                    $newStatus['radio'] = false;
                }

                // determine what has been returned by MPD, it could be a new song or some sort of status change
                // the current $status will be filled with extra information for each new song, this information is not delivered by MPD,
                //  and it should not be lost, the routines which create this extra information are time consuming and should only be run
                //  when when a new song is detected
                if ((($newStatus['radio'] === $saveRadio) && ($newStatus['currentsong'] === $saveCurrentsong)) && ($newStatus['file'] === $saveFile)) {
                    // same song, just replace specific parts of $status
                    unset($newStatus['currentartist'],
                        $newStatus['currentalbumartist'],
                        $newStatus['currentalbum'],
                        $newStatus['currentsong'],
                        $newStatus['currentcomposer'],
                        $newStatus['file'],
                        $newStatus['fileext'],
                        $status['updating_db']);
                    $status = array_merge($status, $newStatus);
                    $mpdChangeSong = false;
                } else {
                    // not radio or new radio song, replace status
                    $status = $newStatus;
                    $mpdChangeSong = true;
                    $saveRadio = $newStatus['radio'];
                    $saveCurrentsong = $newStatus['currentsong'];
                    $saveFile = $newStatus['file'];
                }
                $newStatus = array();

                // decode radio song name and determine the metadata and albumart
                // $rts = 0;
                if ($mpdChangeSong && $status['radio'] && (!isset($status['currentartist']) || !$status['currentartist'])) {
                    runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                    if (isset($status['currentsong']) && $status['currentsong']) {
                        // $rts = time();
                        runelog('rune_PL_wrk: radio currentsong = ', $status['currentsong']);
                        $retval = wrk_get_webradio_art($redis, $status['currentsong']);
                        // $rts = time() - $rts;
                    } else {
                        $retval = false;
                        $status['currentsong'] = '';
                    }
                    $status['fileext'] = '';
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                    $status['bigArtURL'] = $artUrl.'/none.png';
                    $status['smallArtURL'] = $artUrl.'/none.png';
                    $status['currentalbum'] = $status['radioname'];
                    $status['currentalbumartist'] = '';
                    $status['currentartist'] = '';
                    if ($retval) {
                        // ui_notify('Radio success ', $rts.' seconds, change status '.$status['changed']);
                        if ($retval['song']) {
                            $status['currentsong'] = $retval['song'];
                        }
                        if ($retval['song_lyrics']) {
                            $status['song_lyrics'] = $retval['song_lyrics'];
                        }
                        if ($retval['artist']) {
                            $status['currentartist'] = $retval['artist'];
                            $status['currentalbumartist'] = $retval['artist'];
                        }
                        if ($retval['artist_bio_summary']) {
                            $status['artist_bio_summary'] = $retval['artist_bio_summary'];
                        }
                        if ($retval['artist_similar']) {
                            $status['artist_similar'] = $retval['artist_similar'];
                        }
                        if ($retval['artist_arturl']) {
                            if ($bigartIsAlbum) {
                                $status['smallArtURL'] = $retval['artist_arturl'];
                            } else {
                                $status['bigArtURL'] = $retval['artist_arturl'];
                            }
                        }
                        if ($retval['album_arturl_large']) {
                            // when 'album_arturl_large' is set, 'album_arturl_medium' and 'album_arturl_small' are also set
                            if ($bigartIsAlbum) {
                                $status['mainArtURL'] = $retval['album_arturl_medium'];
                                $status['bigArtURL'] = $retval['album_arturl_medium'];
                            } else {
                                $status['mainArtURL'] = $retval['album_arturl_small'];
                                $status['smallArtURL'] = $retval['album_arturl_small'];
                            }
                        }
                    } else {
                        // ui_notify('Radio fail ', $rts.' seconds, change status '.$status['changed']);
                    }
                    if (!$status['currentartist']) {
                        $status['currentartist'] = 'Streaming';
                        $status['currentalbumartist'] = 'Streaming';
                    }
                    if (!$status['currentsong']) {
                        $status['currentsong'] = 'Radio';
                    }
                }
                if (strpos(' '.$status['changed'], 'mixer')) {
                    //$redis->set('current_volume', $status['volume']);
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }
                $status['actPlayer'] = "MPD";
                $redis->set('act_player_info', json_encode($status));

                // Global Random
                if ($redis->hGet('globalrandom', 'enable') && isset($status['state']) && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // save JSON response for extensions
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                If ($redis->hGet('globalrandom', 'enable') && (!isset($status['state']) || ($status['state'] === 'play')) && ($status['nextsongid'] === 0)) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                if (isset($socket['sockVarName']) && isset($socket['description'])) {
                    $sockVarName = $socket['sockVarName'];
                    global $$sockVarName;
                    $errorcode = socket_last_error($$sockVarName);
                    // when no error $errorcode = 0 (false)
                    runelog('MPD last socket error for '.$socket['description'].' = ', $errorcode.' ('.socket_strerror($errorcode).')');
                } else {
                    $errorcode = true;
                    runelog('MPD last socket error for unknown socket = ', 'Unspecified error');
                }
                wrk_clean_music_metadata($redis);
            } while ((!$errorcode) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } elseif ($activePlayer === 'Spotify') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('----------------------------------- FORCE UPDATE -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $status['radio'] = false;
            $status = array();
            do {
                $status = monitorSpopState($socket);
                $status['playlist'] = $redis->hGet('spotify', 'plversion');
                runelog('rune_PL_wrk: UI JSON', $status);
                runelog('rune_PL_wrk: close SPOP socket');
                // save JSON response for extensions
                $status['actPlayer'] = "Spotify";
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('Spotify last socket error = ', $errorcode);
            } while  (($errorcode === 0) && ($redis->get('activePlayer') === 'Spotify'));
            closeSpopSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            $status['radio'] = false;
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "play";
                $status['time'] = "0";
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentalbumartist'] = "Airplay";
                $status['currentartist'] = "Airplay";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $status['actPlayer'] = "Airplay";
                $status['radioname'] = null;
                $status['OK'] = null;
                $status['mainArtURL'] = $artUrl.'/airplay.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            do {
                sleep(2);
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            $status['radio'] = false;
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
//				$status = array();
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                }
                $status['audio'] = "44100:16:2";
                $status['audio_sample_rate'] = "44.1";
                $status['audio_sample_depth'] = "16";
                $status['bitrate'] = "1411";
                $status['audio_channels'] = "Stereo";
                $status['random'] = "0";
                $status['single'] = "0";
                $status['consume'] = "0";
                $status['playlist'] = "";
                $status['playlistlength'] = "";
                $status['state'] = "stop";
                $status['time'] = "0";
                $status['elapsed'] = "0";
                $status['song_percent'] = "100";
                $status['currentalbumartist'] = "SpotifyConnect";
                $status['currentartist'] = "SpotifyConnect";
                $status['currentalbum'] = "-----";
                $status['currentsong'] = "-----";
                $status['actPlayer'] = "SpotifyConnect";
                $status['radioname'] = null;
                $status['OK'] = null;
                $status['mainArtURL'] = $artUrl.'/spotify-connect.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
                // save JSON response for extensions
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                sysCmdAsync('/var/www/command/ui_update_async');
            }
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                $playing = reset(sysCmd('cat /proc/asound/card*/pcm*p/sub*/hw_params | grep -c -i -v closed'));
                // $playing contains 0 or false when nothing is playing, otherwise a positive number like 7 (=true)
                runelog('rune_PL_wrk: $playing:', $playing);
                // if (($redis->hGet('spotifyconnect', 'event') != 'stop') || $playing) {
                if ($playing) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis, 'SpotifyConnect');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                sleep(2);
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
        } else {
            $forceupdate = 1;
            sleep(1);
        }
        $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!

