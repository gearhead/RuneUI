#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_PL_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_PL_wrk.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
error_reporting(E_ALL & ~E_NOTICE);

// reset worker logfile
sysCmd('echo "--------------- start: rune_PL_wrk ---------------" > /var/log/runeaudio/rune_PL_wrk.log');
runelog('WORKER rune_PL_wrk START');
// reset forceupdate state
$forceupdate = 1;
// initialise spotify connect last track ID
$redis->hSet('spotifyconnect', 'last_track_id', '');
// clear the spotify connect metadata queues
$redis->del('s_queue');
$redis->del('s_queue_fifo');

// --- WORKER MAIN LOOP --- //
while (true) {
    // connect to redis backend (pconnect reuses existing connections)
    $redis->pconnect('/run/redis/socket');
    // initialise variables
    $artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
    $artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
    // when coverart is switched off some background jobs are not required
    $coverartRequired = $redis->get('coverart');
    if (($redis->get('remoteSStime') != -1) || ($redis->hGet('local_browser', 'localSStime') != -1)) {
        // when a screensaver is switched on (value not = -1) the coverart routines are also required
        $coverartRequired = true;
    }
    if ($redis->get('remoteSSbigart') === 'album') {
        $bigartIsAlbum = true;
    } else {
        $bigartIsAlbum = false;
    }
    $activePlayer = $redis->get('activePlayer');
    $proxy = $redis->hGetall('proxy');
    $lastfm_apikey = $redis->get('lastfm_apikey');
    // if ($activePlayer === 'MPD') {
        runelog('rune_PL_wrk: open MPD local UNIX socket');
        //$socket = openMpdSocket('/run/mpd/socket', 0);
        $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
        if (!$socket) {
            $redis->close();
            sleep(5);
            continue;
        }
    // } else if ($activePlayer === 'Spotify') {
        // runelog('rune_PL_wrk: open SPOP socket');
        // $socket = openSpopSocket('localhost', 6602, 1);
        // if (!$socket) {
            // $redis->close();
            // sleep(5);
            // continue;
        // }
    // }

    if (!$socket && ($activePlayer !== "Airplay") && ($activePlayer !== "SpotifyConnect")) {
        // exit script
        // die();
        runelog('rune_PL_wrk: no valid socket or streamer');
        $forceupdate = 1;
        sleep(3);
    } else {
        // MPD playback engine
        if ($activePlayer === 'MPD') {
            $status = array();
            $newStatus = array();
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('----------------------------------- FORCE UPDATE MPD -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                $status = array_merge($status, initialise_playback_array($redis, 'MPD'));
                $status['mainArtURL'] = $artUrl.'/none.png';
                $status['smallArtURL'] = $artUrl.'/black.png';
                $status['bigArtURL'] = $artUrl.'/black.png';
            }
            $newStatus = _parseStatusResponse($redis, MpdStatus($socket));
            if (isset($newStatus) || is_array($newStatus)) {
                $status = array_merge($status, $newStatus);
            } else {
                // no status returned, assume mpd not yet ready
                if ($socket) {
                    closeMpdSocket($socket);
                }
                ui_render('playback', json_encode($status));
                continue;
            }
            $newStatus = array();
            $status['actPlayer'] = $activePlayer;
            $redis->set('act_player_info', json_encode($status));
            ui_render('playback', json_encode($status));
            // start the job to retrieve extra metadata when it is not a radio and coverart is enabled
            if (!$status['radio'] && $coverartRequired) {
                // it may already be running, check first
                $retval = sysCmd('systemctl is-active rune_MPDEM_wrk')[0];
                if ($retval != 'active') {
                    sysCmd('systemctl start rune_MPDEM_wrk');
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
                }
            }
            // store next songid
            if (!isset($status['nextsongid']) || !$status['nextsongid']) {
                $status['nextsongid'] = 0;
            }
            $redis->set('nextsongid', $status['nextsongid']);
            // store "lastsongid"
            if (!isset($status['songid'])) {
                $status['songid'] = 0;
            }
            $redis->set('lastsongid', $status['songid']);
            // store the playlist length
            if (!isset($status['playlistlength'])) {
                $status['playlistlength'] = 0;
            }
            $redis->set('pl_length', $status['playlistlength']);
            // set the mpd volume to the last value set via the UI, if a value is available and volume control is enabled
            // the streaming services can change the alsa volume, we want to change it back to the last set value
            set_last_mpd_volume($redis);
            $status = array_merge($status, array('currentartist' => '',
                'currentalbumartist' => '',
                'currentalbum' => '',
                'currentsong' => '',
                'file' => ''));
            $saveRadio = 'x';
            $saveCurrentsong = '';
            $saveCurrentartist = '';
            $saveCurrentalbum = '';
            $saveFile = '';
            $saveChanged = '';
            $subscriptionCnt = 1;
            $mpdFixFile = '';
            do {
                //
                // idle LOOP
                //
                runelog('rune_PL_wrk: enter idle loop');
                $newStatus = monitorMpdState($redis, $socket);
                // if we have lost the connection to mpd then break the loop
                if (!$newStatus || !is_array($newStatus)) {
                    // call close MPD socket to clean up the socket
                    if ($socket) {
                        closeMpdSocket($socket);
                    }
                    break;
                }
                if ($redis->get('activePlayer') != 'MPD') {
                    // no longer MPD, just break the loop
                    if ($socket) {
                        closeMpdSocket($socket);
                    }
                    break;
                }
                // we use the mpd subscribe and unsubscribe to channels to trigger an idle interrupt, we need to do it twice, but
                //  only need to react once
                if (($newStatus['changed'] == 'subscription:OK') && ($newStatus['changed'] == $saveChanged)) {
                    // the subscription changed type come in 3's or 4's after each other, process the first one and skip any others
                    //  which follow sequentially
                    if ($subscriptionCnt-- > 0) {
                        continue;
                    } else {
                        // process every second one
                        $subscriptionCnt = 1;
                    }
                } else if (strpos(' '.$newStatus['changed'], 'subscription')) {
                    // when any other type of 'changed' event happens together with a subscription always process it, but set
                    //  the saved changed value as if it happened alone
                    $saveChanged = 'subscription:OK';
                } else {
                    $saveChanged = $newStatus['changed'];
                }
                // store next songid
                if (!isset($newStatus['nextsongid']) || !$newStatus['nextsongid']) {
                    $newStatus['nextsongid'] = 0;
                }
                $redis->set('nextsongid', $newStatus['nextsongid']);
                // store "lastsongid"
                if (!isset($newStatus['songid'])) {
                    $newStatus['songid'] = 0;
                }
                if (isset($newStatus['song'])) {
                    $redis->set('mpd_playback_lastnumber', $newStatus['song']+1);
                } else if (!$redis->get('mpd_playback_lastnumber')) {
                    $redis->set('mpd_playback_lastnumber', 1);
                }
                $redis->set('lastsongid', $newStatus['songid']);
                // store playlist length
                if (!isset($newStatus['playlistlength'])) {
                    $newStatus['playlistlength'] = 0;
                }
                $redis->set('pl_length', $newStatus['playlistlength']);
                //
                // runelog('---------status data------------',$newStatus);
                $newStatus = ui_status($socket, $newStatus);
                // debug
                // echo "Radioname: ".$newStatus['radioname'].", changed: ".$newStatus['changed'].", playlistlength: ".$newStatus['playlistlength'].", currentsong: ".$newStatus['currentsong']."\n";
                runelog('$newStatus', "Radioname: ".$newStatus['radioname'].", changed: ".$newStatus['changed'].", playlistlength: ".$newStatus['playlistlength'].", currentsong: ".$newStatus['currentsong']);
                // runelog('---------status data(2)------------', $newStatus);
                // render Queue (push async)
                //if ($status['changed'] === 'playlist') {
                //    sysCmdAsync($redis, 'ui_render_pl');
                //    runelog('---------------- PLAYLIST RENDER ----------------');
                //}
                //
                // set the radio flag and the radioname and currentalbum if required
                // webradio's sometimes act like they are just playing file as an url, in this case the currentalbum and radioname are not set
                // whenever the radioname is set, the currentalbum is also set to its value
                if ((!isset($newStatus['currentalbum']) || !$newStatus['currentalbum']) && (!isset($newStatus['radioname']) || !$newStatus['radioname'])) {
                    if (isset($radioUrl) && $radioUrl && ($radioUrl === $newStatus['file'])) {
                        // current file (url) is a radio url
                        $newStatus['currentalbum'] = $radioName;
                        $newStatus['radioname'] = $radioName;
                        $newStatus['radio'] = true;
                    } else {
                        // this routine checks whether the file (url) is a registered web radio and returns its name
                        $radioName = is_radioUrl($redis, $newStatus['file']);
                        if ($radioName) {
                            // current file (url) is a radio url
                            $radioUrl = $newStatus['file'];
                            $newStatus['currentalbum'] = $radioName;
                            $newStatus['radioname'] = $radioName;
                            $newStatus['radio'] = true;
                        } else {
                            $radioUrl = '';
                            $newStatus['radioname'] = '';
                            $newStatus['radio'] = false;
                        }
                    }
                } else if (isset($newStatus['radioname']) && $newStatus['radioname']) {
                    // radioname is set, current file (url) is a radio url (this is how it should work)
                    $newStatus['currentalbum'] = $newStatus['radioname'];
                    $newStatus['radio'] = true;
                } else {
                    $radioUrl = '';
                    $newStatus['radioname'] = '';
                    $newStatus['radio'] = false;
                }
                // the redis variable 'act_player_info' also gets modified in the script rune_MPDEM_wrk, refresh it here
                //  also update the variable, this acts as a sort of optimistic lock
                //  updates of 'act_player_info' in this script have priority over updates carried out in rune_MPDEM_wrk
                //  the updates of act_player_info are tracked in rune_MPDEM_wrk which acts appropriately
                $retval = $redis->get('act_player_info');
                $redis->set('act_player_info', $retval);
                $status = json_decode($retval, true);
                unset($retval);
                //
                // tweaks to only retrieve radio information after a second metadata record
                // some radio stations only send one metadata record (repeatedly), so really there is actually no metadata supplied
                $mpdChangeSong = true;
                if ($newStatus['radio']) {
                    // its a radio
                    $newStatus['time'] = 100;
                    $now = microtime(true);
                    if ($newStatus['file'] != $saveFile) {
                        // it is a radio and it is not the same as the last radio, so this is the first information from the webradio
                        // $saveFile = $newStatus['file'];
                        $saveRadio = $newStatus['radio'];
                        $newStatus['currentsong'] = '...';
                        $newStatus['currentartist'] = 'Webradio';
                        $newStatus['currentalbumartist'] = 'Webradio';
                        $newStatus['currentalbum'] = $newStatus['radioname'];
                        $newStatus['currentcomposer'] = '...';
                        $newStatus['song_lyrics'] = ' ';
                        $newStatus['artist_bio_summary'] = ' ';
                        $newStatus['artist_similar'] = ' ';
                        $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                        $newStatus['bigArtURL'] = $artUrl.'/none.png';
                        $newStatus['smallArtURL'] = $artUrl.'/none.png';
                        $newStatus['elapsed'] = 0;
                        $newStatus['time_last_elapsed'] = $now;
                        $newStatus['song_percent'] = 0;
                        $status = $newStatus;
                        $mpdChangeSong = false;
                        $pauseTime = 0;
                    } else if ($newStatus['currentsong'] === '') {
                        // skip records when no metadata is passed
                        $newStatus['currentsong'] = $saveCurrentsong;
                        $mpdChangeSong = false;
                    } else if (!strpos(' '.$newStatus['currentsong'],' - ')) {
                        // it is a radio and there is no space-hyphen-space in the song name, this indicates an information message and not an artist/album string
                        // $saveFile = $newStatus['file'];
                        $saveRadio = $newStatus['radio'];
                        $newStatus['currentartist'] = 'Webradio';
                        $newStatus['currentalbumartist'] = 'Webradio';
                        $newStatus['currentalbum'] = $newStatus['radioname'];
                        $newStatus['currentcomposer'] = '...';
                        $newStatus['song_lyrics'] = ' ';
                        $newStatus['artist_bio_summary'] = ' ';
                        $newStatus['artist_similar'] = ' ';
                        $newStatus['mainArtURL'] = $artUrl.'/radio.png';
                        $newStatus['bigArtURL'] = $artUrl.'/none.png';
                        $newStatus['smallArtURL'] = $artUrl.'/none.png';
                        $status = $newStatus;
                        $mpdChangeSong = false;
                    }
                    if ($newStatus['state'] === 'play') {
                        // (save and) post the playback data to the UI
                        $status['elapsed'] = round($status['elapsed'] + ($now - $status['time_last_elapsed']));
                        if ($pauseTime) {
                            $status['elapsed'] = round($status['elapsed'] - ($now - $pauseTime));
                        }
                        $status['time_last_elapsed'] = $now;
                        $status['song_percent'] = min(100, round(100*$status['elapsed']/$status['time']));
                        $pauseTime = 0;
                        unset($newStatus['elapsed'], $newStatus['time_last_elapsed'], $newStatus['song_percent']);
                    } else if ($newStatus['state'] === 'pause') {
                        $status['elapsed'] = round($status['elapsed'] + ($now - $status['time_last_elapsed']));
                        if ($pauseTime) {
                            $status['elapsed'] = round($status['elapsed'] - ($now - $pauseTime));
                        }
                        $status['time_last_elapsed'] = $now;
                        $status['song_percent'] = min(100, round(100*$status['elapsed']/$status['time']));
                        $pauseTime = $status['time_last_elapsed'];
                        unset($newStatus['elapsed'], $newStatus['time_last_elapsed'], $newStatus['song_percent']);
                    } else if ($newStatus['state'] === 'stop') {
                        $status['elapsed'] = 0;
                        $status['time_last_elapsed'] = $now;
                        $status['song_percent'] = 0;
                        $pauseTime = 0;
                        unset($newStatus['elapsed'], $newStatus['time_last_elapsed'], $newStatus['song_percent']);
                    }
                }
                if (!$newStatus['radio']) {
                    // its not a radio, try fixing the display data from cached values
                    if ($newStatus['file'] && ($newStatus['file'] != $mpdFixFile)) {
                        // for this file we have not fixed the MPD info
                        if ($coverartRequired) {
                            // coverart is switched on, so fit it
                            $newStatus = ui_mpd_fix($redis, $newStatus);
                        }
                        $mpdFixFile = $newStatus['file'];
                    } else {
                        // the UI remembers the last values
                        unset($newStatus['bitrate'], $newStatus['audio_sample_rate'], $newStatus['audio_sample_depth']);
                    }
                }
                if (($status['state'] === 'play') && ($newStatus['state'] === 'stop')) {
                    unset($newStatus['time']);
                    $newStatus['elapsed'] = 0;
                }
                //
                // determine what has been returned by MPD, it could be a new song or some sort of status change
                // the current $status will be filled with extra information for each new song, this information is not delivered by MPD,
                //  and it should not be lost, the routines which create this extra information are time consuming and should only be run
                //  when when a new song is detected
                if (($newStatus['radio'] === $saveRadio) && ($newStatus['currentsong'] === $saveCurrentsong) && ($newStatus['file'] === $saveFile)) {
                    // same song, just replace specific parts of $status
                    unset($newStatus['currentartist'],
                        $newStatus['currentalbumartist'],
                        $newStatus['currentalbum'],
                        $newStatus['currentsong'],
                        $newStatus['currentcomposer'],
                        $newStatus['file'],
                        $newStatus['fileext'],
                        $status['updating_db']);
                    $status = array_merge($status, $newStatus);
                    $mpdChangeSong = false;
                } else {
                    // radio is togged, new radio station or new song, replace status
                    $status = array_merge($status, $newStatus);
                    if (!$newStatus['radio'] && !$mpdChangeSong) {
                        // don't switch the changed song status for radios when it is already set to false
                        $mpdChangeSong = true;
                    }
                    $saveRadio = $status['radio'];
                    $saveCurrentsong = $status['currentsong'];
                    $saveFile = $status['file'];
                    $status['song_lyrics'] = ' ';
                    if (($status['currentartist'] != $saveCurrentartist) || ($status['currentartist'] == '') || ($status['currentartist'] == 'Webradio')) {
                        $status['artist_bio_summary'] = ' ';
                        $status['artist_similar'] = ' ';
                        $status['bigArtURL'] = $artUrl.'/none.png';
                        $status['smallArtURL'] = $artUrl.'/none.png';
                    }
                    $saveCurrentartist = $status['currentartist'];
                    if (($status['currentalbum'] != $saveCurrentalbum) || ($status['currentalbum'] == '') || ($status['currentalbum'] == 'Webradio')) {
                        if ($status['radio']) {
                            $status['mainArtURL'] = $artUrl.'/radio.png';
                        } else {
                            $status['mainArtURL'] = $artUrl.'/none.png';
                        }
                    }
                    $saveCurrentalbum = $status['currentalbum'];
                }
                //
                $newStatus = array();
                //
                // decode radio song name and determine the metadata and albumart
                // $rts = 0;
                if ($mpdChangeSong && $status['radio'] && (!isset($status['currentartist']) || !$status['currentartist'])) {
                    runelog('rune_PL_wrk: radioname = ', $status['radioname']);
                    if (isset($status['currentsong']) && $status['currentsong'] && $coverartRequired) {
                        // $rts = time();
                        runelog('rune_PL_wrk: radio currentsong = ', $status['currentsong']);
                        $retval = wrk_get_webradio_art($redis, $status['currentsong']);
                        if ($redis->get('activePlayer') != 'MPD') {
                            // no longer MPD, just break the loop
                            break;
                        }
                        // $rts = time() - $rts;
                    } else {
                        // currentsong has no value or coverart is switched off
                        $retval = false;
                        $status['currentsong'] = '';
                    }
                    $status['fileext'] = '';
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                    $status['bigArtURL'] = $artUrl.'/none.png';
                    $status['smallArtURL'] = $artUrl.'/none.png';
                    $status['currentalbum'] = $status['radioname'];
                    $status['currentalbumartist'] = '';
                    $status['currentartist'] = '';
                    if ($retval) {
                        // ui_notify('Radio success ', $rts.' seconds, change status '.$status['changed']);
                        if ($retval['song']) {
                            $status['currentsong'] = $retval['song'];
                        }
                        if ($retval['song_lyrics']) {
                            $status['song_lyrics'] = $retval['song_lyrics'];
                        }
                        if ($retval['artist']) {
                            $status['currentartist'] = $retval['artist'];
                            $status['currentalbumartist'] = $retval['artist'];
                        }
                        if ($retval['artist_bio_summary']) {
                            $status['artist_bio_summary'] = $retval['artist_bio_summary'];
                        }
                        if ($retval['artist_similar']) {
                            $status['artist_similar'] = $retval['artist_similar'];
                        }
                        if ($retval['album_arturl_large']) {
                            // when 'album_arturl_large' is set, 'album_arturl_medium' and 'album_arturl_small' are also set
                            // album art sourced from discogs is escaped, always remove with stripcslashes
                            if ($bigartIsAlbum) {
                                $status['mainArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                $status['bigArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                            } else {
                                $status['mainArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                $status['smallArtURL'] = trim(stripcslashes($retval['album_arturl_small']));
                            }
                        }
                        if ($retval['artist_arturl']) {
                            if ($bigartIsAlbum) {
                                if (strpos(' '.$retval['artist_arturl'], '/none.png')) {
                                    $status['smallArtURL'] = trim(stripcslashes($retval['album_arturl_small']));
                                } else {
                                    $status['smallArtURL'] = trim(stripcslashes($retval['artist_arturl']));
                                }
                            } else {
                                if (strpos(' '.$retval['artist_arturl'], '/none.png')) {
                                    $status['bigArtURL'] = trim(stripcslashes($retval['album_arturl_medium']));
                                } else {
                                    $status['bigArtURL'] = trim(stripcslashes($retval['artist_arturl']));
                                }
                            }
                        }
                    } else {
                        // ui_notify('Radio fail ', $rts.' seconds, change status '.$status['changed']);
                    }
                    if (!$status['currentartist']) {
                        $status['currentartist'] = 'Streaming';
                        $status['currentalbumartist'] = 'Streaming';
                    }
                    if (!$status['currentsong']) {
                        $status['currentsong'] = 'Radio';
                    }
                }
                // this is a catchall when the main art url is not set or incorrectly set for radio
                if (!$status['mainArtURL']) {
                    $status['mainArtURL'] = $artUrl.'/none.png';
                }
                if ($status['radio'] && strpos(' '.$status['mainArtURL'], '/none.png')) {
                    $status['mainArtURL'] = $artUrl.'/radio.png';
                }                
                if (strpos(' '.$status['changed'], 'mixer') && $redis->get('volume')) {
                    if ($redis->get('ao') === 'PianoDACPlus' && $redis->hget('mpdconf', 'mixer_type') === 'hardware') {
                        sysCmd('amixer -D '.json_decode($redis->hget('acards', 'PianoDACPlus'))->mixer_device.' set Subwoofer '.$status['volume'].'%');
                    }
                }
                $status['actPlayer'] = $activePlayer;
                // always save the current $status
                $redis->set('act_player_info', json_encode($status));

                // Global Random
                if ($redis->hGet('globalrandom', 'enable') && isset($status['state']) && ($status['state'] === 'stop') && ($redis->get('lock_globalrandom') === '1')) {
                    // MPD now stopped, the last track was the last in the queue, ashuffle will start a new track in this status
                    // to avoid displaying the first track in the queue force a UI update and skip the UI render step
                    ui_update($redis, $socket, 0);
                    // skip only once
                    $redis->set('lock_globalrandom', 0);
                } else {
                    // normal process render the UI
                    // post $status to the UI
                    runelog('rune_PL_wrk: ui_render() response', json_encode($status));
                    ui_render('playback', json_encode($status));
                }
                if ($redis->hGet('globalrandom', 'enable') && (!isset($status['state']) || ($status['state'] === 'play')) && ($status['nextsongid'] === 0)) {
                    // now playing the last track in the queue
                    $redis->set('lock_globalrandom', 1);
                } else {
                    // in all other circumstances do not skip
                    $redis->set('lock_globalrandom', 0);
                }
                // start the job to retrieve extra metadata when it is not a radio and coverart is enabled
                if (!$status['radio'] && $coverartRequired) {
                    // it may already be running, check first
                    $retval = sysCmd('systemctl is-active rune_MPDEM_wrk')[0];
                    if ($retval != 'active') {
                        sysCmd('systemctl start rune_MPDEM_wrk');
                        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
                    }
                }
                // debug information
                if (isset($socket['sockVarName']) && isset($socket['description'])) {
                    $sockVarName = $socket['sockVarName'];
                    global $$sockVarName;
                    $errorcode = socket_last_error($$sockVarName);
                    // when no error $errorcode = 0 (false)
                    runelog('MPD last socket error for '.$socket['description'].' = ', $errorcode.' ('.socket_strerror($errorcode).')');
                } else {
                    $errorcode = true;
                    runelog('MPD last socket error for unknown socket = ', 'Unspecified error');
                }
                // clean up the metadata, async and at low priority
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/clean_music_metadata_async.php');
            } while ((!$errorcode) && ($redis->get('activePlayer') === 'MPD'));

            // close Redis connection
            //$redis->close();
            runelog('rune_PL_wrk: close MPD local UNIX socket');
            closeMpdSocket($socket);
            $forceupdate = 1;
        } elseif ($activePlayer === 'Spotify') {
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('----------------------------------- FORCE UPDATE Spotify -----------------------------------');
                sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                $status = array_merge($status, initialise_playback_array($redis, 'Spotify'));
                sysCmdAsync($redis, '/srv/http/command/ui_update_async', 0);
            }
            $status['radio'] = false;
            $status = array();
            do {
                $status = monitorSpopState($socket);
                $status['playlist'] = $redis->hGet('spotify', 'plversion');
                runelog('rune_PL_wrk: UI JSON', $status);
                runelog('rune_PL_wrk: close SPOP socket');
                // check the current player on each cycle
                $activePlayer = $redis->get('activePlayer');
                if ($activePlayer != 'Spotify') {
                    // call close Spotify socket to clean up the socket
                    closeSpopSocket($socket);
                    break;
                }
                // save JSON response for extensions
                $status['actPlayer'] = $activePlayer;
                $redis->set('act_player_info', json_encode($status));
                ui_render('playback', json_encode($status));
                $errorcode = socket_last_error($socket);
                runelog('Spotify last socket error = ', $errorcode);
            } while  (($errorcode === 0) && ($redis->get('activePlayer') === 'Spotify'));
            closeSpopSocket($socket);
            $forceupdate = 1;
        } else if ($activePlayer === 'Airplay') {
            //
            // Airplay
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE Airplay ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Airplay'));
            }
            do {
                sleep(2);
            } while ($redis->get('activePlayer') === 'Airplay');
            sleep(1);
        } else if ($activePlayer === 'SpotifyConnect') {
            //
            // Spotify Connect
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE SpotifyConnect ----------------------------------');
                $status = array_merge($status, initialise_playback_array($redis, 'Spotify connect'));
            }
            $redis->hSet('spotifyconnect', 'last_track_id', '');
            $spotify_connect_timeout = $redis->hGet('spotifyconnect', 'timeout');
            $spotify_connect_timeout_count = $spotify_connect_timeout;
            $sleepUntilTime = microtime(true)+2;
            do {
                runelog('rune_PL_wrk: Spotify Connect idle loop');
                // sometimes spotifyd gets its stop/start switch mixed up (returning start when stopped) so test for something playing instead of the event 'stop' value
                $playing = trim(sysCmd('grep -vihs closed /proc/asound/card?/pcm?p/sub?/hw_params | xargs')[0]);
                // $playing is empty when nothing is playing, otherwise a string like 'access: RW_INTERLEAVED format: S24_LE subformat: STD channels: 2 rate: 44100 (44100/1) period_size: 4410 buffer_size: 22050'
                runelog('rune_PL_wrk: $playing:', $playing);
                if ($playing) {
                    runelog('rune_PL_wrk: Spotify Connect is playing');
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                } else {
                    runelog('rune_PL_wrk: Spotify Connect is not playing');
                    $spotify_connect_timeout_count -= 2;
                }
                runelog('rune_PL_wrk: Spotify Connect timeout count', $spotify_connect_timeout_count);
                if ($spotify_connect_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Spotify Connect timeout initiated');
                    wrk_stopPlayer($redis);
                    $spotify_connect_timeout_count = $spotify_connect_timeout;
                    break;
                }
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'SpotifyConnect');
            sleep(1);
            $redis->hSet('spotifyconnect', 'last_track_id', '');
        } else if ($activePlayer === 'Bluetooth') {
            //
            // Bluetooth
            //
            if ($forceupdate !== 0) {
                $forceupdate = 0;
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('---------------------------- FORCE UPDATE Bluetooth ----------------------------------');
                $status = initialise_playback_array($redis, 'Bluetooth');
                ui_render('playback', json_encode($status));
                $redis->set('act_player_info', json_encode($status));
                $audio = $status['audio'];
                $btDeviceName = $status['currentalbum'];
                $state = $status['state'];
                $audio_channels = $status['audio_channels'];
                $audio_sample_depth = $status['audio_sample_depth'];
                $audio_sample_rate = intval($status['audio_sample_rate'] * 1000);
                $btDeviceName = $status['currentalbum'];
            }
            $bluetooth_timeout = $redis->hGet('bluetooth', 'timeout');
            $bluetooth_timeout_count = $bluetooth_timeout;
            $sleepUntilTime = microtime(true)+2;
            $checkAudioCnt = 2;
            do {
                $status = json_decode($redis->get('act_player_info'), true);
                runelog('rune_PL_wrk: Bluetooth idle loop');
                // test for something playing instead of a event 'stop' value
                $playing = trim(strtolower(sysCmd('grep -vihs closed /proc/asound/card?/pcm?p/sub?/hw_params | xargs')[0]));
                // $playing is empty when nothing is playing, otherwise a string like 'access: RW_INTERLEAVED format: S24_LE subformat: STD channels: 2 rate: 44100 (44100/1) period_size: 4410 buffer_size: 22050'
                runelog('rune_PL_wrk: $playing:', $playing);
                if ($playing) {
                    runelog('rune_PL_wrk: Bluetooth is playing');
                    $bluetooth_timeout_count = $bluetooth_timeout;
                    $state = 'play';
                    if ($state != $status['state']) {
                        $status['elapsed'] = 0;
                        $status['song_percent'] = 0;
                    }
                    if ($checkAudioCnt-- <= 0) {
                        // a value of 5 for $checkAudioCnt means that this code is run every 10 seconds since the do loop has a 2 second cycle
                        $checkAudioCnt = 5;
                        $audio_channels_number = round(preg_replace('/[^0-9]/', '', get_between_data($playing, 'channels: ', ' ')), 1);
                        if ($audio_channels_number == 1) {
                            $audio_channels = 'Mono';
                        } else if ($audio_channels_number == 2) {
                            $audio_channels = 'Stereo';
                        } else {
                            $audio_channels = 'Multichannel';
                        }
                        $audio_sample_depth = intval(preg_replace('/[^0-9]/', '', get_between_data($playing, 'format: ', ' ')));
                        $audio_sample_rate = intval(preg_replace('/[^0-9]/', '', get_between_data($playing, 'rate: ', ' ')));
                        $audio = $audio_sample_rate.':'.$audio_sample_depth.':'.$audio_channels_number;
                        $btDeviceArray = wrk_btcfg($redis, 'status');
                        $btDeviceName = '';
                        foreach ($btDeviceArray as $btDevice) {
                            if ($btDevice['connected'] && $btDevice['source']) {
                                $btDeviceName = $btDevice['name'];
                                break;
                            }
                        }
                        if (!isset($btDeviceName)) {
                            $btDeviceName = '-';
                        }
                    } else {
                    }
                } else if ($redis->hGet('bluetooth', 'initialising')) {
                    runelog('rune_PL_wrk: Bluetooth is initialising');
                    $state = 'stop';
                    $bluetooth_timeout_count = $bluetooth_timeout;
                } else {
                    runelog('rune_PL_wrk: Bluetooth is not playing');
                    $state = 'stop';
                    $bluetooth_timeout_count -= 2;
                }
                if ($bluetooth_timeout_count <= 0) {
                    runelog('rune_PL_wrk: Bluetooth timeout initiated');
                    wrk_stopPlayer($redis);
                    continue;
                }
                if (($audio != $status['audio']) || ($btDeviceName != $status['currentalbum']) || ($state != $status['state'])) {
                    $status['state'] = $state;
                    $status['audio'] = $audio;
                    $status['audio_channels'] = $audio_channels;
                    $status['audio_sample_depth'] = $audio_sample_depth;
                    $status['audio_sample_rate'] = round($audio_sample_rate/1000, 1);
                    $status['currentalbum'] = $btDeviceName;
                    $status['currentsong'] = 'Streaming';
                    ui_render('playback', json_encode($status));
                    $redis->set('act_player_info', json_encode($status));
                }
                runelog('rune_PL_wrk: Bluetooth timeout count', $bluetooth_timeout_count);
                // 2 second sleep
                $sleepTime = $sleepUntilTime - microtime(true);
                if ($sleepTime > 0) {
                    $sleepTime = intval($sleepTime * 1000000);
                    usleep($sleepTime);
                }
                $sleepUntilTime = microtime(true)+2;
            } while ($redis->get('activePlayer') === 'Bluetooth');
            sleep(1);
        } else {
            $forceupdate = 1;
            sleep(1);
        }
        $forceupdate = 1;
    }
    // close Redis connection
    $redis->close();
    sleep(1);
// --- WORKER MAIN LOOP --- //
}
// These command never get executed!!!

