#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2015 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2015 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2015 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2015 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_MPDEM_wrk
 *  version: 0.5
 *  coder: janui
 *  date: March 2022
 *  description:
 *      this script replaces app/coverart_ctl.php, app/artist_info_ctl.php and app/lyric_ctl.php these
 *      files were previously called by the javascript UI engine (runeaudio.js) to retrieve album art
 *      artist information and lyrics at the moment it was required for display
 *      while these scripts were operating the UI was blocked which caused poor UI response and the routines
 *      were also called by each active client causing stress on the external data-service providers
 *      in the new situation the information retrieved once and is pushed to the UI from the back-end
 *      some caching is applied to improve performance to reduce the load on the external data-service
 *      providers
 *      information for the next track (if known) is pre-retrieved while playing the previous track, this
 *      also helps the UI response
 *      all the data active data is stored in the redis variable 'act_player_info' which is concurrently updated
 *      by rune_PL_wrk, updates by rune_PL_wrk have priority
 *      redis transaction constructs watch and exec are used to eliminate 'act_player_info' update conflicts
 */
// initialisation
// report errors: set display_errors to true (=1)
ini_set('display_errors', '1');
// report all PHP errors: set error_reporting to -1
ini_set('error_reporting', -1);
// set the name of the error log file
ini_set('error_log', '/var/log/runeaudio/rune_MPDEM_wrk.log');
// common include
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend
require_once('/srv/http/app/libs/openredis.php');
// include the music metadata decode module getid3
// getid3 needs to operate in directory /srv/http/app/libs/vendor
chdir('/srv/http/app/libs/vendor');
require_once('getid3/audioinfo.class.php');
// reset logfile
sysCmd('echo "--------------- start: rune_MPDEM_wrk ---------------" > /var/log/runeaudio/rune_MPDEM_wrk.log');
// logging starting message
runelog('WORKER rune_MPDEM_wrk STARTING...');
// define APP global
define('APP', '/srv/http/app/');
// reset the systemd reset counter for this job, this job is designed to restart when problems occur
sysCmd('systemctl reset-failed rune_MPDEM_wrk');
// reset the process priorities
sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
// get the album art directory and url dir
$artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
$artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
$mpdRoot = rtrim($redis->hGet('mpdconf', 'music_directory'), '/');
//
if ($redis->get('remoteSSbigart') === 'album') {
    $bigartIsAlbum = true;
} else {
    $bigartIsAlbum = false;
}
$wordlength = $redis->get('wordlength');

// load the lyrics tags, comma delimited, possibly with quotes, normally lower case
$lyricsTags = explode(',', $redis->hGet('lyrics', 'lyrics_tags'));
foreach ($lyricsTags as $key => &$lyricsTag) {
    // remove quotes from the tag and trim
    $lyricsTag = trim(preg_replace('/[\"\']/', '', $lyricsTag));
    // skip and remove empty tag names
    if (!$lyricsTag) {
        unset($lyricsTags[$key]);
    }
}
// get the genres where lyrics are omitted unless they are supplied as embedded tags, comma delimited, possibly with quotes
$omit_lyrics = explode(',', $redis->hGet('lyrics', 'omit_lyrics'));
foreach ($omit_lyrics as $key => &$omit_lyric) {
    // remove quotes from the tag and trim
    $omit_lyric = trim(preg_replace("/[\"\']/", '', $omit_lyric));
    // skip and remove empty tag names
    if (!$omit_lyrics) {
        unset($omit_lyrics[$key]);
    }
}
// process lyrics files?
if ($redis->hGet('lyrics', 'lyric_file')) {
    $procesLyricsFiles = true;
} else {
    $procesLyricsFiles = false;
}
//
$statusCnt = 10;
$saveFile = '';
$saveAlbumArtistSong = '';
$socket = 0;
while (true)  {
    // loop forever
    // process the extra metadata
    // use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
    $redis->unwatch();
    $status = json_decode($redis->get('act_player_info'), true);
    if (!isset($status) || !is_array($status)) {
        // the array is empty, sleep then loop
        sleep(3);
        continue;
    }
    $redis->watch('act_player_info');
    if (isset($status['radio']) && trim($status['radio'])) {
        $curSongIsRadio = true;
    } else {
        $curSongIsRadio = false;
    }
    // this part corrects missing bio or lyrics on the first number after switching back to MPD from another source
    if ((trim($status['artist_bio_summary']) == '')
            || (trim($status['song_lyrics']) == '')) {
        $saveFile = '';
    }
    // this part handles play-lists playing multiple songs from one source file
    //  normally it is enough to check a changed file name ($status['file']),
    //  here $currentAlbumArtistSong is set with album, artist and song up to detect a change
    if (isset($status['currentartist']) && $status['currentartist']) {
        $currentAlbumArtistSong = trim(preg_replace('/\s+/', '', $status['currentalbum'].$status['currentartist'].$status['currentsong']));
    } else {
        $currentAlbumArtistSong = trim(preg_replace('/\s+/', '', $status['currentalbum'].$status['currentalbumartist'].$status['currentsong']));
    }
    //
    while (isset($status['actPlayer']) && isset($status['file'])
            && ($status['actPlayer'] === 'MPD') && trim($status['file'])
            && (sysCmd('dir -1 /srv/http/tmp/art/*.png 2>/dev/null | wc -l')[0])
            && (($status['file'] != $saveFile) || ($currentAlbumArtistSong != $saveAlbumArtistSong))) {
        // enter the loop when MPD is the player, the directory /srv/http/tmp/art/ has been set up and the song has changed
        //
        // main processing
        //
        $saveFile = $status['file'];
        $saveAlbumArtistSong = $currentAlbumArtistSong;
        //
        // clear the variables set in this script
        //  many are set to a single space which will cause the UI to use the value, clearing unset information (an
        //  empty string is ignored in the UI)
        //
        $status['mainArtURL'] = '';
        $status['bigArtURL'] = '';
        $status['smallArtURL'] = '';
        // $status['bitrate'] = ' ';
        // $status['audio_sample_rate'] = ' ';
        // $status['audio_sample_depth'] = ' ';
        $status['song_lyrics'] = ' ';
        $status['coverArtPreload'] = '';
        $status['artist_bio_summary'] = ' ';
        $status['artist_similar'] = ' ';
        //
        // open the MPD socket, first close it if already open
        if ($socket) {
            closeMpdSocket($socket);
            $socket = 0;
        }
        $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
        $currsongid = '';
        $nextsongid = '';
        //
        // get the current status, this includes pointers to the current song and the next song
        //
        if ($socket && sendMpdCommand($socket, 'status')) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, 'songid: ') === 1) {
                        // careful, 'songid: ', dont match 'nextsongid: '
                        $currsongid = trim(explode(': ', $retline, 2)[1]);
                    } else if (strpos(' '.$retline, 'nextsongid: ') === 1) {
                        $nextsongid = trim(explode(': ', $retline, 2)[1]);
                    } else if (strpos(' '.$retline, 'state: ') === 1) {
                        $state = trim(explode(': ', $retline, 2)[1]);
                    }
                }
            }
        } else {
            // mpd socket is not open or MPD command failed
            $saveFile = '';
            sleep(2);
            break;
        }
        // debug
        // echo "Currsongid 1: '$currsongid', Nextsongid: '$nextsongid'\n";
        runelog('[rune_MPDEM_wrk]', "Currsongid 1: '$currsongid', Nextsongid: '$nextsongid'");
        if (!$currsongid && !$nextsongid) {
            if ($state != 'stop') {
                // nothing to do, loop or continue the loop
                $saveFile = '';
                sleep(2);
                break;
            } else {
                if ($socket && sendMpdCommand($socket, 'playlistinfo 0')) {
                    $retval = readMpdResponse($socket);
                    if ($retval && strpos($retval, "OK\n")) {
                        // response is valid
                        $retarray = explode("\n", $retval);
                        foreach ($retarray as $retline) {
                            if (strpos(' '.$retline, 'Id: ') === 1) {
                                $currsongid = trim(explode(': ', $retline, 2)[1]);
                            }
                        }
                    }
                } else {
                    // mpd socket is not open or MPD command failed
                    $saveFile = '';
                    sleep(2);
                    break;
                }
                if ($socket && sendMpdCommand($socket, 'playlistinfo 1')) {
                    $retval = readMpdResponse($socket);
                    if ($retval && strpos($retval, "OK\n")) {
                        // response is valid
                        $retarray = explode("\n", $retval);
                        foreach ($retarray as $retline) {
                            if (strpos(' '.$retline, 'Id: ') === 1) {
                                $nextsongid = trim(explode(': ', $retline, 2)[1]);
                            }
                        }
                    }
                } else {
                    // mpd socket is not open or MPD command failed
                    $saveFile = '';
                    sleep(2);
                    break;
                }
                // debug
                // echo "Currsongid 2: '$currsongid', Nextsongid: '$nextsongid'\n";
                runelog('[rune_MPDEM_wrk]', "Currsongid 2: '$currsongid', Nextsongid: '$nextsongid'");
                if (!$currsongid && !$nextsongid) {
                    // nothing to do, loop or continue the loop
                    $saveFile = '';
                    sleep(2);
                    break;
                }
            }
        }
        $songinfo = array();
        //
        // get the current song information and create the 'currsong' cache table entry, when not a radio
        //
        if ($currsongid && $socket && sendMpdCommand($socket, 'playlistid '.$currsongid)) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                $currsong = array();
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, ': ')) {
                        $retlineparts = explode(': ', $retline, 2);
                        $retlineparts[0] = trim($retlineparts[0]);
                        $retlineparts[1] = trim($retlineparts[1]);
                        if ($retlineparts[0] && $retlineparts[1]) {
                            $songinfo['currsong'][strtolower($retlineparts[0])] = $retlineparts[1];
                        }
                    }
                }
            } else {
                // mpd response invalid, clear the array element
                unset($songinfo['currsong']);
            }
        } else {
            // mpd socket invalid or send command failed, clear the array element
            unset($songinfo['currsong']);
        }
        if (!isset($songinfo['currsong']['file']) || ($songinfo['currsong']['file'] !== $saveFile)) {
            // current song file from MPD not set or it differs from current file in act_player_info, song has changed
            $saveFile = '';
            break;
        }
        if ($curSongIsRadio) {
            // its a radio, don't process it, remove it from the array
            unset($songinfo['currsong']);
        } else if (strpos(' '.strtolower($songinfo['currsong']['file']), 'http') === 1) {
            // the file has a prefix of http, so it could still be a radio, otherwise it could be a UPnP/DLNA stream
            if (is_radioUrl($redis, $songinfo['currsong']['file'])) {
                // it exists and its a radio, don't process it, remove it from the array
                unset($songinfo['currsong']);
            }
        } else if (strpos(' '.$songinfo['currsong']['file'], 'alsa:') === 1) {
            // hardware alsa input, don't process it, remove it from the array
            unset($songinfo['currsong']);
        } else if (strpos(' '.$songinfo['currsong']['file'], 'cdda:') === 1) {
            // hardware CD input, don't process it, remove it from the array
            unset($songinfo['currsong']);
        } else {
            // this is a file on local or network storage, add the mpd root prefix
            $songinfo['currsong']['uri'] = $songinfo['currsong']['file'];
            $songinfo['currsong']['file'] = $mpdRoot.'/'.$songinfo['currsong']['file'];
            clearstatcache(true, $songinfo['currsong']['file']);
            if (!file_exists($songinfo['currsong']['file'])) {
                // the file does not exist or the file name is invalid, don't process it, remove it from the array
                unset($songinfo['currsong']);
            }
        }
        //
        // get the next song information and create the 'nextsong' cache table entry
        //
        if ($nextsongid && $socket && sendMpdCommand($socket, 'playlistid '.$nextsongid)) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, ': ')) {
                        $retlineparts = explode(': ', $retline, 2);
                        $retlineparts[0] = trim($retlineparts[0]);
                        $retlineparts[1] = trim($retlineparts[1]);
                        if ($retlineparts[0] && $retlineparts[1]) {
                            $songinfo['nextsong'][strtolower($retlineparts[0])] = $retlineparts[1];
                        }
                    }
                }
            } else {
                // mpd response invalid, clear the array
                unset($songinfo['nextsong']);
            }
        } else {
            // mpd socket invalid or send command failed, clear the array
            unset($songinfo['nextsong']);
        }
        if (!isset($songinfo['nextsong']['file'])) {
            // next song file from MPD not set
            unset($songinfo['nextsong']);
        } else if (strpos(' '.strtolower($songinfo['nextsong']['file']), 'http') === 1) {
            // the file has a prefix of http, so it could still be a radio, otherwise it could be a UPnP/DLNA stream
            if (is_radioUrl($redis, $songinfo['nextsong']['file'])) {
                // it exists and its a radio, don't process it, remove it from the array
                unset($songinfo['nextsong']);
            }
        } else if (strpos(' '.$songinfo['nextsong']['file'], 'alsa:') === 1) {
            // hardware alsa input, don't process it, remove it from the array
            unset($songinfo['nextsong']);
        } else if (strpos(' '.$songinfo['nextsong']['file'], 'cdda:') === 1) {
            // hardware CD input, don't process it, remove it from the array
            unset($songinfo['nextsong']);
        } else {
            // this is a file on local or network storage, add the mpd root prefix
            $songinfo['nextsong']['uri'] = $songinfo['nextsong']['file'];
            $songinfo['nextsong']['file'] = $mpdRoot.'/'.$songinfo['nextsong']['file'];
            clearstatcache(true, $songinfo['nextsong']['file']);
            if (!file_exists($songinfo['nextsong']['file'])) {
                // the file does not exist or the file name is invalid, don't process it, remove it from the array
                unset($songinfo['nextsong']);
            }
        }
        //
        // tidy up
        //
        unset($retval, $retarray, $retline, $retlineparts, $currsongid, $nextsongid);
        //
        // process the songinfo array, which has one or two entries, current song 'currsong' and in most cases also next song 'nextsong'
        //
        if (!count($songinfo)) {
            // songinfo array empty, nothing to do, the foreach below will do nothing
            $saveFile = '';
            break;
        }
        foreach ($songinfo as $songkey => &$song) {
            // note: $song is by reference and can be modified
            //
            // retrieve and validate the cached information
            //
            // the file name is not unique for cue lists which play multiple songs from a single file, so use album, artist, title and date
            if (isset($song['album']) && isset($song['artist']) && isset($song['title']) && isset($song['date'])
                    && $song['album'] && $song['artist'] && $song['title'] && $song['date']) {
                $datafile = md5($song['album'].$song['artist'].$song['title'].$song['date'].$song['file']);
            } else if (isset($song['album']) && isset($song['albumartist']) && isset($song['title']) && isset($song['date'])
                    && $song['album'] && $song['albumartist'] && $song['title'] && $song['date']) {
                $datafile = md5($song['album'].$song['albumartist'].$song['title'].$song['date'].$song['file']);
            } else if (isset($song['album']) && isset($song['artist']) && isset($song['title'])
                    && $song['album'] && $song['artist'] && $song['title']) {
                $datafile = md5($song['album'].$song['artist'].$song['title'].$song['file']);
            } else if (isset($song['album']) && isset($song['albumartist']) && isset($song['title'])
                    && $song['album'] && $song['albumartist'] && $song['title']) {
                $datafile = md5($song['album'].$song['albumartist'].$song['title'].$song['file']);
            } else {
                $datafile = md5($song['file']);
            }
            if (isset($song['album']) && isset($song['albumartist']) && isset($song['date'])
                    && $song['album'] && $song['albumartist'] && $song['date']) {
                $imagename = md5($song['album'].$song['albumartist'].$song['date']);
            } else if (isset($song['album']) && isset($song['artist']) && isset($song['date'])
                    && $song['album'] && $song['artist'] && $song['date']) {
                $imagename = md5($song['album'].$song['artist'].$song['date']);
            } else if (isset($song['album']) && isset($song['albumartist'])
                    && $song['album'] && $song['albumartist']) {
                $imagename = md5($song['album'].$song['albumartist']);
            } else if (isset($song['album']) && isset($song['artist'])
                    && $song['album'] && $song['artist']) {
                $imagename = md5($song['album'].$song['artist']);
            } else {
                $imagename = md5($song['file']);
            }
            $song['datafile'] = $artDir.'/'.$datafile.'.mpd';
            clearstatcache(true, $song['datafile']);
            if (file_exists($song['datafile'])) {
                touch($song['datafile']);
                $songDatafile = json_decode(file_get_contents($song['datafile']), true);
                if (isset($songDatafile) && $songDatafile && is_array($songDatafile)) {
                    $song = array_merge($song, $songDatafile);
                }
                unset($songDatafile);
            }
            if (isset($song['albumarturl'])) {
                // artfile entry in the array is set
                if (substr($song['albumarturl'], 0, 4) === 'http') {
                    // the name of the arturl is set and it is a web image, so still valid
                    // remove the album art file entry, it should not be there
                    unset($song['albumartfile']);
                } else if (isset($song['albumartfile']) && $song['albumartfile']) {
                    // album art file entry has a value
                    clearstatcache(true, $song['albumartfile']);
                    if (file_exists($song['albumartfile'])) {
                        // artfile exists, update its date stamp, the cache is still valid
                        touch($song['albumartfile']);
                    } else {
                        // cache is invalid clear the album art file and album art url entries
                        unset($song['albumartfile'], $song['albumarturl']);
                    }
                } else {
                    // cache is invalid clear the album art file and album art url entries
                    unset($song['albumartfile'], $song['albumarturl']);
                }
            } else {
                // cache is invalid clear the album art file and album art url entries
                unset($song['albumartfile'], $song['albumarturl']);
            }
            //
            // attempt to find lyrics files and use then if enabled and available
            //
            if ($procesLyricsFiles && (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) && isset($song['file']) && $song['file']) {
                $prefixFile = strtolower(substr($song['file'],0, 4));
                if (!strpos('|http|', $prefixFile)) {
                    // process non-http files, works only on locally mounted files
                    $pathParts = pathinfo($song['file']);
                    $fileDirFile = $pathParts['dirname'].'/'.$pathParts['filename'];
                    // lower case file extension
                    $lyricFileName = $fileDirFile.'.lrc';
                    clearstatcache(true, $lyricFileName);
                    if (file_exists($lyricFileName)) {
                        $song['song_lyrics'] = strip_synchronised_lyrics(file_get_contents($lyricFileName));
                    }
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        // upper case file extension
                        $lyricFileName = $fileDirFile.'.LRC';
                        clearstatcache(true, $lyricFileName);
                        if (file_exists($lyricFileName)) {
                            $song['song_lyrics'] = strip_synchronised_lyrics(file_get_contents($lyricFileName));
                        }
                    }
                }
            }
            //
            // process album art and other embedded metadata information
            //
            if (isset($song['albumarturl'])) {
                // a cached file has been found, we can skip the next section
                $song['artFound'] = true;
            } else {
                $song['artFound'] = false;
            }
            if (!$song['artFound']) {
                // determine the album art and other embedded metadata information
                //
                // 1. try to extract embedded metadata (coverart, lyrics, etc.) with getid3
                //
                // getID3 needs to operate in directory /srv/http/app/libs/vendor
                chdir('/srv/http/app/libs/vendor');
                // run getID3 and trap any errors
                $auOK = true;
                unset($au, $auinfo);
                try {
                    // Code that may throw an Exception or Error.
                    // $au = new AudioInfo();
                    // $auinfo =  $au->Info($song['file']);
                    $au = new getID3;
                    if ($wordlength == 32) {
                        // ape tags throw lots of warnings for the 32bit image, they cannot be decoded properly, switch ape tags off
                        $au->setOption(array('option_tag_apetag' => false));
                    }
                    $auinfo =  $au->analyze($song['file']);
                }
                catch (Throwable $t) {
                    // Executed only in PHP 7 and higher, will not match in PHP 5 and lower
                    // save the name of the file which caused the error
                    $redis->set('getID3_error', $song['file']);
                    $auOK = false;
                    echo "[rune_MPDEM_wrk] Caught Throwable ('{$t->getMessage()}')\n{$t}\n";
                }
                catch (Exception $e) {
                    // Executed only in PHP 5 and lower, will not match in PHP 7 and higher
                    // save the name of the file which caused the error
                    $redis->set('getID3_error', $song['file']);
                    $auOK = false;
                    echo "[rune_MPDEM_wrk] Caught Exception ('{$e->getMessage()}')\n{$e}\n";
                }
                if ($auOK && is_array($auinfo)) {
                    // set up the file names, we assume jpg, but it could be something else, regardless
                    //  of this, the browser seems to test the image file type and use it correctly
                    $song['albumartfile'] = $artDir.'/'.$imagename.'.jpg';
                    $song['albumarturl'] = $artUrl.'/'.$imagename.'.jpg';
                    unset ($pictureIndex);
                    if (isset($auinfo['comments']['picture']) && is_array($auinfo['comments']['picture'])) {
                        // there appears to be images available
                        for ($i = 0; $i <= array_key_last($auinfo['comments']['picture']); $i++) {
                            if (!isset($pictureIndex) && isset($auinfo['comments']['picture'][$i]['data']) && (strlen($auinfo['comments']['picture'][$i]['data']) > 200)) {
                                // found the first valid image, save the key
                                $pictureIndex = $i;
                                continue;
                            }
                            if (isset($auinfo['comments']['picture'][$i]['picturetype']) && strpos($auinfo['comments']['picture'][$i]['picturetype'], 'front') &&
                                    isset($auinfo['comments']['picture'][$i]['data']) && (strlen($auinfo['comments']['picture'][$i]['data']) > 200)) {
                                // found another valid image with name 'front', delete any already saved images and save the key
                                if (isset($pictureIndex)) {
                                    // unset previously saved picture data to save memory
                                    unset($auinfo['comments']['picture'][$pictureIndex]);
                                }
                                $pictureIndex = $i;
                                continue;
                            }
                            // unset any other picture data to save memory
                            unset($auinfo['comments']['picture'][$i]);
                        }
                    }
                    if (isset($pictureIndex)) {
                        // the music file has embedded metadata and it has a size of more than 200 bytes, save it
                        // send the image to the file using ImageMagick, this will convert to the required format
                        $descriptorspec = array(
                           0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
                           1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
                           2 => array("pipe", "w"),  // stderr is a pipe that the child will write to
                        );
                        $cwd = '/tmp';
                        $magick_opts = trim($redis->hGet('magick', 'opts'));
                        $magick_resize = trim($redis->hGet('magick', 'resize'));
                        if ($magick_resize) {
                            $process = proc_open('convert -resize '.$magick_resize.' '.$magick_opts.' - \''.$song['albumartfile'].'\'', $descriptorspec, $pipes, $cwd);
                        } else {
                            $process = proc_open('convert '.$magick_opts.' - \''.$song['albumartfile'].'\'', $descriptorspec, $pipes, $cwd);
                        }
                        $return_value = 0;
                        if (is_resource($process)) {
                            // $pipes now looks like this:
                            // 0 => writeable handle connected to child stdin
                            // 1 => readable handle connected to child stdout
                            // Any error output will be appended to /tmp/error-output.txt
                            fwrite($pipes[0], $auinfo['comments']['picture'][$pictureIndex]['data']);
                            fclose($pipes[0]);
                            // empty and close the pipes
                            $std_out = stream_get_contents($pipes[1]);
                            fclose($pipes[1]);
                            $std_err = stream_get_contents($pipes[2]);
                            fclose($pipes[2]);
                            // debug
                            if (is_array($std_out)) {
                                $std_out = implode("\n", $std_out);
                            }
                            $std_out = trim($std_out);
                            if (isset($std_out) && $std_out) {
                                echo "[rune_MPDEM_wrk] ImageMagick error, std_out: ".$std_out."\n";
                            }
                            if (is_array($std_err)) {
                                $std_err = implode("\n", $std_err);
                            }
                            $std_err = trim($std_err);
                            if (isset($std_err) && $std_err) {
                                echo "[rune_MPDEM_wrk] ImageMagick error, std_err: ".$std_err."\n";
                            }
                            // It is important that you close any pipes before calling
                            // proc_close in order to avoid a deadlock
                            $return_value = proc_close($process);
                        } else {
                            // failed to start the ImageMagick convert
                            file_put_contents($song['albumartfile'], $auinfo['comments']['picture'][0]['data']);
                        }
                        if ($return_value) {
                            // zero is returned for correct execution, so it has failed, but sometimes the image conversion is correct
                            // get some information about the file
                            list($width, $height, $type, $attr) = getimagesize($song['albumartfile']);
                            // width and height are in pixels (null when invalid), type is a non zero/null value when valid
                            if (isset($width) && isset($height) && isset($type) && ($width > 20) && ($height > 20) && $type) {
                                // it is a valid image file (or at least it has a valid header) and it is at least 20x20px
                                $song['artFound'] = true;
                            } else {
                                // the image file has an invalid format or is very small, write the unaltered image
                                file_put_contents($song['albumartfile'], $auinfo['comments']['picture'][0]['data']);
                            }
                        }
                        if (!$song['artFound']) {
                            // get some information about the album art file
                            list($width, $height, $type, $attr) = getimagesize($song['albumartfile']);
                            // width and height are in pixels (null when invalid), type is a non zero/null value when valid
                            if (isset($width) && isset($height) && isset($type) && ($width > 20) && ($height > 20) && $type) {
                                // it is a valid image file (or at least it has a valid header) and it is at least 20x20px
                                $song['artFound'] = true;
                            } else {
                                // the image file has an invalid format or is very small, delete it
                                unlink($song['albumartfile']);
                            }
                        }
                    }
                    unset($auinfo['comments']['picture']);
                    // var_dump($auinfo);
                    // save the other getID3 fields (e.g. average bitrate and sample rate)
                    if (isset($auinfo) && is_array($auinfo)) {
                        foreach ($auinfo as $valuekey => $value) {
                            // echo "valuekey '".$valuekey."'\n";
                            // skip tags with only a numeric name
                            if (is_numeric($valuekey)) {
                                continue;
                            }
                            if (!is_array($value)) {
                                // some of the useful information is stored at the first level of the array
                                $value = trim($value);
                                if ($value) {
                                    $song[strtolower($valuekey)] = $value;
                                }
                            }
                        }
                    }
                    if (isset($auinfo['audio']) && is_array($auinfo['audio'])) {
                        foreach ($auinfo['audio'] as $valuekey => $value) {
                            // echo "valuekey '".$valuekey."'\n";
                            // skip tags with only a numeric name
                            if (is_numeric($valuekey)) {
                                continue;
                            }
                            if (!is_array($value)) {
                                // some of the useful information is stored in the [audio] tag
                                $value = trim($value);
                                if ($value) {
                                    $song[strtolower($valuekey)] = $value;
                                }
                            }
                        }
                    }
                    if (isset($auinfo['tags']) && is_array($auinfo['tags'])) {
                        foreach ($auinfo['tags'] as $value) {
                            if (isset($value) && is_array($value)) {
                                foreach ($value as $value1) {
                                    // this level is ['id3v1'], ['id3v2'], ['vorbiscomment'], etc
                                    if (isset($value1) && is_array($value1)) {
                                        foreach ($value1 as $valuekey2 => $value2) {
                                            // this level has things like artist, album, track, etc.
                                            // however the data is generally stored in an array, then the first element is used
                                            // debug
                                            // echo "valuekey2 '".$valuekey2."'\n";
                                            // skip tags with only a numeric name
                                            if (is_numeric($valuekey2)) {
                                                continue;
                                            }
                                            if (isset($value2) && !is_array($value2)) {
                                                // value2 is not an array, use it
                                                $value = trim($value2);
                                                if ($value) {
                                                    $song[strtolower($valuekey2)] = $value;
                                                }
                                            } else if (isset($value2[0]) && !is_array($value2[0])) {
                                                // the first element of value2 is not an array, use it
                                                $value = trim($value2[0]);
                                                if ($value) {
                                                    $song[strtolower($valuekey2)] = $value;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // when there are music brainz id's in the metadata save them, these make searching for things on internet easier
                    if (!isset($song['artist_mbid'])) {
                        $artist_mbid = trim(search_array_keys($auinfo, 'artist_mbid', true, true, true));
                        if ($artist_mbid) {
                            $song['artist_mbid'] = $artist_mbid;
                        }
                    }
                    if (!isset($song['artist_mbid'])) {
                        $artist_mbid = trim(search_array_keys($auinfo, 'musicbrainz_artistid', true, true, true));
                        if ($artist_mbid) {
                            $song['artist_mbid'] = $artist_mbid;
                        }
                    }
                    if (!isset($song['artist_mbid'])) {
                        $artist_mbid = trim(search_array_keys($auinfo, 'MusicBrainz Artist Id', true, true, true));
                        if ($artist_mbid) {
                            $song['artist_mbid'] = $artist_mbid;
                        }
                    }
                    if (isset($song['artist_mbid'])) {
                        $song['artist_mbid'] = trim($song['artist_mbid'], ", \n\r\t\v\x00");
                    }
                    //
                    if (!isset($song['album_mbid'])) {
                        $album_mbid = trim(search_array_keys($auinfo, 'album_mbid', true, true, true));
                        if ($album_mbid) {
                            $song['album_mbid'] = $album_mbid;
                        }
                    }
                    if (!isset($song['album_mbid'])) {
                        $album_mbid = trim(search_array_keys($auinfo, 'musicbrainz_albumid', true, true, true));
                        if ($album_mbid) {
                            $song['album_mbid'] = $album_mbid;
                        }
                    }
                    if (!isset($song['album_mbid'])) {
                        $album_mbid = trim(search_array_keys($auinfo, 'MusicBrainz Album Id', true, true, true));
                        if ($album_mbid) {
                            $song['album_mbid'] = $album_mbid;
                        }
                    }
                    if (isset($song['album_mbid'])) {
                        $song['album_mbid'] = trim($song['album_mbid'], ", \n\r\t\v\x00");
                    }
                    //
                    if (!isset($song['song_mbid'])) {
                        $song_mbid = trim(search_array_keys($auinfo, 'song_mbid', true, true, true));
                        if ($song_mbid) {
                            $song['song_mbid'] = $song_mbid;
                        }
                    }
                    if (!isset($song['song_mbid'])) {
                        $song_mbid = trim(search_array_keys($auinfo, 'track_mbid', true, true, true));
                        if ($song_mbid) {
                            $song['song_mbid'] = $song_mbid;
                        }
                    }
                    if (!isset($song['song_mbid'])) {
                        $song_mbid = trim(search_array_keys($auinfo, 'musicbrainz_trackid', true, true, true));
                        if ($song_mbid) {
                            $song['song_mbid'] = $song_mbid;
                        }
                    }
                    if (!isset($song['song_mbid'])) {
                        $song_mbid = trim(search_array_keys($auinfo, 'MusicBrainz Track Id', true, true, true));
                        if ($song_mbid) {
                            $song['song_mbid'] = $song_mbid;
                        }
                    }
                    if (isset($song['song_mbid'])) {
                        $song['song_mbid'] = trim($song['song_mbid'], ", \n\r\t\v\x00");
                    }
                    //
                    // check for bit rate (bitrate)
                    if (!isset($song['bitrate'])) {
                        $bitrate = trim(search_array_keys($auinfo, 'bitrate', true, true, true));
                        if ($bitrate) {
                            $song['bitrate'] = $bitrate;
                        }
                    }
                    // check for average bit rate (avg_bit_rate)
                    if (!isset($song['avg_bit_rate'])) {
                        $avg_bit_rate = trim(search_array_keys($auinfo, 'avg_bit_rate', true, true, true));
                        if ($avg_bit_rate) {
                            $song['avg_bit_rate'] = $avg_bit_rate;
                        }
                    }
                    if (!isset($song['avg_bit_rate']) && isset($song['bitrate']) && is_numeric($song['bitrate'])) {
                        $song['avg_bit_rate'] = round($song['bitrate']);
                    }
                    // check for song lyrics
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        foreach ($lyricsTags as $key => $lyricsTag) {
                            $lyricsTagLower = strtolower($lyricsTag);
                            if ((lyricsTagLower != $lyricsTag) && isset($auinfo[$lyricsTagLower]) && trim($auinfo[$lyricsTagLower])) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($auinfo[$lyricsTagLower]);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                            if (isset($auinfo[$lyricsTag]) && trim($auinfo[$lyricsTag])) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($auinfo[$lyricsTag]);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                        }
                    }
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        foreach ($lyricsTags as $key => $lyricsTag) {
                            $lyrics = trim(search_array_keys($auinfo, $lyricsTag, true, true, true));
                            if (isset($lyrics) && $lyrics) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($lyrics);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                        }
                    }
                }
                // when more mbid's are returned (these are comma delimited) just use the first one
                if (isset($song['artist_mbid']) && $song['artist_mbid']) {
                    $commapos = strpos(' '.$song['artist_mbid'], ',');
                    if ($commapos) {
                        $song['artist_mbid'] = substr($song['artist_mbid'], 0, $commapos);
                    }
                }
                if (isset($song['album_mbid']) && $song['album_mbid']) {
                    $commapos = strpos(' '.$song['album_mbid'], ',');
                    if ($commapos) {
                        $song['album_mbid'] = substr($song['album_mbid'], 0, $commapos);
                    }
                }
                if (isset($song['song_mbid']) && $song['song_mbid']) {
                    $commapos = strpos(' '.$song['song_mbid'], ',');
                    if ($commapos) {
                        $song['song_mbid'] = substr($song['song_mbid'], 0, $commapos);
                    }
                }
                unset($au, $auinfo, $width, $height, $type, $attr, $valuekey, $value, $artist_mbid, $album_mbid, $song_mbid, $avg_bit_rate, $lyrics);
            }
            //
            if (!$song['artFound']) {
                //
                // 2. try to extract coverart via MPD using mpc
                //
                sysCmd('mpc readpicture '.$song['uri'].' > /tmp/cover.jpg');
                clearstatcache(true, '/tmp/cover.jpg');
                if (file_exists('/tmp/cover.jpg')) {
                    // echo "Exists\n";
                    $filesize = intval(trim(filesize('/tmp/cover.jpg')));
                    if (isset($filesize) && $filesize && ($filesize > 200)) {
                        // echo "Greater than 200\n";
                        $magick_opts = trim($redis->hGet('magick', 'opts'));
                        $magick_resize = trim($redis->hGet('magick', 'resize'));
                        if ($magick_resize) {
                            sysCmd('convert -resize '.$magick_resize.' '.$magick_opts.' \'/tmp/cover.jpg\' \''.$song['albumartfile'].'\'');
                        } else {
                            sysCmd('convert -resize 350x350\> '.$magick_resize.' '.$magick_opts.' \'/tmp/cover.jpg\' \''.$song['albumartfile'].'\'');
                        }
                        list($width, $height, $type, $attr) = getimagesize($song['albumartfile']);
                        // width and height are in pixels (null when invalid), type is a non zero/null value when valid
                        if (isset($width) && isset($height) && isset($type) && ($width > 20) && ($height > 20) && $type) {
                            // it is a valid image file (or at least it has a valid header) and it is at least 20x20px
                            $song['artFound'] = true;
                        } else {
                            // the image file has an invalid format or is very small, delete it
                            unlink($song['albumartfile']);
                        }
                    }
                }
            }
            clearstatcache(true, '/tmp/cover.jpg');
            if (file_exists('/tmp/cover.jpg')) {
                unlink('/tmp/cover.jpg');
            }
            //
            if (isset($song['file']) && $song['file']) {
                $prefixFile = strtolower(substr($song['file'],0, 4));
                if (strpos('|http|', $prefixFile)) {
                    // local coverart will not work network files
                    $song['local'] = false;
                } else {
                    // local coverart will only work on locally mounted files
                    $song['local'] = true;
                }
            }
            if (!$song['artFound'] && $song['local']) {
                //
                // 3. try to find local coverart
                //
                $coverArtFileNames = array('folder.jpg', 'cover.jpg', 'folder.png', 'cover.png', 'FOLDER.JPG', 'COVER.JPG', 'FOLDER.PNG', 'COVER.PNG');
                $coverArtDirectory = dirname($song['file']).'/';
                foreach ($coverArtFileNames as $coverArtFileName) {
                    clearstatcache(true, $coverArtDirectory.$coverArtFileName);
                    if (file_exists($coverArtDirectory.$coverArtFileName)) {
                        // there is a valid art file in the album directory, copy it to the art directory and reduce its size as specified
                        $magick_opts = trim($redis->hGet('magick', 'opts'));
                        $magick_resize = trim($redis->hGet('magick', 'resize'));
                        if ($magick_resize) {
                            sysCmd('convert -resize '.$magick_resize.' '.$magick_opts.' \''.$coverArtDirectory.$coverArtFileName."' '".$song['albumartfile']."'");
                        } else {
                            sysCmd('convert -resize 350x350\> '.$magick_opts.' \''.$coverArtDirectory.$coverArtFileName."' '".$song['albumartfile']."'");
                        }
                        list($width, $height, $type, $attr) = getimagesize($song['albumartfile']);
                        // width and height are in pixels (null when invalid), type is a non zero/null value when valid
                        if (isset($width) && isset($height) && isset($type) && ($width > 20) && ($height > 20) && $type) {
                            // it is a valid image file (or at least it has a valid header) and it is at least 20x20px
                            $song['artFound'] = true;
                            // finish when one is found, exit the innermost loop
                            break;
                        } else {
                            // the image file has an invalid format or is very small, delete it
                            unlink($song['albumartfile']);
                        }
                    }
                }
                unset($coverArtFileNames, $coverArtDirectory);
            }
            //
            // only when processing the current song and that albumart has been found update the UI
            if (($songkey === 'currsong') && $song['artFound']) {
                // assume the current song is still valid
                if (($state == 'stop') || ($status['state'] == 'stop')) {
                    $status['song_percent'] = 0;
                    $status['elapsed'] = 0;
                }
                $status['mainArtURL'] = $song['albumarturl'];
                if ($bigartIsAlbum) {
                    $status['bigArtURL'] = $song['albumarturl'];
                } else {
                    $status['smallArtURL'] = $song['albumarturl'];
                }
                if (isset($song['avg_bit_rate']) && $song['avg_bit_rate']) {
                    // echo "song['avg_bit_rate']: '".$song['avg_bit_rate']."'\n";
                    if (!is_numeric($song['avg_bit_rate'])) {
                        $status['bitrate'] = $song['avg_bit_rate'];
                    } else {
                        $status['bitrate'] = intval(intval($song['avg_bit_rate'])/1000);
                    }
                }
                // echo "song['sample_rate']: '".$song['sample_rate']."'\n";
                if (!isset($status['audio_sample_rate']) || !trim($status['audio_sample_rate'])) {
                    if (isset($song['sample_rate']) && $song['sample_rate']) {
                        $status['audio_sample_rate'] = round($song['sample_rate']/1000, 1);
                    }
                }
                // echo "song['bits_per_sample']: '".$song['bits_per_sample']."'\n";
                if (!isset($status['audio_sample_depth']) || !trim($status['audio_sample_depth'])) {
                    if (isset($song['bits_per_sample']) && $song['bits_per_sample']) {
                        $status['audio_sample_depth'] = $song['bits_per_sample'];
                    }
                }
                if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                    $status['song_lyrics'] = $song['song_lyrics'];
                }
                unset($status['song_percent'], $status['elapsed']);
                // use redis (watch and) exec to update act_player_info
                // use (watch and) exec to update act_player_info
                $retval = $redis->multi()
                    ->set('act_player_info', json_encode($status))
                    ->exec();
                if ($retval) {
                    // update successful
                    //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                    $redis->unwatch();
                    $redis->watch('act_player_info');
                    // debug
                    // echo "0-1: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 0-1');
                } else {
                    // act_player_info has changed
                    //  currently in a double loop, continue at the end of the outside loop
                    $saveFile = '';
                    // debug
                    // echo "0-2: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 0-2');
                    break 2;
                    // echo "Data changed by rune_PL_wrk, restarting\n";
                    // use exit code 0 'Successful end'
                    // exit(0);
                }
                ui_render('playback', json_encode($status));
                // debug
                // echo "0-3: ".$saveFile.", ".$status['file']."\n";
                runelog('[rune_MPDEM_wrk] 0-3');
                // unload CPU: 1 second sleep
                // sleep(1);
            } else if (($songkey === 'nextsong') && $song['artFound']) {
                // when processing the nextsong only update the cover art preload url
                // assume the next song is still valid
                // set the cover art preload to the next song art url when changed
                if (!isset($status['coverArtPreload']) || ($status['coverArtPreload'] != $song['albumarturl'])) {
                    $status['coverArtPreload'] = $song['albumarturl'];
                    if (($state == 'stop') || ($status['state'] == 'stop')) {
                        $status['song_percent'] = 0;
                        $status['elapsed'] = 0;
                    } else {
                        unset($status['song_percent'], $status['elapsed']);
                    }
                    // use (watch and) exec to update act_player_info
                    $retval = $redis->multi()
                        ->set('act_player_info', json_encode($status))
                        ->exec();
                    if ($retval) {
                        // update successful
                        //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                        $redis->unwatch();
                        $redis->watch('act_player_info');
                        // debug
                        // echo "1-1: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 1-1');
                    } else {
                        // act_player_info has changed
                        //  currently in a double loop, continue at the end of the outside loop
                        $saveFile = '';
                        // debug
                        // echo "1-2: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 1-2');
                        break 2;
                        // echo "Data changed by rune_PL_wrk, restarting\n";
                        // use error code 0 'Successful end'
                        // exit(0);
                    }
                    ui_render('playback', json_encode($status));
                    // debug
                    // echo "1-3: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 1-3');
                    // unload CPU: 1 second sleep
                    // sleep(1);
                }
            }
            file_put_contents($song['datafile'], json_encode($song)."\n");
            //
            // get the artistinfo & lyrics
            //
            $info = array();
            if (isset($song['artist'])) {
                $info['artist'] = $song['artist'];
            } else {
                $info['artist'] = '';
            }
            if (isset($song['albumartist'])) {
                $info['albumartist'] = $song['albumartist'];
            } else {
                $info['albumartist'] = '';
            }
            if (isset($song['title'])) {
                $info['song'] = $song['title'];
            } else {
                $info['song'] = '';
            }
            if (isset($song['album'])) {
                $info['album'] = $song['album'];
            } else {
                $info['album'] = '';
            }
            if (isset($song['artist_mbid'])) {
                $info['artist_mbid'] = $song['artist_mbid'];
            }
            if (isset($song['album_mbid'])) {
                $info['album_mbid'] = $song['album_mbid'];
            }
            if (isset($song['song_mbid'])) {
                $info['song_mbid'] = $song['song_mbid'];
            }
            $retval = get_artistInfo($redis, $info);
            if ($retval) {
                $info = array_merge($info, $retval);
            }
            // some lyrics are omitted since they almost never exits, default is 'classical, baroque'
            $omit_string = '';
            if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                // we already have lyrics so use them
                $info['song_lyrics'] = $song['song_lyrics'];
            } else if (isset($song['genre']) && trim($song['genre'])) {
                // determine omitted lyrics
                foreach ($omit_lyrics as $omit_lyric) {
                    if (strpos(' '.strtolower($song['genre']), $omit_lyric)) {
                        // found a genre with omitted lyrics
                        $omit_string = $omit_lyric;
                        break;
                    }
                }
            }
            if ($omit_string) {
                // skip the lyrics
                $info['song_lyrics'] = 'Lyrics retrieval omitted for the "'.$omit_string.'" genre';
            } else {
                // when genre is unknown or not omitted get the lyrics (also when we already know the lyrics, this will cache them)
                $retval = get_songInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
            }
            // it seems illogical for this to be here however it is more effective to search
            //  for cover art on internet after searching for the artist and song information
            if (!$song['artFound']) {
                //
                // 4. try to find coverart on internet
                //
                $retval = get_albumInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
                // the routine always returns image names, including when 'not found'
                //  album_arturl_large, album_arturl_medium, and album_arturl_small
                // in this case there is no image file
                unset($song['albumartfile']);
                $song['albumarturl'] = $info['album_arturl_medium'];
                $song['artFound'] = true;
            }
            if ($song['artFound']) {
                // save the songinfo data
                file_put_contents($song['datafile'], json_encode($song)."\n");
            } else {
                unset($song['albumarturl']);
            }
            //
            if ($songkey === 'currsong') {
                // current song
                // assume the current song is still valid
                if (isset($song['albumarturl']) && trim($song['albumarturl'])) {
                    $status['mainArtURL'] = $song['albumarturl'];
                    if ($bigartIsAlbum) {
                        $status['bigArtURL'] = $song['albumarturl'];
                    } else {
                        $status['smallArtURL'] = $song['albumarturl'];
                    }
                }
                if (isset($song['avg_bit_rate']) && $song['avg_bit_rate']) {
                    if (!is_numeric($song['avg_bit_rate'])) {
                        $status['bitrate'] = $song['avg_bit_rate'];
                    } else {
                        $status['bitrate'] = intval(intval($song['avg_bit_rate'])/1000);
                    }
                }
                if (!isset($status['audio_sample_rate']) || !trim($status['audio_sample_rate'])) {
                    if (isset($song['sample_rate']) && trim($song['sample_rate'])) {
                        $status['audio_sample_rate'] = round($song['sample_rate']/1000, 1);
                    }
                }
                if (!isset($status['audio_sample_depth']) || !trim($status['audio_sample_depth'])) {
                    if (isset($song['bits_per_sample']) && trim($song['bits_per_sample'])) {
                        $status['audio_sample_depth'] = $song['bits_per_sample'];
                    }
                }
                if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                    $status['song_lyrics'] = $song['song_lyrics'];
                } else if (isset($info['song_lyrics']) && trim($info['song_lyrics'])) {
                    $status['song_lyrics'] = $info['song_lyrics'];
                }
                $status['artist_bio_summary'] = $info['artist_bio_summary'];
                $status['artist_similar'] = $info['artist_similar'];
                if ($artUrl === substr($info['artist_arturl'], 0, strlen($artUrl))) {
                    // the artist art has not been found, so use the album art
                    $info['artist_arturl'] = $status['mainArtURL'];
                }
                if ($bigartIsAlbum) {
                    $status['smallArtURL'] = $info['artist_arturl'];
                } else {
                    $status['bigArtURL'] = $info['artist_arturl'];
                }
                unset($status['song_percent'], $status['elapsed']);
                // use (watch and) exec to update act_player_info
                $retval = $redis->multi()
                    ->set('act_player_info', json_encode($status))
                    ->exec();
                if ($retval) {
                    // update successful
                    //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                    $redis->unwatch();
                    $redis->watch('act_player_info');
                    // debug
                    // echo "3-1: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 3-1');
                } else {
                    // act_player_info has changed
                    //  currently in a double loop, continue at the end of the outside loop
                    $saveFile = '';
                    // debug
                    // echo "3-2: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 3-2');
                    break 2;
                    // echo "Data changed by rune_PL_wrk, restarting\n";
                    // use exit code 0 'Successful end'
                    // exit(0);
                }
                ui_render('playback', json_encode($status));
                // debug
                // echo "3-3: ".$saveFile.", ".$status['file']."\n";
                runelog('[rune_MPDEM_wrk] 3-2');
                // unload CPU: 1 second sleep
                // sleep(1);
            } else if (($songkey === 'nextsong') && $song['artFound']) {
                // when processing the nextsong only update the cover art preload url
                // assume the next song is still valid
                // set the cover art preload to the next song art url when changed
                if (!isset($status['coverArtPreload']) || ($status['coverArtPreload'] != $song['albumarturl'])) {
                    $status['coverArtPreload'] = $song['albumarturl'];
                    unset($status['song_percent'], $status['elapsed']);
                    // use (watch and) exec to update act_player_info
                    $retval = $redis->multi()
                        ->set('act_player_info', json_encode($status))
                        ->exec();
                    if ($retval) {
                        // update successful
                        //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                        $redis->unwatch();
                        $redis->watch('act_player_info');
                        // debug
                        // echo "4-1: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 4-1');
                    } else {
                        // act_player_info has changed
                        //  currently in a double loop, continue at the end of the outside loop
                        // debug
                        // echo "4-2: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 4-2');
                        $saveFile = '';
                        break 2;
                        // echo "Data changed by rune_PL_wrk, restarting\n";
                        // use exit code 0 'Successful end'
                        // exit(0);
                    }
                    ui_render('playback', json_encode($status));
                    // debug
                    // echo "4-3: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 4-3');
                    // unload CPU: 1 second sleep
                    // sleep(1);
                }
            }
            //
            unset($info);
        }
        // 'break 2' statements above result in executing the following lines only when everything has been
        //  processed completely & correctly
        // unload CPU: 1 second sleep
        sleep(1);
        // use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
        $redis->unwatch();
        $status = json_decode($redis->get('act_player_info'), true);
        $redis->watch('act_player_info');
        if (isset($status['currentartist']) && $status['currentartist']) {
            $currentAlbumArtistSong = trim(preg_replace('/\s+/', '', $status['currentalbum'].$status['currentartist'].$status['currentsong']));
        } else {
            $currentAlbumArtistSong = trim(preg_replace('/\s+/', '', $status['currentalbum'].$status['currentalbumartist'].$status['currentsong']));
        }
    }
    $redis->unwatch();
    unset($status);
    // close the socket if its not been done
    if ($socket) {
        closeMpdSocket($socket);
        $socket = 0;
    }
    // unload CPU: 1 second sleep
    sleep(1);
}
// close Redis connection
$redis->close();

runelog('WORKER rune_MPDEM_wrk END...');
#---
#End script
