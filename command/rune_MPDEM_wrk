#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2015 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2015 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2015 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2015 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_MPDEM_wrk
 *  version: 0.5
 *  coder: janui
 *  date: March 2022
 *  description:
 *      this script replaces app/coverart_ctl.php, app/artist_info_ctl.php and app/lyric_ctl.php these
 *      files were previously called by the javascript UI engine (runeaudio.js) to retrieve album art
 *      artist information and lyrics at the moment it was required for display
 *      while these scripts were operating the UI was blocked which caused poor UI response and the routines
 *      were also called by each active client causing stress on the external data-service providers
 *      in the new situation the information retrieved once and is pushed to the UI from the back-end
 *      some caching is applied to improve performance to reduce the load on the external data-service
 *      providers
 *      information for the next track (if known) is pre-retrieved while playing the previous track, this
 *      also helps the UI response
 *      all the data active data is stored in the redis variable 'act_player_info' which is concurrently updated
 *      by rune_PL_wrk, updates by rune_PL_wrk have priority
 *      redis transaction constructs watch and exec are used to eliminate 'act_player_info' update conflicts
 */
// initialisation
// report errors: set display_errors to true (=1)
ini_set('display_errors', '1');
// report all PHP errors: set error_reporting to -1
ini_set('error_reporting', -1);
// set the name of the error log file
ini_set('error_log', '/var/log/runeaudio/rune_MPDEM_wrk.log');
// common include
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend
require_once('/srv/http/app/libs/openredis.php');
// include the music metadata decode module getid3
// getid3 needs to operate in directory /srv/http/app/libs/vendor
chdir('/srv/http/app/libs/vendor');
require_once('getid3/audioinfo.class.php');
// reset logfile
sysCmd('echo "--------------- start: rune_MPDEM_wrk ---------------" > /var/log/runeaudio/rune_MPDEM_wrk.log');
// logging starting message
runelog('WORKER rune_MPDEM_wrk STARTING...');
// define APP global
define('APP', '/srv/http/app/');
// get the album art directory and url dir
$artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
$artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
$mpdRoot = rtrim($redis->hGet('mpdconf', 'music_directory'), '/');
//
if ($redis->get('remoteSSbigart') === 'album') {
    $bigartIsAlbum = true;
} else {
    $bigartIsAlbum = false;
}
// load the lyrics tags, comma delimited, possibly with quotes, nomally lowwer case
$lyricsTags = explode(',', $redis->hGet('lyrics', 'lyrics_tags'));
foreach ($lyricsTags as $key => &$lyricsTag) {
    // remove quotes from the tag and trim
    $lyricsTag = trim(preg_replace('/[\"\']/', '', $lyricsTag));
    // skip and remove empty tag names
    if (!$lyricsTag) {
        unset($lyricsTags[$key]);
    }
}
// get the genres where lyrics are omitted unless they are supplied as embedded tags, comma delimited, possibly with quotes
$omit_lyrics = explode(',', $redis->hGet('lyrics', 'omit_lyrics'));
foreach ($omit_lyrics as $key => &$omit_lyric) {
    // remove quotes from the tag and trim
    $omit_lyric = trim(preg_replace("/[\"\']/", '', $omit_lyric));
    // skip and remove empty tag names
    if (!$omit_lyrics) {
        unset($omit_lyrics[$key]);
    }
}
// process lyrics files?
if ($redis->hGet('lyrics', 'lyric_file')) {
    $procesLyricsFiles = true;
} else {
    $procesLyricsFiles = false;
}
//
$statusCnt = 10;
$saveFile = '';
while (true)  {
    // loop forever
    // process the extra metadata
    $status = json_decode($redis->get('act_player_info'), true);
    if (isset($status['radio']) && trim($status['radio'])) {
        $curSongIsRadio = true;
    } else {
        $curSongIsRadio = false;
    }
    if ((trim($status['artist_bio_summary']) == '')
            || (trim($status['song_lyrics']) == '')) {
        $saveFile = '';
    }
    while (isset($status['actPlayer']) && isset($status['file'])
            && ($status['actPlayer'] === 'MPD') && trim($status['file']) && ($status['file'] != $saveFile)) {
        // loop while MPD and the song has changed
        // so exit if the song is the same at the start and end of the loop
        //
        // main processing
        //
        // use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
        $redis->unwatch();
        $redis->watch('act_player_info');
        $saveFile = $status['file'];
        //
        // clear the variables set in this script
        //  many are set to a single space which will cause the UI to use the value, clearing unset information (an
        //  empty string is ignored in the UI)
        //
        $status['mainArtURL'] = '';
        $status['bigArtURL'] = '';
        $status['smallArtURL'] = '';
        $status['bitrate'] = ' ';
        $status['audio_sample_rate'] = ' ';
        $status['audio_sample_depth'] = ' ';
        $status['song_lyrics'] = ' ';
        $status['coverArtPreload'] = '';
        $status['artist_bio_summary'] = ' ';
        $status['artist_similar'] = ' ';
        //
        // open the MPD socket
        $socket = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
        $currsongid = '';
        $nextsongid = '';
        //
        // get the current status, this includes pointers to the current song and the next song
        //
        if ($socket && sendMpdCommand($socket, 'status')) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, 'songid: ') === 1) {
                        // careful, 'songid: ', dont match 'nextsongid: '
                        $currsongid = trim(explode(': ', $retline, 2)[1]);
                    } else if (strpos(' '.$retline, 'nextsongid: ') === 1) {
                        $nextsongid = trim(explode(': ', $retline, 2)[1]);
                    } else if (strpos(' '.$retline, 'state: ') === 1) {
                        $state = trim(explode(': ', $retline, 2)[1]);
                    }
                }
            }
        }
        // debug
        // echo "Currsongid 1: '$currsongid', Nextsongid: '$nextsongid'\n";
        runelog('[rune_MPDEM_wrk]', "Currsongid 1: '$currsongid', Nextsongid: '$nextsongid'");
        if (!$currsongid && !$nextsongid) {
            if ($state != 'stop') {
                // nothing to do, loop or continue the loop
                $saveFile = '';
                sleep(2);
                break;
            } else {
                if ($socket && sendMpdCommand($socket, 'playlistinfo 0')) {
                    $retval = readMpdResponse($socket);
                    if ($retval && strpos($retval, "OK\n")) {
                        // response is valid
                        $retarray = explode("\n", $retval);
                        foreach ($retarray as $retline) {
                            if (strpos(' '.$retline, 'Id: ') === 1) {
                                $currsongid = trim(explode(': ', $retline, 2)[1]);
                            }
                        }
                    }
                }
                if ($socket && sendMpdCommand($socket, 'playlistinfo 1')) {
                    $retval = readMpdResponse($socket);
                    if ($retval && strpos($retval, "OK\n")) {
                        // response is valid
                        $retarray = explode("\n", $retval);
                        foreach ($retarray as $retline) {
                            if (strpos(' '.$retline, 'Id: ') === 1) {
                                $nextsongid = trim(explode(': ', $retline, 2)[1]);
                            }
                        }
                    }
                }
                // debug
                // echo "Currsongid 2: '$currsongid', Nextsongid: '$nextsongid'\n";
                runelog('[rune_MPDEM_wrk]', "Currsongid 2: '$currsongid', Nextsongid: '$nextsongid'");
                if (!$currsongid && !$nextsongid) {
                    // nothing to do, loop or continue the loop
                    $saveFile = '';
                    sleep(2);
                    break;
                }
            }
        }
        $songinfo = array();
        //
        // get the current song information and create the 'currsong' cache table entry, when not a radio
        //
        if ($currsongid && $socket && sendMpdCommand($socket, 'playlistid '.$currsongid)) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                $currsong = array();
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, ': ')) {
                        $retlineparts = explode(': ', $retline, 2);
                        $retlineparts[0] = trim($retlineparts[0]);
                        $retlineparts[1] = trim($retlineparts[1]);
                        if ($retlineparts[0] && $retlineparts[1]) {
                            $songinfo['currsong'][strtolower($retlineparts[0])] = $retlineparts[1];
                        }
                    }
                }
            } else {
                // mpd response invalid, clear the array element
                unset($songinfo['currsong']);
            }
        } else {
            // mpd socket invalid or send command failed, clear the array element
            unset($songinfo['currsong']);
        }
        if (!isset($songinfo['currsong']['file']) || ($songinfo['currsong']['file'] !== $saveFile)) {
            // current song file from MPD not set or it differs from current file in act_player_info, song has changed
            $saveFile = '';
            break;
        }
        if ($curSongIsRadio) {
            // its a radio, don't process it, remove it from the array
            unset($songinfo['currsong']);
        } else if (strpos(' '.strtolower($songinfo['currsong']['file']), 'http') === 1) {
            // the file has a prefix of http, so it could still be a radio
            if (is_radioUrl($redis, $songinfo['currsong']['file'])) {
                // it exists and its a radio, don't process it, remove it from the array
                unset($songinfo['currsong']);
            }
        } else if (strpos(' '.$songinfo['currsong']['file'], 'alsa:') === 1) {
            // hardware alsa input, don't process it, remove it from the array
            unset($songinfo['currsong']);
        } else if (strpos(' '.$songinfo['currsong']['file'], 'cdda:') === 1) {
            // hardware CD input, don't process it, remove it from the array
            unset($songinfo['currsong']);
        }
        //
        // get the next song information and create the 'nextsong' cache table entry
        //
        if ($nextsongid && $socket && sendMpdCommand($socket, 'playlistid '.$nextsongid)) {
            $retval = readMpdResponse($socket);
            if ($retval && strpos($retval, "OK\n")) {
                // response is valid
                $retarray = explode("\n", $retval);
                foreach ($retarray as $retline) {
                    if (strpos(' '.$retline, ': ')) {
                        $retlineparts = explode(': ', $retline, 2);
                        $retlineparts[0] = trim($retlineparts[0]);
                        $retlineparts[1] = trim($retlineparts[1]);
                        if ($retlineparts[0] && $retlineparts[1]) {
                            $songinfo['nextsong'][strtolower($retlineparts[0])] = $retlineparts[1];
                        }
                    }
                }
            } else {
                // mpd response invalid, clear the array
                unset($songinfo['nextsong']);
            }
        } else {
            // mpd socket invalid or send command failed, clear the array
            unset($songinfo['nextsong']);
        }
        if (!isset($songinfo['nextsong']['file'])) {
            // next song file from MPD not set
            unset($songinfo['nextsong']);
        } else if (strpos(' '.strtolower($songinfo['nextsong']['file']), 'http') === 1) {
            // the file has a prefix of http, so it could be a radio
            if (is_radioUrl($redis, $songinfo['nextsong']['file'])) {
                // it exists and its a radio, don't process it, remove it from the array
                unset($songinfo['nextsong']);
            }
        } else if (strpos(' '.$songinfo['nextsong']['file'], 'alsa:') === 1) {
            // hardware alsa input, don't process it, remove it from the array
            unset($songinfo['nextsong']);
        } else if (strpos(' '.$songinfo['nextsong']['file'], 'cdda:') === 1) {
            // hardware CD input, don't process it, remove it from the array
            unset($songinfo['nextsong']);
        }
        //
        // tidy up
        //
        unset($retval, $retarray, $retline, $retlineparts, $currsongid, $nextsongid);
        //
        // process the songinfo array, which has one or two entries, current song 'currsong' and in most cases also next song 'nextsong'
        //
        if (!count($songinfo)) {
            // songinfo array empty, nothing to do, the foreach below will do nothing
            $saveFile = '';
            break;
        }
        foreach ($songinfo as $songkey => &$song) {
            // note: $song is by reference and can be modified
            //
            // retrieve and validate the cached information
            //
            $song['file'] = $mpdRoot.'/'.$song['file'];
            $datafile = md5($song['file']);
            if (isset($song['album']) && isset($song['albumartist']) && isset($song['date']) && isset($song['title'])
                    && $song['album'] && $song['albumartist'] && $song['date'] && $song['title']) {
                $imagename = md5($song['album'].$song['albumartist'].$song['date']);
            } else if (isset($song['album']) && isset($song['artist']) && isset($song['title'])
                    && $song['album'] && $song['artist'] && $song['title']) {
                $imagename = md5($song['album'].$song['artist']);
            } else {
                $imagename = $datafile;
            }
            $song['datafile'] = $artDir.'/'.$datafile.'.mpd';
            clearstatcache(true, $song['datafile']);
            if (file_exists($song['datafile'])) {
                touch($song['datafile']);
                $song = array_merge($song, json_decode(file_get_contents($song['datafile']), true));
            }
            if (isset($song['albumarturl'])) {
                // artfile entry in the array is set
                if (substr($song['albumarturl'], 0, 4) === 'http') {
                    // the name of the arturl is set and it is a web image, so still valid
                    // remove the album art file entry, it should not be there
                    unset($song['albumartfile']);
                } else if (isset($song['albumartfile']) && $song['albumartfile']) {
                    // album art file entry has a value
                    clearstatcache(true, $song['albumartfile']);
                    if (file_exists($song['albumartfile'])) {
                        // artfile exists, update its date stamp, the cache is still valid
                        touch($song['albumartfile']);
                    } else {
                        // cache is invalid clear the album art file and album art url entries
                        unset($song['albumartfile'], $song['albumarturl']);
                    }
                } else {
                    // cache is invalid clear the album art file and album art url entries
                    unset($song['albumartfile'], $song['albumarturl']);
                }
            } else {
                // cache is invalid clear the album art file and album art url entries
                unset($song['albumartfile'], $song['albumarturl']);
            }
            //
            // attempt to find lyrics files and use then if enabled and available
            //
            if ($procesLyricsFiles && (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) && isset($song['file']) && $song['file']) {
                $prefixFile = strtolower(substr($song['file'],0, 4));
                if (!strpos('|http|', $prefixFile)) {
                    // process non-http files, works only on locally mounted files
                    $pathParts = pathinfo($song['file']);
                    $fileDirFile = $pathParts['dirname'].'/'.$pathParts['filename'];
                    // lower case file extension
                    $lyricFileName = $fileDirFile.'.lrc';
                    clearstatcache(true, $lyricFileName);
                    if (file_exists($lyricFileName)) {
                        $song['song_lyrics'] = strip_synchronised_lyrics(file_get_contents($lyricFileName));
                    }
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        // upper case file extension
                        $lyricFileName = $fileDirFile.'.LRC';
                        clearstatcache(true, $lyricFileName);
                        if (file_exists($lyricFileName)) {
                            $song['song_lyrics'] = strip_synchronised_lyrics(file_get_contents($lyricFileName));
                        }
                    }
                }
            }
            //
            // process album art and other embedded metadata information
            //
            if (isset($song['albumarturl'])) {
                // a cached file has been found, we can skip the next section
                $song['artFound'] = true;
            } else {
                $song['artFound'] = false;
            }
            if (!$song['artFound']) {
                // determine the album art and other embedded metadata information
                //
                // 1. try to extract embedded metadata (coverart, lyrics, etc.) with getid3
                //
                // getID3 needs to operate in directory /srv/http/app/libs/vendor
                chdir('/srv/http/app/libs/vendor');
                // run getID3 and trap any errors
                $auOK = true;
                unset($au, $auinfo);
                try {
                    // Code that may throw an Exception or Error.
                    $au = new AudioInfo();
                    $auinfo =  $au->Info($song['file']);
                }
                catch (Throwable $t) {
                    // Executed only in PHP 7 and higher, will not match in PHP 5 and lower
                    // save the name of the file which caused the error
                    $redis->set('getID3_error', $song['file']);
                    $auOK = false;
                    echo "[rune_MPDEM_wrk] Caught Throwable ('{$t->getMessage()}')\n{$t}\n";
                }
                catch (Exception $e) {
                    // Executed only in PHP 5 and lower, will not match in PHP 7 and higher
                    // save the name of the file which caused the error
                    $redis->set('getID3_error', $song['file']);
                    $auOK = false;
                    echo "[rune_MPDEM_wrk] Caught Exception ('{$e->getMessage()}')\n{$e}\n";
                }
                if ($auOK && is_array($auinfo)) {
                    // set up the file names, we assume jpg, but it could be something else, regardless
                    //  of this, the browser seems to test the image file type and use it correctly
                    $song['albumartfile'] = $artDir.'/'.$imagename.'.jpg';
                    $song['albumarturl'] = $artUrl.'/'.$imagename.'.jpg';
                    if (isset($auinfo['comments']['picture'][0]['data']) && (strlen($auinfo['comments']['picture'][0]['data']) > 200)) {
                        // the music file has embedded metadata and it has a size of more than 200 bytes, save it
                        file_put_contents($song['albumartfile'], $auinfo['comments']['picture'][0]['data']);
                        // get some information about the file
                        list($width, $height, $type, $attr) = getimagesize($song['albumartfile']);
                        // width and height are in pixels (null when invalid), type is a non zero/null value when valid
                        if (isset($width) && isset($height) && isset($type) && ($width > 20) && ($height > 20) && $type) {
                            // it is a valid image file (or at least it has a valid header) and it is at least 20x20px
                            $song['artFound'] = true;
                        } else {
                            // the image file has an invalid format or is very small, delete it
                            unlink($song['albumartfile']);
                        }
                    }
                    // save the other getID3 fields (e.g. average bitrate and sample rate)
                    foreach ($auinfo as $valuekey => $value) {
                        if (!is_array($value)) {
                            // most of the useful information is stored at the first level of the array
                            $value = trim($value);
                            if ($value) {
                                $song[strtolower($valuekey)] = $value;
                            }
                        }
                    }
                    // if there are music brainz id's in the metadata save them
                    if (!isset($song['artist_mbid'])) {
                        $artist_mbid = trim(search_array_keys($auinfo, 'artist_mbid'));
                        if ($artist_mbid) {
                            $song['artist_mbid'] = $artist_mbid;
                        }
                    }
                    if (!isset($song['album_mbid'])) {
                        $album_mbid = trim(search_array_keys($auinfo, 'album_mbid'));
                        if ($album_mbid) {
                            $song['album_mbid'] = $album_mbid;
                        }
                    }
                    if (!isset($song['song_mbid'])) {
                        $song_mbid = trim(search_array_keys($auinfo, 'song_mbid'));
                        if ($song_mbid) {
                            $song['song_mbid'] = $song_mbid;
                        }
                    }
                    // check for average bit rate (avg_bit_rate)
                    if (!isset($song['avg_bit_rate'])) {
                        $avg_bit_rate = trim(search_array_keys($auinfo, 'avg_bit_rate'));
                        if ($avg_bit_rate) {
                            $song['avg_bit_rate'] = $avg_bit_rate;
                        }
                    }
                    // check for song lyrics
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        foreach ($lyricsTags as $key => $lyricsTag) {
                            $lyricsTagLower = strtolower($lyricsTag);
                            if ((lyricsTagLower != $lyricsTag) && isset($auinfo[$lyricsTagLower]) && trim($auinfo[$lyricsTagLower])) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($auinfo[$lyricsTagLower]);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                            if (isset($auinfo[$lyricsTag]) && trim($auinfo[$lyricsTag])) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($auinfo[$lyricsTag]);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                        }
                    }
                    if (!isset($song['song_lyrics']) || !trim($song['song_lyrics'])) {
                        foreach ($lyricsTags as $key => $lyricsTag) {
                            $lyricsTagLower = strtolower($lyricsTag);
                            if (lyricsTagLower != $lyricsTag) {
                                $lyrics = trim(search_array_keys($auinfo, $lyricsTagLower));
                                if (isset($lyrics) && $lyrics) {
                                    $song['song_lyrics'] = strip_synchronised_lyrics($lyrics);
                                    if (trim($song['song_lyrics'])) {
                                        break;
                                    }
                                }
                            }
                            $lyrics = trim(search_array_keys($auinfo, $lyricsTag));
                            if (isset($lyrics) && $lyrics) {
                                $song['song_lyrics'] = strip_synchronised_lyrics($lyrics);
                                if (trim($song['song_lyrics'])) {
                                    break;
                                }
                            }
                        }
                    }
                }
                unset($au, $auinfo, $width, $height, $type, $attr, $valuekey, $value, $artist_mbid, $album_mbid, $song_mbid, $avg_bit_rate, $lyrics);
            }
            if (isset($song['file']) && $song['file']) {
                $prefixFile = strtolower(substr($song['file'],0, 4));
                if (strpos('|http|', $prefixFile)) {
                    // local coverart will not work network files
                    $song['local'] = false;
                } else {
                    // local coverart will only work on locally mounted files
                    $song['local'] = true;
                }
            }
            if (!$song['artFound'] && $song['local']) {
                //
                // 2. try to find local coverart
                //
                $coverArtFileNames = array('folder.jpg', 'cover.jpg', 'folder.png', 'cover.png', 'FOLDER.JPG', 'COVER.JPG', 'FOLDER.PNG', 'COVER.PNG');
                $coverArtDirectory = dirname($song['file']).'/';
                foreach ($coverArtFileNames as $coverArtFileName) {
                    clearstatcache(true, $coverArtDirectory.$coverArtFileName);
                    if (file_exists($coverArtDirectory.$coverArtFileName)) {
                        // there is a valid art file in the album directory, copy it to the art directory
                        copy($coverArtDirectory.$coverArtFileName, $song['albumartfile']);
                        $song['artFound'] = true;
                        // finish when one is found, exit the innermost loop
                        break;
                    }
                }
                unset($coverArtFileNames, $coverArtDirectory);
            }
            //
            // only when processing the current song and that albumart has been found update the UI
            if (($songkey === 'currsong') && $song['artFound']) {
                // assume the current song is still valid
                if (($state == 'stop') || ($status['state'] == 'stop')) {
                    $status['song_percent'] = 0;
                    $status['elapsed'] = 0;
                }
                $status['mainArtURL'] = $song['albumarturl'];
                if ($bigartIsAlbum) {
                    $status['bigArtURL'] = $song['albumarturl'];
                } else {
                    $status['smallArtURL'] = $song['albumarturl'];
                }
                if (isset($song['avg_bit_rate']) && $song['avg_bit_rate']) {
                    if (!is_numeric($song['avg_bit_rate'])) {
                        $status['bitrate'] = $song['avg_bit_rate'];
                    } else {
                        $status['bitrate'] = intval(intval($song['avg_bit_rate'])/1000);
                    }
                }
                if (!isset($status['audio_sample_rate']) || !trim($status['audio_sample_rate'])) {
                    if (isset($song['sample_rate']) && $song['sample_rate']) {
                        $status['audio_sample_rate'] = round($song['sample_rate']/1000, 1);
                    }
                }
                if (!isset($status['audio_sample_depth']) || !trim($status['audio_sample_depth'])) {
                    if (isset($song['bits_per_sample']) && $song['bits_per_sample']) {
                        $status['audio_sample_depth'] = $song['bits_per_sample'];
                    }
                }
                if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                    $status['song_lyrics'] = $song['song_lyrics'];
                }
                unset($status['song_percent'], $status['elapsed']);
                // use redis (watch and) exec to update act_player_info
                // use (watch and) exec to update act_player_info
                $retval = $redis->multi()
                    ->set('act_player_info', json_encode($status))
                    ->exec();
                if ($retval) {
                    // update successful
                    //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                    $redis->unwatch();
                    $redis->watch('act_player_info');
                    // debug
                    // echo "0-1: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 0-1');
                } else {
                    // act_player_info has changed
                    //  currently in a double loop, continue at the end of the outside loop
                    $saveFile = '';
                    // debug
                    // echo "0-2: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 0-2');
                    break 2;
                }
                ui_render('playback', json_encode($status));
                // debug
                // echo "0-3: ".$saveFile.", ".$status['file']."\n";
                runelog('[rune_MPDEM_wrk] 0-3');
                // unload CPU: 1 second sleep
                // sleep(1);
            } else if (($songkey === 'nextsong') && $song['artFound']) {
                // when processing the nextsong only update the cover art preload url
                // assume the next song is still valid
                // set the cover art preload to the next song art url when changed
                if (!isset($status['coverArtPreload']) || ($status['coverArtPreload'] != $song['albumarturl'])) {
                    $status['coverArtPreload'] = $song['albumarturl'];
                    if (($state == 'stop') || ($status['state'] == 'stop')) {
                        $status['song_percent'] = 0;
                        $status['elapsed'] = 0;
                    } else {
                        unset($status['song_percent'], $status['elapsed']);
                    }
                    // use (watch and) exec to update act_player_info
                    $retval = $redis->multi()
                        ->set('act_player_info', json_encode($status))
                        ->exec();
                    if ($retval) {
                        // update successful
                        //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                        $redis->unwatch();
                        $redis->watch('act_player_info');
                        // debug
                        // echo "1-1: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 1-1');
                    } else {
                        // act_player_info has changed
                        //  currently in a double loop, continue at the end of the outside loop
                        $saveFile = '';
                        // debug
                        // echo "1-2: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 1-2');
                        break 2;
                    }
                    ui_render('playback', json_encode($status));
                    // debug
                    // echo "1-3: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 1-3');
                    // unload CPU: 1 second sleep
                    // sleep(1);
                }
            }
            file_put_contents($song['datafile'], json_encode($song)."\n");
            //
            // get the artistinfo & lyrics
            //
            $info = array();
            if (isset($song['artist'])) {
                $info['artist'] = $song['artist'];
            } else {
                $info['artist'] = '';
            }
            if (isset($song['albumartist'])) {
                $info['albumartist'] = $song['albumartist'];
            } else {
                $info['albumartist'] = '';
            }
            if (isset($song['title'])) {
                $info['song'] = $song['title'];
            } else {
                $info['song'] = '';
            }
            if (isset($song['title'])) {
                $info['album'] = $song['album'];
            } else {
                $info['album'] = '';
            }
            if (isset($song['artist_mbid'])) {
                $info['artist_mbid'] = $song['artist_mbid'];
            }
            if (isset($song['album_mbid'])) {
                $info['album_mbid'] = $song['album_mbid'];
            }
            if (isset($song['song_mbid'])) {
                $info['song_mbid'] = $song['song_mbid'];
            }
            $retval = get_artistInfo($redis, $info);
            if ($retval) {
                $info = array_merge($info, $retval);
            }
            // some lyrics are omitted since they almost never exits, default is 'classical, baroque'
            $omit_string = '';
            if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                // we already have lyrics so use them
                $info['song_lyrics'] = $song['song_lyrics'];
            } else if (isset($song['genre']) && trim($song['genre'])) {
                // determine omitted lyrics
                foreach ($omit_lyrics as $omit_lyric) {
                    if (strpos(' '.strtolower($song['genre']), $omit_lyric)) {
                        // found a genre with omitted lyrics
                        $omit_string = $omit_lyric;
                        break;
                    }
                }
            }
            if ($omit_string) {
                // skip the lyrics
                $info['song_lyrics'] = 'Lyrics retrieval omitted for the "'.$omit_string.'" genre';
            } else {
                // when genre is unknown or not omitted get the lyrics (also when we already know the lyrics, this will cache them)
                $retval = get_songInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
            }
            // it seems illogical for this to be here however it is more effective to search
            //  for cover art on internet after searching for the artist and song information
            if (!$song['artFound']) {
                //
                // 3. try to find coverart on internet
                //
                $retval = get_albumInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
                // the routine always returns image names, including when 'not found'
                //  album_arturl_large, album_arturl_medium, and album_arturl_small
                // in this case there is no image file
                unset($song['albumartfile']);
                $song['albumarturl'] = $info['album_arturl_medium'];
                $song['artFound'] = true;
            }
            if ($song['artFound']) {
                // save the songinfo data
                file_put_contents($song['datafile'], json_encode($song)."\n");
            } else {
                unset($song['albumarturl']);
            }
            //
            if ($songkey === 'currsong') {
                // currnet song
                // assume the current song is still valid
                if (isset($song['albumarturl']) && trim($song['albumarturl'])) {
                    $status['mainArtURL'] = $song['albumarturl'];
                    if ($bigartIsAlbum) {
                        $status['bigArtURL'] = $song['albumarturl'];
                    } else {
                        $status['smallArtURL'] = $song['albumarturl'];
                    }
                }
                if (isset($song['avg_bit_rate']) && trim($song['avg_bit_rate'])) {
                    $status['bitrate'] = intval($song['avg_bit_rate']/1000);
                }
                if (!isset($status['audio_sample_rate']) || !trim($status['audio_sample_rate'])) {
                    if (isset($song['sample_rate']) && $trim(song['sample_rate'])) {
                        $status['audio_sample_rate'] = round($song['sample_rate']/1000, 1);
                    }
                }
                if (!isset($status['audio_sample_depth']) || !trim($status['audio_sample_depth'])) {
                    if (isset($song['bits_per_sample']) && trim($song['bits_per_sample'])) {
                        $status['audio_sample_depth'] = $song['bits_per_sample'];
                    }
                }
                if (isset($song['song_lyrics']) && trim($song['song_lyrics'])) {
                    $status['song_lyrics'] = $song['song_lyrics'];
                } else if (isset($info['song_lyrics']) && trim($info['song_lyrics'])) {
                    $status['song_lyrics'] = $info['song_lyrics'];
                }
                $status['artist_bio_summary'] = $info['artist_bio_summary'];
                $status['artist_similar'] = $info['artist_similar'];
                if ($artUrl === substr($info['artist_arturl'], 0, strlen($artUrl))) {
                    // the artist art has not been found, so use the album art
                    $info['artist_arturl'] = $status['mainArtURL'];
                }
                if ($bigartIsAlbum) {
                    $status['smallArtURL'] = $info['artist_arturl'];
                } else {
                    $status['bigArtURL'] = $info['artist_arturl'];
                }
                unset($status['song_percent'], $status['elapsed']);
                // use (watch and) exec to update act_player_info
                $retval = $redis->multi()
                    ->set('act_player_info', json_encode($status))
                    ->exec();
                if ($retval) {
                    // update successful
                    //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                    $redis->unwatch();
                    $redis->watch('act_player_info');
                    // debug
                    // echo "3-1: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 3-1');
                } else {
                    // act_player_info has changed
                    //  currently in a double loop, continue at the end of the outside loop
                    $saveFile = '';
                    // debug
                    // echo "3-2: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 3-2');
                    break 2;
                }
                ui_render('playback', json_encode($status));
                // debug
                // echo "3-3: ".$saveFile.", ".$status['file']."\n";
                runelog('[rune_MPDEM_wrk] 3-2');
                // unload CPU: 1 second sleep
                // sleep(1);
            } else if (($songkey === 'nextsong') && $song['artFound']) {
                // when processing the nextsong only update the cover art preload url
                // assume the next song is still valid
                // set the cover art preload to the next song art url when changed
                if (!isset($status['coverArtPreload']) || ($status['coverArtPreload'] != $song['albumarturl'])) {
                    $status['coverArtPreload'] = $song['albumarturl'];
                    unset($status['song_percent'], $status['elapsed']);
                    // use (watch and) exec to update act_player_info
                    $retval = $redis->multi()
                        ->set('act_player_info', json_encode($status))
                        ->exec();
                    if ($retval) {
                        // update successful
                        //  use redis watch (and exec) to update act_player_info, any updates from rune_PL_wrk have priority
                        $redis->unwatch();
                        $redis->watch('act_player_info');
                        // debug
                        // echo "4-1: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 4-1');
                    } else {
                        // act_player_info has changed
                        //  currently in a double loop, continue at the end of the outside loop
                        // debug
                        // echo "4-2: ".$saveFile.", ".$status['file']."\n";
                        runelog('[rune_MPDEM_wrk] 4-2');
                        $saveFile = '';
                        break 2;
                    }
                    ui_render('playback', json_encode($status));
                    // debug
                    // echo "4-3: ".$saveFile.", ".$status['file']."\n";
                    runelog('[rune_MPDEM_wrk] 4-3');
                    // unload CPU: 1 second sleep
                    // sleep(1);
                }
            }
            //
            unset($info);
        }
        // 'break 2' statements above result in executing the following lines only when everything has been
        //  processed completely & correctly
        // unload CPU: 1 second sleep
        sleep(1);
        $status = json_decode($redis->get('act_player_info'), true);
    }
    $redis->unwatch();
    unset($status);
    // close the socket if its not been done
    if (isset($socket) && $socket) {
        closeMpdSocket($socket);
        unset($socket);
    }
    // unload CPU: 1 second sleep
    sleep(1);
}
// close Redis connection
$redis->close();

runelog('WORKER rune_MPDEM_wrk END...');
#---
#End script
