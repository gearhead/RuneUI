#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/refresh_nics
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
// common include
ini_set('display_errors', '1');
// ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/refresh_nics.log');
// Connect to Redis backend
$redis = new Redis();
$redis->connect('/run/redis/socket');
require_once('/var/www/app/libs/runeaudio.php');
include '/var/www/app/libs/vendor/ziegler/iwlist-parser.class.php';
// startup - lock the scan system
runelog('--------------------------- lock the scan system ---------------------------');
$redis->Set('lock_wifiscan', 1);
// random delay
$sleep = rand(1000000, 2000000);
usleep($sleep);
runelog('random delay: ', $sleep);
// startup - collect system data
runelog('--------------------------- collect system data ---------------------------');
$excluded_nics = array('ifb0', 'ifb1', 'p2p0', 'bridge');
$active_nics = sysCmd("ifconfig | grep UP | cut -d ':' -f 1");
$detected_nics = sysCmd("ip addr |grep \"BROADCAST,\" |cut -d':' -f1-2 |cut -d' ' -f2");
$detected_nics = array_diff($detected_nics, $excluded_nics);
$inactive_nics = array_diff($detected_nics, $active_nics);
// configured nics will show with *A in connman. 
// to parse the connman info, we need the MAC of all addresses
// this gives the MAC of eth0 "ip link show dev eth0 |grep "link/ether" | sed 's/^[ \t]*//' |cut -d " " -f 2 | tr -d ':'"
$eth0MAC = sysCmd("ip link show dev eth0 |grep 'link/ether' | sed 's/^[ \t]*//' |cut -d ' ' -f 2 | tr -d ':'");
//print_r($eth0MAC);
$wlan0MAC = sysCmd("ip link show dev wlan0 |grep 'link/ether' | sed 's/^[ \t]*//' |cut -d ' ' -f 2 | tr -d ':'");
//print_r($wlan0MAC);
runelog('########### Set eth MACs ###########');
// can probably automate this to grab all MACs and put them in an array in redis for use...
$redis->Set('eth0MAC',$eth0MAC[0]);
$redis->Set('wlan0MAC',$wlan0MAC[0]);
//$configured_nics = array_map("trim", sysCmd("netctl list | cut -d ' ' -f 2,3"));
$configured_nics = array_map("trim",sysCmd("connmanctl services | grep '*A' | cut -b 26-"));
// this provides the list of known networks to connman we need to parse them
// and format them
// this is currently either ethx (the nic) or the SSID of the connected network (not a nics)...
// I think this should be actual nics...
$i=0;
foreach($configured_nics as &$value){
if (strpos($value,$eth0MAC[0])) {
    $value = 'eth0';
}
elseif (strpos($value,$wlan0MAC[0])) {
    //$value = sysCmd("connmanctl services | grep '*A' | cut -b 5-25 | sed 's/ //g'")[$i];
    $value = 'wlan0';
}
// need to think about how to add more wlan MACs or a better way of doing this. 
// if we could ues ip addr and look at all entries which are not lo: the second field would be
// an array of network interfaces... if only I could parse this into php...
$i=$i+1;
}

$removed_nics = array_diff($configured_nics, $detected_nics);
// debug
runelog('########### active_nics ########### ', $active_nics);
// print_r($active_nics);
// print_r($excluded_nics);
runelog('########### excluded_nics ########### ', $excluded_nics);
// print_r($detected_nics);
runelog('########### detected_nics ########### ', $detected_nics);
// print_r(array_diff($detected_nics,$active_nics));
// print_r($configured_nics);
runelog('########### configured_nics ########### ', $configured_nics);
// print_r(array_diff($configured_nics,$detected_nics));
// print_r($removed_nics);
runelog('########### removed_nics ########### ', $removed_nics);
// check if wlan0/1 is detected
if (!in_array("wlan0", $detected_nics)) {
// with netctl we restart service. with connman, need to see if it is up
// then turn it on then connect
    $retval = sysCmd('iwctl device list | grep -c "off"');
    if ($retval[0] === '0') {
        sysCmd ("connmanctl disable wifi");
        sysCmd ("connmanctl enable wifi");
        runelog('######## Enabled wlan0 ########');
    }
}
//if (!in_array("wlan1", $detected_nics)) {
//    //$retval = sysCmd('systemctl is-enabled netctl-auto@wlan1');
//    $retval = sysCmd('iwctl device list | grep -c "off"');
//    if ($retval[0] === '0') {
//        //sysCmd ("systemctl stop netctl-auto@wlan1");
//        //sysCmd ("systemctl disable netctl-auto@wlan1");
//        sysCmd ("connmanctl disable wifi");
//        runelog('######## Disabled wlan1 ########');
//    }
//}
// handle inactive nics
runelog('--------------------------- handle inactive nics ---------------------------');
unset($nic);
runelog('--------------------------- handle active nics ---------------------------');
// check if there is a stored profile
// if ethernet is not connected, connect it
// if wlan is available. look for a known SSID and connect to it
// refesh visible wifi networks.
runelog('######## Enabled wlan0 ########');
//$iw = new iwlist_parser;
wrk_netconfig($redis, 'setnics');
runelog('######## We return from library ##########');
$nics = wrk_netconfig($redis, 'getnics');
foreach ($nics as $nic => $nicdetail) {
    if ($nicdetail->wireless === 1) {
        if (empty(sysCmd('ifconfig | grep '.$nic.''))) {
            runelog('########### restart link for nic: '.$nic);
                sysCmd('ip link set '.$nic.' up');
                sysCmd ("connmanctl enable wifi");
        }
        runelog('  try nic: '.$nic);

        // test if service is enabled
        // don't know what this is for
        //sysCmd('systemctl enable netctl-auto@'.$nic.'.service');
        // get stored profiles
		// these are configured ssids for wlan
        //$wlans_profiles = sysCmd("netctl-auto list | cut -c3-");
        $wlans_profiles = sysCmd("connmanctl services | grep wifi | grep '*A' | cut -c5-25 | tr -d ' \t\n\r'");
        $redis->set('stored_profiles',json_encode($wlans_profiles));
		// scan for ap in range
// done with iwlist-parser.class.php (zeigler) - very inefficient
// the format is:
// "8":{"nic":"wlan0","origin":"scan","encryption":"on","ESSID":"insight-shared","connected":0}
// need to wrap the output of:
//  iwctl station wlan0 scan
//  iwctl station wlan0 get-networks | sed -e 's/^[ \t]*//' | sed -e "/^ *$/d" |  sed -e '1,4d' | tr -s ' '
// which provides: {insight-shared psk ****} ( 3 fields SSID, Encryption, Strength (4 stars of grey or white))
// the other option is to use connmanctl services which responds with the *AO/R space name...
// connmanctl services | grep wifi |  sed -e "/^ *$/d"
// yields this:
// *AR insight-shared       wifi_74da383afc2e_696e73696768742d736861726564_managed_psk
//     Sequoia              wifi_74da383afc2e_536571756f6961_managed_psk
// to display it in the UI...
        //$scan = $iw->parseScanDev( $nic );
        runelog('--------------------------- Scan Wifis ---------------------------');
        //$scan = sysCmd("iwctl station ".$nic." get-networks | sed -e '1,4d' |sed $'s/[^[:print:]\t]//g' file.txt | tr -s ' '");
        // this shows the non printing charcters
        // iwctl station wlan0 get-networks | sed -e '1,4d' |sed -e 's/[^[:print:]\t]//g' | tr -s ' '
        // we really want to reomve all characters between the '[1;30m' and the '[0m' to make this useful and I have not figured
        // out how. the current command gets rid of the '>' for the connected network, but all networks now show as power
        // level 4 which is not right... kg
        $scan1 = sysCmd("iwctl station wlan0 get-networks | sed -e '1,4d' | sed 's/^ *//g' | tr -s ' ' | sed -r 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g' | sed 's|> ||'");
// this works although I have a trailing blank I cannot get rid of. 
// this has a blank line at the end and I cheated by going to one less than the count 

        $numSSIDs = count ($scan1);
        for ($x = 0; $x < $numSSIDs -1; $x++) {
        $scan [$x] = explode (" ",$scan1[$x]);
        }

        // this breaks it up into each row is an array of 'ssid', 'security', and 'power level'
        // but I do not know how to give each key a name...

        // in my for loop so I do not load it into redis with a blank
        // I think we need to call the array by the name of the nic 'wlan0' to be consistent
        // with previous and also to differentiate between wlan0 and wlan1...

// then go through the list and see if we know it from this list: If you look at the 
// result in wlans in redis, it is what I want, though the variables have no names
// and I do not yet know how to do that so that the rest of this script runs... 
// from here to end is mostly from the netctl version.
// this should cycle through the known SSIDs and connect if they are in range

        $redis->set('wlans',json_encode($scan));
        foreach ($scan as $nicname => $nicscan) {
            runelog('    scan for nic: '.$nic.' nicname = '.$nicname);
            foreach ($nicscan as $count => $wlan) {
                runelog('      scan for nic: '.$nic.' AP = '.$count);
                if ($wlan['ESSID'] === "" OR array_search ($wlan['ESSID'], $tmp_wlans) !== false) {
                    runelog('        SSID already found');
                } else {
                    foreach ($wlan as $key => $value) {
                        $wlans[$count]['nic'] = $nicname;
                        runelog('        scan for nic: '.$nic.' = '.$key.' = '.$value);
                        if ($key === 'ESSID') {
                            $wlans[$count][$key] = $value;
                            $tmp_wlans[] = $value;
                            if ($nicdetail->currentssid === $value) {
                                $wlans[$count]['connected'] = 1;
                            } else {
                                $wlans[$count]['connected'] = 0;
//$ssid_exists = sysCmd("iwctl known-networks list | grep -c '.$value.' | tr -d ' \t\n\r'");
// how do I make this a variable instead of an array element???
//if ($ssid_exists[0] == 1){                      
//sysCmd('iwctl station wlan0 connect '.$value);       
                            }
                            foreach($wlans_profiles as $item){
                                if($item === $value){
                                    $wlans[$count]['storedprofile'] = 1;
                                    break;   // found it!
                                } else {
                                    $wlans[$count]['storedprofile'] = 0;
                                }
                            }
                        }
                        if ($key === 'Encryption key') $wlans[$count]['encryption'] = $value;
                        $wlans[$count]['origin'] = 'scan';
                    }
                }
            }
        }

        // handle hidden but stored profiles
        foreach ($wlans_profiles as $item){
            if ((bool)strpos(serialize($wlans), $item) === false){
                $wlans[++$count]['nic'] = $nic;
                $wlans[$count]['ESSID'] = $item;
                if ($nicdetail->currentssid === $item) {
                    $wlans[$count]['connected'] = 1;
                } else {
                    $wlans[$count]['connected'] = 0;
                }
                $wlans[$count]['storedprofile'] = 1;
                $wlans[$count]['encryption'] = 'unknown';
                $wlans[$count]['origin'] = 'storage';
            }
        }

        //runelog('wlans response: ', $wlans);
        $wlans = json_encode($wlans);
        runelog('wlans response(encoded): ', $wlans);
        ui_render('wlans', $wlans);
    } else {
        // cabled ethernet?
        //should make the system connect to any known networks
        sysCmd('connmanctl connect ethernet_'.$eth0MAC[0].'_cable');
    }
}
// send nics status to RuneUI
ui_render('nics', json_encode($nics));
unset($nic);
// handle removed nics
runelog('--------------------------- handle removed nics ---------------------------');
if (!empty($removed_nics)) {
    foreach($removed_nics as $nic) {
        // check for orphan netctl startup profiles
        if (!empty(sysCmd('ls /etc/systemd/system/multi-user.target.wants/ | grep '.$nic))) {
			// this does nothing as connman does not interact with systemd like this. 
			// the only reason we should delete a profile is manually.
            runelog('########### disable netctl profiles for nic: '.$nic);
            //sysCmd('systemctl disable netctl-ifplugd@'.$nic);
            //sysCmd('systemctl disable netctl-auto@'.$nic);
        }
    }
}

// start AP if configured and no IP is assigned
// it appears that this can be done with iwctl instead of hostapd, but we leave it in here for now
if ($redis->hGet('AccessPoint', 'enabled') === '1') {
    runelog('------------------ try to start AP if no IP is assigned ---------------------');
    $got_one_IP = false;
    if (!empty($active_nics)) {
        foreach($active_nics as $nic) {
            if (($nic === "wlan0") && (sysCmd('ip address show dev '.$nic.' | grep inet | wc -l')[0] !== '0')) {
                runelog('########### got one IP for nic: '.$nic);
                $got_one_IP = true;
            }
        }
    }
   // Start AP only if a supported nic is available by checking for the line '* AP' in the section 'Supported interface modes:' in the output from 'iw list'
   // 'iw list' returns nothing when some unsupported nics are installed. These unsupported nics seem only to work when netctl-auto@wlan0 is running, don't switch it off
   $iwAccessPointInfo = sysCmd("iw list | sed -n '/Supported interface modes:/,/:/p' | grep '* AP$'");
   if (($got_one_IP === false) && (trim($iwAccessPointInfo[0]) == '* AP')) {
   //if ($got_one_IP === false) {
        runelog('########### no IP => start AP on wlan0');
        //sysCmd('systemctl stop netctl-auto@wlan0');
		sysCmd('connmanctl disable wifi');
		sysCmd('connmanctl enable wifi');
        // change AP name
        $file = '/etc/hostapd/hostapd.conf';
        $newArray = wrk_replaceTextLine($file, '', 'ssid=', 'ssid='.$redis->hGet("AccessPoint", "ssid"));
        $fp = fopen($file, 'w');
        $return = fwrite($fp, implode("", $newArray));
        fclose($fp);
        // change passphrase
        $file = '/etc/hostapd/hostapd.conf';
        $newArray = wrk_replaceTextLine($file, '', 'wpa_passphrase=', 'wpa_passphrase='.$redis->hGet("AccessPoint", "passphrase"));
        $fp = fopen($file, 'w');
        $return = fwrite($fp, implode("", $newArray));
        fclose($fp);
        sysCmd('systemctl start hostapd');
        // change dhcp-range
        $file = '/etc/dnsmasq.conf';
        $newArray = wrk_replaceTextLine($file, '', 'dhcp-range=', 'dhcp-range='.$redis->hGet("AccessPoint", "dhcp-range"));
        $fp = fopen($file, 'w');
        $return = fwrite($fp, implode("", $newArray));
        fclose($fp);
        // change dhcp-option
        $file = '/etc/dnsmasq.conf';
        $newArray = wrk_replaceTextLine($file, '', 'dhcp-option-force=option:dns-server,', 'dhcp-option-force=option:dns-server,'.$redis->hGet("AccessPoint", "dhcp-option-dns"));
        $fp = fopen($file, 'w');
        $return = fwrite($fp, implode("", $newArray));
        fclose($fp);
        $file = '/etc/dnsmasq.conf';
        $newArray = wrk_replaceTextLine($file, '', 'dhcp-option-force=option:router,', 'dhcp-option-force=option:router,'.$redis->hGet("AccessPoint", "dhcp-option-router"));
        $fp = fopen($file, 'w');
        $return = fwrite($fp, implode("", $newArray));
        fclose($fp);
        sysCmd('systemctl start dnsmasq');
        sysCmd('ip addr add '.$redis->hGet("AccessPoint", "ip-address").'/24 broadcast '.$redis->hGet("AccessPoint", "broadcast").' dev wlan0');
        if ($redis->hGet('AccessPoint', 'enable-NAT') === '1') {
            sysCmd('iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE');
            sysCmd('iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT');
            sysCmd('iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT');
            sysCmd('sysctl net.ipv4.ip_forward=1');
        }
    }
}
// start AP end

// end - unlock the scan system
runelog('--------------------------- unlock the scan system ---------------------------');
$redis->Set('lock_wifiscan', 0);
// colse Redis connection
$redis->close();
