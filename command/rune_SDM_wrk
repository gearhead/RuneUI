#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_SDM_wrk
 *  version: 0.5b
 *  coder: janui
 *  date: April 2022
 *
 */
//
// this routing reads the play event information from spotifyd and uses it to generate metadata and album art
// the events are processed as follows:
//  change:         -unset elapsed and song_percent, set to stopped then display results
//  endofqueue:     -ignore (internally generated)
//  endoftrack:     -unset elapsed and song_percent, set to stopped then display results
//  load:           -ignore
//  pause:          -unset elapsed and song_percent, set to paused then display results
//  play:           -search for metadata, determine elapsed and song_percent then display results
//  preload:        -ignore
//  preloading:     -search for metadata, but do not display results (this caches the display data for the next song)
//  start:          -initialize data, display switching
//  stop:           -display switching, initiate player-end switch
//  unavailable:    -ignore
//  volumeset:      unset elapsed and song_percent, set the volume then display results
//
// initialisation
// report errors: set display_errors to true (=1)
ini_set('display_errors', '1');
// report all PHP errors: set error_reporting to -1
ini_set('error_reporting', -1);
// set the name of the error log file
ini_set('error_log', '/var/log/runeaudio/rune_SDM_wrk.log');
// common include
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend
require_once('/srv/http/app/libs/openredis.php');
// reset logfile
sysCmd('echo "--------------- start: rune_SDM_wrk ---------------" > /var/log/runeaudio/rune_SDM_wrk.log');
// logging starting message
runelog('WORKER rune_SDM_wrk STARTING...');
// define APP global
define('APP', '/srv/http/app/');
//
// get the album art directory and url dir
$artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
$artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
if ($redis->get('remoteSSbigart') === 'album') {
    $bigartIsAlbum = true;
} else {
    $bigartIsAlbum = false;
}
$mixer = $redis->hGet('spotifyconnect', 'mixer');
if ($mixer == 'PCM' && strlen($card)) {
    // the card has a PCM 'softvol' (software volume) control or there is no card number available (maybe Bluetooth)
    $alsaVolume = false;
} else {
    // the card has a simple control and a card number
    $alsaVolume = true;
    // get the card number
    $card = preg_replace('/[^0-9]/', '',$redis->hGet('spotifyconnect', 'device'));
}
if ($redis->hGet('spotifyconnect', 'save_last_volume')) {
    $save_last_volume = true;
} else {
    $save_last_volume = false;
}
// get the last stored status
$status = json_decode($redis->get('act_player_info'), true);
$updateUI = false;
$cnt = 20;
//
// make sure we have the last track ID
$last_track_id = $redis->hGet('spotifyconnect', 'last_track_id');
do {
    if (isset($job['event'])) {
        $lastEvent = $job['event'];
    } else {
        $lastEvent = 'endofqueue';
    }
    if (isset($status['time'])) {
        $lastTime = $status['time'];
    } else {
        $lastTime = 0;
    }
    if (isset($status['elapsed'])) {
        $lastElapsed = $status['elapsed'];
    } else {
        $lastElapsed = 0;
    }
    $job = array();
    $job['event'] = 'endofqueue';
    $job['track_id'] = $last_track_id;
    $job['duration_ms'] = '0';
    $job['position_ms'] = '0';
    $job['volume'] = '0';
    // pop the jobID from the work fifo queue
    $jobID = $redis->rPop('s_queue_fifo');
    if (!isset($jobID) || !$jobID) {
        // queue is empty
        // in some cases an entry is added to the s_queue without adding an entry to the fifo queue
        //  this should never happen, even so add an entry to the fifo queue for
        //  any entries in the work queue
        foreach ($redis->hGetAll('s_queue') as $jobID => $jobinfo) {
            if (isset($jobID) && $jobID) {
                $redis->lPush('s_queue_fifo', $jobID);
            }
        }
    } else {
        // read the job information from the work queue
        // not end of queue
        if ($redis->hExists('s_queue', $jobID)) {
            $job = array_merge($job, json_decode($redis->hGet('s_queue', $jobID), true));
            $redis->hDel('s_queue', $jobID);
        } else {
            // no work queue entry for the fifo queue entry, this should never happen!
            //  something went wrong, just skip and get the next one
            // unload CPU: 0.5 second sleep before looping
            usleep(500000);
            $active_player = $redis->get('activePlayer');
            continue;
        }
    }
    // PLAYER_EVENT: <one of the values: start, stop, play, pause, change, volumeset, load, preload, endoftrack, unavailable, preloading, endofqueue>
    // ignore the following events
    $skipEvents = array('load', 'preload', 'unavailable');
    if (in_array($job['event'], $skipEvents)) {
        // unload CPU: 0.5 second sleep when there is nothing to do
        usleep(500000);
        $active_player = $redis->get('activePlayer');
        continue;
    }
    $active_player = $redis->get('activePlayer');
    if ($active_player != 'SpotifyConnect') {
        continue;
    }
    // event: stop, start, change, load, play, pause, preload, endoftrack, volumeset, unavailable, preloading
    // track_id: the current Spotify track ID
    // duration_ms: track time in milliseconds
    // position_ms: track current position in milliseconds
    runelog('[rune_SDM_wrk] job PLAYER_EVENT    :', $job['event']);
    runelog('[rune_SDM_wrk] job TRACK_ID        :', $job['track_id']);
    runelog('[rune_SDM_wrk] job TIME            :', $job['duration_ms']);
    runelog('[rune_SDM_wrk] job ELAPSED         :', $job['position_ms']);
    runelog('[rune_SDM_wrk] job VOLUME          :', $job['volume']);
    // echo "E:".$job['event'].", ID:".$job['track_id'].", D:".$job['duration_ms'].", P:".$job['position_ms'].", V:".$job['volume']." \n";
    //
    // first-time start event or stop event
    if (($last_track_id == '') || ($job['event'] == 'start') || ($job['event'] == 'stop')) {
        $last_track_id = '*';
        // initialise the status array
        initialise_playback_array($redis, 'Spotify connect');
        $status['audio'] = "44100:16:2";
        $status['audio_sample_rate'] = "44.1";
        $status['audio_sample_depth'] = "16";
        $status['bitrate'] = $redis->hGet('spotifyconnect', 'bitrate');
        $status['audio_channels'] = "Stereo";
        $status['random'] = "0";
        $status['single'] = "0";
        $status['consume'] = "0";
        $status['playlist'] = "1";
        $status['playlistlength'] = "1";
        $status['state'] = "stop";
        $status['time'] = "0";
        $status['elapsed'] = "0";
        $status['song_percent'] = "0";
        $status['time_last_elapsed'] = microtime(true);
        if ($save_last_volume) {
            // set the volume to the last one used when playing spotify connect
            $lastvolume = $redis->hGet('spotifyconnect', 'lastvolume');
            if (!isset($lastvolume) && !strlen($lastvolume)) {
                $lastvolume = $redis->hGet('spotifyconnect', 'initial_volume');
            }
        } else {
            $lastvolume = $redis->hGet('spotifyconnect', 'initial_volume');
        }
        if (isset($lastvolume) && strlen($lastvolume)) {
            // has a integer value between 0 and 100 inclusive
            $lastvolume = min(100, intval($lastvolume));
            $lastvolume = max(0, $lastvolume);
            if ($alsaVolume) {
                $retval = sysCmd('amixer -c '.$card.' set '.$mixer.' '.$lastvolume.'% | grep -i "%] "')[0];
                $retval = get_between_data($retval, ' [', '%] ');
            } else {
                sysCmd('mpc volume '.$lastvolume);
                $retval = preg_replace('/[^0-9]/', '', sysCmd('mpc volume')[0]);
            }
        }
        if (isset($retval) && strlen($retval)) {
            // has a integer value between 0 and 100 inclusive
            $lastvolume = min(100, intval($retval));
            $lastvolume = max(0, $lastvolume);
            $status['volume'] = $lastvolume;
            $redis->hSet('spotifyconnect', 'lastvolume', $lastvolume);
            sysCmd("sed -i 's/^initial_volume = .*/initial_volume = ".'"'.$lastvolume.'"'."/' /etc/spotified.conf");
        }
        $status['currentalbumartist'] = "SpotifyConnect";
        $status['currentartist'] = "SpotifyConnect";
        $status['currentalbum'] = "-----";
        $status['currentsong'] = "Switching";
        $status['actPlayer'] = "SpotifyConnect";
        $status['radioname'] = null;
        $status['OK'] = null;
        $status['mainArtURL'] = $artUrl.'/spotify-connect.png';
        $status['smallArtURL'] = $artUrl.'/black.png';
        $status['bigArtURL'] = $artUrl.'/black.png';
        // save JSON response for extensions
        $redis->set('act_player_info', json_encode($status));
        ui_render('playback', json_encode($status));
        // echo $job['event']." ".$job['track_id']." Init\n";
        sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
        sysCmdAsync($redis, '/var/www/command/ui_update_async', 0);
        if ($job['event'] == 'stop') {
            wrk_control($redis, 'newjob', $data = array('wrkcmd' => 'stopplayer'));
            $redis->del('s_queue');
            $redis->del('s_queue_fifo');
            $updateUI = false;
        } else if ($job['event'] == 'start') {
            $updateUI = false;
        }
    }
    //
    // 'elapsed' and 'song_percent' are always unset unless explicitly set by stop, start or play events
    // unset($status['elapsed'], $status['song_percent']);
    //
    // pause event
    if ($job['event'] == 'pause') {
        $status['state'] = "pause";
        // the play event delivers the song duration (time) and the elapsed (elapsed and song_percent) information
        $status['time_last_elapsed'] = microtime(true);
        if ($job['duration_ms'] > 0) {
            $status['time'] = round($job['duration_ms'] / 1000);
            $status['elapsed'] = round($job['position_ms'] / 1000);
            $status['song_percent'] = min(100, round((100 * $job['position_ms']) / $job['duration_ms']));
        } else {
            // this should not happen
            $status['time'] = "0";
            $status['elapsed'] = "0";
            $status['song_percent'] = "0";
        }
        $updateUI = true;
    }
    //
    // change or endoftrack event
    if (($job['event'] == 'change') || ($job['event'] == 'endoftrack')) {
        if (($lastEvent == 'change') || ($lastEvent == 'endoftrack')) {
            // endoftrack and change are often sent sequentially after each other, skip the second one
            $updateUI = false;
        } else {
            $status['state'] = "stop";
            $status['elapsed'] = "0";
            $status['song_percent'] = "0";
            $status['time_last_elapsed'] = microtime(true);
            $updateUI = true;
        }
    }
    //
    // preloading or play event
    if (($job['event'] == 'preloading') || ($job['event'] == 'play')) {
        // preloading the next track of starting to play the new track
        if (($lastEvent == 'play') && ($lastTime == round($job['duration_ms']/1000)) && ($lastElapsed == round($job['position_ms']/1000))) {
            // sometimes almost duplicate play events are sent, ignore the second one
            $updateUI = false;
        } else {
            // a valid preload or play event
            $status['time_last_elapsed'] = microtime(true);
            if (!isset($spotifyInfo['track_id'])) {
                // its not in the cache, get the spotify info
                $spotifyInfo[$job['track_id']] = wrk_getSpotifyMetadata($redis, $job['track_id']);
                // when nothing is returned try to create some metadata from the jounal file
                if ($spotifyInfo[$job['track_id']]['title'] == '-') {
                    // no metadata returned
                    $spotifyInfo[$job['track_id']] = wrk_getSpotifydJournalMetadata($redis, $job['track_id']);
                }
                $cachedIDs[] = $job['track_id'];
                if ($job['event'] == 'play') {
                    // push the known data to the UI, this is an overhead because it's done again below
                    //  but it helps with the responsiveness of the UI
                    $now = microtime(true);
                    if ($job['duration_ms'] > 0) {
                        $status['time'] = round($job['duration_ms'] / 1000);
                        $status['elapsed'] = round(round($job['position_ms'] / 1000) + $now - $status['time_last_elapsed']);
                        $status['song_percent'] = min(100, round((100 * $status['elapsed']) / $status['time']));
                        $status['time_last_elapsed'] = $now;
                    } else {
                        // this should not happen
                        $status['time'] = "0";
                        $status['elapsed'] = "0";
                        $status['song_percent'] = "0";
                    }
                    $status['state'] = "play";
                    $status['currentartist'] = $spotifyInfo[$job['track_id']]['artist'];
                    $status['currentalbumartist'] = $spotifyInfo[$job['track_id']]['artist'];
                    $status['currentalbum'] = $spotifyInfo[$job['track_id']]['album'];
                    $status['currentsong'] = $spotifyInfo[$job['track_id']]['title'];
                    $status['mainArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                    $status['bigArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                    $status['smallArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                    $status['song_lyrics'] = ' ';
                    $status['artist_bio_summary'] = ' ';
                    $status['artist_similar'] = ' ';
                    // save JSON response for extensions
                    $redis->set('act_player_info', json_encode($status));
                    ui_render('playback', json_encode($status));
                    sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                }
                // now get the artist art and song information, this can take a while to retrieve
                $info = array();
                $info['artist'] = $spotifyInfo[$job['track_id']]['artist'];
                $info['albumartist'] = $spotifyInfo[$job['track_id']]['artist'];
                $info['song'] = $spotifyInfo[$job['track_id']]['title'];
                $retval = get_artistInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
                $retval = get_songInfo($redis, $info);
                if ($retval) {
                    $info = array_merge($info, $retval);
                }
                $spotifyInfo[$job['track_id']] = array_merge($spotifyInfo[$job['track_id']], $info);
                unset ($info);
            } else {
                // the track ID is cached, make sure the list of cached track ID's is in the correct order
                foreach ($cachedIDs as $key => $value) {
                    // remove the track ID from the array
                    if ($value == $job['track_id']) {
                        unset($cachedIDs[$key]);
                    }
                }
                // add the track ID again in the last position of the array (the newest)
                $cachedIDs[] = $job['track_id'];
            }
            if ($job['event'] == 'preloading') {
                // if its preloading then clean the cache and continue
                while (count($cachedIDs) > 3) {
                    // trim the first track ID (the oldest)
                    $firstCacheKey = array_key_first($cachedIDs);
                    $cachedID = $cachedIDs[$firstCacheKey];
                    unset($spotifyInfo[$cachedID], $cachedIDs[$firstCacheKey]);
                }
                // renumber the array [0] to [2]
                $cachedIDs = array_values($cachedIDs);
                $updateUI = false;
            } else {
                // the play event supplies the duration (time) and position (elapsed), the time that these were received
                //  is stored in $status['time_last_elapsed']
                $status['time'] = round($job['duration_ms'] / 1000);
                $status['elapsed'] = round($job['position_ms'] / 1000);
                // adjust the elapsed time based on the elapsed time since the last update, the time that this is recalculated
                //  is stored in $status['time_last_elapsed']
                $now = microtime(true);
                if ($status['time'] > 0) {
                    $status['elapsed'] = round($status['elapsed'] + $now - $status['time_last_elapsed']);
                    $status['song_percent'] = min(100, round((100 * $status['elapsed']) / $status['time']));
                    $status['time_last_elapsed'] = $now;
                } else {
                    // this should not happen
                    $status['time'] = "0";
                    $status['elapsed'] = "0";
                    $status['song_percent'] = "0";
                }
                $status['state'] = "play";
                // its a play event and we have all the available data
                $status['currentartist'] = trim($spotifyInfo[$job['track_id']]['artist']);
                $status['currentalbumartist'] = trim($spotifyInfo[$job['track_id']]['albumartist']);
                $status['currentalbum'] = trim($spotifyInfo[$job['track_id']]['album']);
                $status['currentsong'] = trim($spotifyInfo[$job['track_id']]['title']);
                $status['mainArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                if ($bigartIsAlbum) {
                    $status['bigArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                } else {
                    $status['smallArtURL'] = $spotifyInfo[$job['track_id']]['albumart_url'];
                }
                $status['song_lyrics'] = $spotifyInfo[$job['track_id']]['song_lyrics'];
                $status['artist_bio_summary'] = $spotifyInfo[$job['track_id']]['artist_bio_summary'];
                $status['artist_similar'] = $spotifyInfo[$job['track_id']]['artist_similar'];
                if ($artUrl == substr($spotifyInfo[$job['track_id']]['artist_arturl'], 0, strlen($artUrl))) {
                    // the artist art has not been found, so use the album art
                    $spotifyInfo[$job['track_id']]['artist_arturl'] = $status['mainArtURL'];
                }
                if ($bigartIsAlbum) {
                    $status['smallArtURL'] = $spotifyInfo[$job['track_id']]['artist_arturl'];
                } else {
                    $status['bigArtURL'] = $spotifyInfo[$job['track_id']]['artist_arturl'];
                }
                if ($status['currentartist'] == '') {
                    $status['currentartist'] = 'SpotifyConnect';
                }
                if ($status['currentalbumartist'] == '') {
                    $status['currentalbumartist'] = 'SpotifyConnect';
                }
                if ($status['currentalbum'] == '') {
                    $status['currentalbum'] = 'SpotifyConnect';
                }
                if ($status['currentsong'] == '') {
                    $status['currentsong'] = 'SpotifyConnect';
                }
                $updateUI = true;
            }
        }
    }
    //
    // volumeset event
    if (($job['event'] == 'volumeset') || ($cnt-- <= 0)) {
        // the volume is not set here, that is done by spotifyd
        // this routine only retrieves the volume level for display in the UI
        //
        // check every 10 seconds or so (= 20 cycles)
        $cnt = 20;
        $now = microtime(true);
        // the volume is retrieved from alsa using amixer when possible otherwise from MPD using in mpc
        if ($alsaVolume) {
            $retval = sysCmd('amixer -c '.$card.' get '.$mixer.' | grep -i "%] "')[0];
            $retval = get_between_data($retval, ' [', '%] ');
        } else {
            $retval = preg_replace('/[^0-9]/', '', sysCmd('mpc volume')[0]);
        }
        if (isset($retval) && strlen($retval)) {
            // has a integer value between 0 and 100 inclusive
            $lastvolume = min(100, intval($retval));
            $lastvolume = max(0, $lastvolume);
            // there is something peculiar (or a bug) in the way spotifyd sets and reports the volume
            //  this routine will correct it for alsa volume controls when max volume is set
            // if (($lastvolume > 95) && ($lastvolume != 100) && $alsaVolume) {
                // if (sysCmd('amixer -c '.$card.' get '.$mixer.' | grep -ic "[100%]"')[0]) {
                    // $lastvolume = 100;
                    // sysCmd('mpc volume '.$lastvolume);
                // }
            // }
            if ($status['volume'] != $lastvolume) {
                $status['volume'] = $lastvolume;
                // save the last set volume
                if ($save_last_volume) {
                    $redis->hSet('spotifyconnect', 'lastvolume', $lastvolume);
                    sysCmd("sed -i 's/^initial_volume = .*/initial_volume = ".'"'.$lastvolume.'"'."/' /etc/spotified.conf");
                }
                $updateUI = true;
            }
        } else {
            $lastvolume = $redis->hGet('spotifyconnect', 'lastvolume');
            if ($status['volume'] != $lastvolume) {
                $status['volume'] = $lastvolume;
                $updateUI = true;
            } else {
                $updateUI = false;
            }
        }
        // calculate the elapsed time if the UI needs updating and music is playing
        if ($updateUI && ($status['time'] != 0) && isset($status['time_last_elapsed']) && $status['time_last_elapsed'] && ($status['state'] == 'play')) {
            $status['elapsed'] = round($status['elapsed'] + $now - $status['time_last_elapsed']);
            $status['song_percent'] = min(100, round(100*$status['elapsed']/$status['time']));
            $status['time_last_elapsed'] = $now;
        } else {
            unset($status['elapsed'], $status['song_percent'], $status['time_last_elapsed']);
        }
    }
    //
    // Check that spotify connect is still running, and if it is update the UI if requested
    $active_player = $redis->get('activePlayer');
    if ($updateUI && ($active_player == 'SpotifyConnect')) {
        $updateUI = false;
        // save JSON response for extensions
        $redis->set('act_player_info', json_encode($status));
        ui_render('playback', json_encode($status));
        sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
        // sysCmdAsync($redis, '/var/www/command/ui_update_async', 0);
        if ($last_track_id != $job['track_id']) {
            // clean up the metadata cache
            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/clean_music_metadata_async.php');
            $last_track_id = $job['track_id'];
            $redis->hSet('spotifyconnect', 'last_track_id', $last_track_id);
        }
        // unload CPU: 0.5 second sleep after updating the UI
        usleep(500000);
    }
    // debug
    // echo "E:".$job['event'].", ID:".$job['track_id'].", D:".$job['duration_ms'].", P:".$job['position_ms'].", V:".$job['volume']." \n";
    runelog("[rune_SDM_wrk] E:".$job['event'].", ID:".$job['track_id'].", D:".$job['duration_ms'].", P:".$job['position_ms'].", V:".$job['volume']);
} while ($active_player == 'SpotifyConnect');
runelog('lock status ', $redis->get('lock_spotify_connect_metadata'));
// close Redis connection
$redis->close();

runelog('WORKER rune_SDM_wrk END...');
#---
#End script

