#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/rune_SY_wrk
 *  version: 1.3
 *  coder: Simone De Gregori
 *
 */
$start = microtime(true);
$savecpuRp = 12;
$savecpuMnt = 1;
$savecpuSmt = 480;
$savecpuInc = 240;
$savecpuIncPrev = $savecpuInc;
$savecpuSps = 43200;
$savecpuAvd = 16;
$savecpuFixdnssec = 20;
$savecpuRefreshNics = 24;
$savecpuRefreshNicsPrev = $savecpuRefreshNics;
$savecpuOneTimeActions = 30;
$savecpuMpdLog = 600;
$savecpuTimezone = 60;
$savecpuOpCache = 7200;
$savecpuFixLogs = 36;
$allmounted = 0;
$retriesmounting = 100;
ini_set('display_errors', '1');
error_reporting(E_ALL & ~E_NOTICE);
ini_set('error_log', '/var/log/runeaudio/rune_SY_wrk.log');
define('APP', '/srv/http/app/');

// common include
require_once(APP.'libs/runeaudio.php');
// Connect to Redis backend include
require_once(APP.'libs/openredis.php');

// setup /run dir
sysCmd('chmod 777 /run');
// clear the cache otherwise file_exists() returns incorrect values
clearstatcache(true, '/srv/http/command/update_os.php');
// if os updates are needed
if (file_exists('/srv/http/command/update_os.php')) {
    include '/srv/http/command/update_os.php';
    updateOS($redis);
}

// Set redis variable disk_error to false
$redis->set('disk_error', 0);

// clean up Rern's addons security
// Rern's addons menu
if ($redis->hGet('addons', 'addo') != '') {
    // do nothing
} else {
    // not set or is empty so delete the sudo enable-all file for user http - used for addons menu
    sysCmd('rm -f /etc/sudoers.d/http');
}

// determine the actual mpd player version
$mpdversion = sysCmd("grep -i 'Music Player Daemon' /srv/http/.config/mpdversion.txt | cut -f4 -d' ' | xargs")[0];

// read registered HW architecture
$arch_db = $redis->get('hwplatformid');
runelog('registered architecture: ', $arch_db);
$playerid_db = $redis->get('playerid');
runelog('registered playerid: ', $playerid_db);

// initialize Redis worker data tables
$redis->del('w_lock');
$redis->del('w_queue');
$redis->del('w_queue_fifo');
$redis->del('w_message');
$redis->set('waitSyWrk', 0);

// reset worker logfile
sysCmd('echo "--------------- start: rune_SY_wrk.php ---------------" > /var/log/runeaudio/rune_SY_wrk.log');
runelog('WORKER rune_SY_wrk.php STARTING...');
// INITIALIZE ENVIRONMENT --- //
runelog('INITIALIZE ENVIRONMENT ---');

// check Architecture
$arch = wrk_getHwPlatform($redis);
runelog('detected architecture: ', $arch);
if ($arch_db !== $arch) {
    runelog('architecture mismatch: registered HWID: '.$arch_db.' detected: ', $arch);
    // reset playerID if architectureID not match. This condition "fires" another first-run process
    $playerid_db = '';
}

// check git branch
$gitbranch = sysCmd('sudo -u http git --git-dir=/srv/http/.git -C /srv/http/ branch --show-current | xargs')[0];
if (isset($gitbranch) && $gitbranch) {
    runelog('GIT BRANCH: ', $gitbranch);
    $redis->hSet('git', 'branch', $gitbranch);
}

if ($playerid_db === '') {
    // RUNEAUDIO FIRST RUN PROCESS --- //
    runelog('>>>>>>RUNEAUDIO FIRST RUN PROCESS ---');
    // reset critical file permissions to default
    runelog('reset critical file permissions to default');
    wrk_sysAcl();
    // reset Redis Player Datastore
    runelog('invoke Redis player datastore reset');
    sysCmd('/srv/http/db/redis_datastore_setup reset');
    // register HW architectureID and playerID
    runelog('register HW architectureID and playerID');
    wrk_setHwPlatform($redis);
    // Set audio on off to its redis value
    wrk_audio_on_off($redis, $redis->get('audio_on_off'));
    // reset netconf to defaults
    runelog('reset netconf to defaults');
    // read system network interfaces details
    wrk_netconfig($redis,'reset');
    // reset USB mounts
    runelog('invoke USB mounts reset');
    sysCmd('/srv/http/command/usbmount');
    // reset sourcecfg to defaults
    runelog('reset sourcecfg to defaults');
    wrk_mpdconf($redis, 'stop');
    wrk_sourcecfg($redis,'reset');
    // reset Webradios
    $redis->del('webradios');
    sysCmd('rm /mnt/MPD/Webradio/*');
    // reset mpdconf to defaults
    runelog('reset mpdconf to defaults');
    wrk_mpdconf($redis, 'reset');
    // check that mpd is running
    // wrk_mpdconf($redis, 'start');
    // ashuffle gets started automatically
    // reconnect to new instance of MPD
    // clear MPD database
    //$mpd = openMpdSocket('/run/mpd/socket', 0);
    //$mpd = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
    //sendMpdCommand($mpd, 'update');
    // sysCmd('mpc update');
    // system ENV files check and replace
        // runelog("system ENV files check and replace",'');
        // wrk_sysEnvCheck($arch,1);
    // set HOSTNAME << TODO: integrate in wrk_sysEnvCheck >>
    // check that MPD only has one output enabled
    // $count = sysCmd('mpc outputs | grep -c -i enabled');
    // $countMpdEnabled = $count[0];
    // unset($count);
    // if ($countMpdEnabled != 1) {
        // sysCmd("mpc enable only 1");
    // }
    //
    // load Wi-Fi configuration, refresh nics & set up avahi
    wrk_netconfig($redis, 'boot-initialise');
    refresh_nics($redis);
    wrk_avahiconfig($redis, strtolower(trim($redis->get('hostname'))));
    //
    // disable/enable Bluetooth, bluetooth_on is set depending on the Pi model on-board Bluetooth support
    if ($redis->get('bluetooth_on')) {
        wrk_btcfg($redis, 'enable');
    } else {
        wrk_btcfg($redis, 'disable');
    }
    // setup the bluealsa config files to reflect their redis values
    wrk_btcfg($redis, 'config', json_encode($redis->hgetall('bluetooth')));
    //
    // disable/enable Wi-Fi, wifi_on is set depending on the Pi model on-board Wi-Fi support
    if ($redis->get('wifi_on')) {
        wrk_netconfig($redis, 'enableWiFi');
    } else {
        wrk_netconfig($redis, 'disableWiFi');
    }
    //
    // check and update the valid ciphers for use in the asynchronous command queue
    sysCmd('/srv/http/command/test_ciphers.php');
    //
    // enable mpd to start automatically on boot
    sysCmd('systemctl enable mpd.socket');
    // enable nginx and php-fpm to start automatically on boot
    sysCmd('systemctl enable nginx');
    sysCmd('systemctl enable php-fpm');
    sysCmd('systemctl daemon-reload');
    // copy the runeaudio cmdline.txt file which suppresses console information
    copy('/boot/cmdline.txt.runeaudio', '/boot/cmdline.txt');
    // set first time boot to true
    $redis->set('first_time_boot', 1);
    runelog('--- RUNEAUDIO FIRST RUN PROCESS END');
    // reboot - for some reason (probably connman or nginx) a connection to the UI cannot be made without a reboot
    sysCmd('/srv/http/command/rune_shutdown reboot ; shutdown now --reboot --no-wall');
    // should never get here
    // invoke rune_SY_wrk respawn
    sysCmd('systemctl restart rune_SY_wrk');
    // --- RUNEAUDIO FIRST RUN PROCESS END --- //
} else if ($redis->hGet('mpdconf', 'version') != $mpdversion) {
    // MPD VERSION HAS CHANGED PROCES--- //
    runelog('>>>>>>MPD VERSION HAS CHANGED PROCESS ---');
    // set up file protections and ownership
    wrk_sysAcl();
    // check Redis Player Datastore
    runelog('invoke Redis player datastore check');
    sysCmd('/srv/http/db/redis_datastore_setup check');
    // stop MPD and associated services
    wrk_mpdconf($redis,'stop');
    // reset mpdconf to defaults (also restarts mpd)
    runelog('reset mpdconf to defaults');
    wrk_mpdconf($redis,'reset');
    // reset sourcecfg to defaults
    runelog('reset sourcecfg to defaults');
    wrk_sourcecfg($redis,'reset');
    // check that MPD is running
    wrk_mpdconf($redis,'start');
    // ashuffle gets started automatically
    // clear MPD database
    //$mpd = openMpdSocket('/run/mpd/socket', 0);
    //$mpd = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'), 0);
    //sendMpdCommand($mpd,'update');
    sysCmd('mpc update');
    // check that MPD only has one output enabled
    $countMpdEnabled = sysCmd('mpc outputs | grep -c -i enabled')[0];
    if ($countMpdEnabled != 1) {
        sysCmd("mpc enable only 1");
    }
    runelog('--- MPD VERSION HAS CHANGED PROCESS');
    // invoke rune_SY_wrk respawn
    sysCmd('systemctl daemon-reload');
    sysCmd('systemctl restart rune_SY_wrk');
    // --- MPD VERSION HAS CHANGED PROCESS//
} else {
    runelog('--- INITIALIZE ENVIRONMENT');
    // --- INITIALIZE ENVIRONMENT //
    // NORMAL STARTUP --- //
    runelog('NORMAL STARTUP ---');
    $start2 = microtime(true);
    $firstlap = $start2-$start;
    $start3 = microtime(true);
    //
    // set the async command queue driver to a lower priority
    sysCmdAsync($redis, 'nice --adjustment=10 renice 6 $(pgrep -w cmd_async_queue)');
    //
    // create the directory structure for backup, shairport sysnc, spotifyd and PMD (this part is vital and must be run first)
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/create_work_dirs.sh');
    //
    // check and set HOSTNAME
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/sethost_async.php');
    //
    // store the memory and number of cores
    $redis->set('cores', preg_replace('/[^0-9]/', '', sysCmd('nproc')[0]));
    $redis->set('memoryKb', preg_replace('/[^0-9]/', '', sysCmd('grep -i MemTotal /proc/meminfo')[0]));
    //
    // set the Wi-Fi regulatory domain based on the current time zone
    wrk_setRegDom($redis);
    //
    // activate rune udev rules
    add_udev_rules('/srv/http/app/config/defaults/etc/udev/rules.d/99-runeaudio.rules');
    //
    // check and set the active player
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/setplayer_async.php');
    //
    // initialize OrionProfile
    $orionprofile = $redis->get('orionprofile');
    $hwplatformid = $redis->get('hwplatformid');
    runelog('env: SET KERNEL PROFILE',$orionprofile.' '.$hwplatformid);
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/orion_optimize.sh "'.$orionprofile.'" "'.$hwplatformid.'"');
    // reset usb storage (also starts samba)
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/usbmount');
    // set the mpd volume - important on the first boot, subsequently less so as MPD remembers the last volume level
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/set_mpd_volume.php');
    // check that MPD only has one output enabled and if not correct it
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/check_MPD_outputs_async.php');
    // start spotifyd (Spotify Connect)
    if ($redis->hGet('spotifyconnect', 'enable')) {
        runelog('service: SPOTIFYD start','');
        // start spotifyd if it is not already started
        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/wrk_spotifyd_async.php');
    }
    // start shairport-sync (Airplay)
    if ($redis->hGet('airplay', 'enable')) {
        runelog('service: SHAIRPORT-SYNC start','');
        // start shairport-sync if it is not already started
        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/wrk_shairport_async.php');
    }
    // check the availability of internet and services
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/internet_available_async.sh');
    // refresh nics, this will start the AP if required
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/refresh_nics');
    // refresh the bluetooth status
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/bt_status_async.php');
    // set process priority (to nice)
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
    //
    // load i2smodule
    $kernel = $redis->get('kernel');
    $loadi2s = false;
    if ($redis->get('i2smodule') !== 'none') {
        switch($arch_db) {
            case '01':
                if ($kernel !== 'linux-rune-3.6.11-18-ARCH+') $loadi2s = true;
                break;
            case '10':
                $loadi2s = true;
                break;
        }
        if ($loadi2s === true) wrk_i2smodule($redis, $redis->get('i2smodule'));
    }
    //
    // start udevil
    if ($redis->get('udevil')) {
        runelog("service: UDEVIL start",'');
        sysCmd('pgrep -x udevil || systemctl start udevil');
        // clean up any invalid mount points
        sysCmd('udevil clean');
    }
    //
    // start php-fpm if required
    sysCmd('pgrep php-fpm || systemctl start php-fpm');
    if ($redis->get('first_time_boot')) {
        // workaround for nginx needing restart with php7.x (normally it now seems to work fine without, but not the first time boot)
        sysCmd('systemctl restart nginx');
    }
    unset($retval);
    // sometimes on the armv6 image nginx fails to start automatically, if it is not running start it
    sysCmd('pgrep nginx || systemctl start nginx');
    //
    // clear the current song data on the first pass after startup
    if (is_firstTime($redis, 'clear_act_player_info')) {
        $redis->set('act_player_info', json_encode(array()));
    }
    // start rune_PL_wrk
    sysCmdAsync($redis, 'pgrep -x rune_PL_wrk || systemctl start rune_PL_wrk', 0);
    //
    // start the local browser when required
    // clear the cache otherwise file_exists() returns incorrect values
    clearstatcache(true, '/usr/bin/xinit');
    if (($redis->hGet('local_browser', 'enable')) && (file_exists('/usr/bin/xinit'))) {
        sysCmdAsync($redis, 'systemctl start local-browser ; /srv/http/command/ui_update_async 5000000');
    } else {
        sysCmdAsync($redis, 'systemctl stop local-browser');
        $redis->hSet('local_browser', 'enable', 0);
    }
    //
    // PHP OPCache
    if (!$redis->get('dev')) {
        // prime PHP OPCache
        runelog('prime PHP OPCache');
        sysCmdAsync($redis, "curl -s -X GET 'http://127.0.0.1/command/cachectl.php?action=prime'");
    }
    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
    if ($redis->get('first_time_boot')) {
        // display the first boot message
        sysCmdAsync($redis, "ply-image '/usr/share/bootsplash/runeaudio_first_time.png'", 0);
        $redis->set('first_time_boot', 0);
    }
    //
    // save the redis database to disk
    $redis->bgsave();
    // don't close redis, it has been opened with a $redis->pconnect() which reuses connections.
    // $redis->close();
    //
    $start4 = microtime(true);
    $starttime = ($start4-$start3)+$firstlap;
    runelog('WORKER rune_SY_wrk.php STARTED in '.$starttime.' seconds.');
    ui_notify($redis, 'system worker', 'rune_SY_wrk started in '.$starttime.' seconds.');
    runelog('--- NORMAL STARTUP');
    // --- NORMAL STARTUP //
}
//
runelog('WORKER MAIN LOOP ---');
//
// WORKER MAIN LOOP --- //
while (true) {
    // Connect to Redis backend
    $redis->pconnect('/run/redis/socket');
    // runelog('[wrk] loop marker ',microtime(true));
    // monitor loop
    do {
        // pop the jobID from the work fifo queue
        $jobID = $redis->rPop('w_queue_fifo');
        if (!isset($jobID) || !$jobID) {
            // queue is empty
            // in some cases an entry is added to the w_queue without adding an entry to the fifo queue
            //  this happens when w_queue entries are added in bash, so add an entry to the fifo queue for
            //  any entries in the work queue
            foreach ($redis->hGetAll('w_queue') as $jobID => $job) {
                if (isset($jobID) && $jobID) {
                    $redis->lPush('w_queue_fifo', $jobID);
                }
            }
            // when the queue is empty delete all the locks
            if (!$redis->hLen('w_queue')) {
                // it should not really happen, but if rune_SY_wrk gets stopped and restarted in the wrong place it could happen
                $redis->del('w_lock');
                $redis->set('waitSyWrk', 0);
            }
            $jobID = '';
            continue;
        }
        // read the job information from the work queue
        if ($redis->hExists('w_queue', $jobID)) {
            $job = $redis->hGet('w_queue', $jobID);
            // add a lock
            $redis->sAdd('w_lock', $jobID);
        } else {
            // no work queue entry for the fifo queue entry, this should never happen!
            //  something went wrong, just skip and get the next one
            $jobID = '';
            continue;
        }
        runelog('(loop) start job', $jobID);
        // decode redis data
        $job = json_decode($job);
        runelog('wrk_SY: ', $job->wrkcmd);
        if (isset($job->action)) {
            runelog($job->wrkcmd.' action: ', $job->action);
        } else {
            runelog($job->wrkcmd.' action: ', 'Not set');
        }
        if (isset($job->args)) {
            runelog($job->wrkcmd.'   args: ', $job->args);
        } else {
            runelog($job->wrkcmd.'   args: ', 'Not set');
        }
        switch($job->wrkcmd) {
            case 'test':
                // send notfy to UI
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, 'Test', 'text message: jobID='.$jobID);
                break;
            case 'notify_async':
                $redis->sRem('w_lock', $jobID);
                $cnt = 40;
                while ($redis->get('waitSyWrk') && ($cnt-- >= 0)) {
                    // loop sleeping for half a second until the UI is active
                    //  timeout after 20 seconds ($cnt = 40 x 0,5)
                    usleep(500000);
                    //sleep(1);
                }
                do {
                    $message = $redis->rPop('w_message');
                    // debug
                    // echo "Message : $message\n";
                    runelog('Message : '.$message);
                    if (isset($message) && $message) {
                        // sleep for 0,5 second before and between sending messages
                        usleep(500000);
                        // sleep(1);
                        ui_render('notify', base64_decode($message));
                    }
                } while (isset($message) && $message);
                unset($cnt);
                break;
            case 'airplay':
                if ($job->args !== $redis->hGet('airplay', 'name')) {
                    $redis->hSet('airplay', 'name', $job->args);
                    // update shairport startup config
                    $action = 'name updated';
                }
                if ($job->action === 'start') {
                    // start shairport-sync
                    runelog('service: SHAIRPORT start');
                    // create a directory to use for airplay metadata artwork
                    // the location /srv/http/tmp is a tmpfs, see /etc/fstab
                    // TO-DO: use the airplay redis variables to determine the metadata artwork directory
                    sysCmd('mkdir -p /srv/http/tmp/airplay');
                    sysCmd('cp /srv/http/assets/img/airplay-default.png /srv/http/tmp/airplay/airplay-default.png');
                    sysCmd('chown -R http:http /srv/http/tmp');
                    sysCmd('chmod 644 /srv/http/tmp/airplay/airplay-default.png');
                    // start or re-start shairport-sync service
                    $redis->hSet('airplay', 'enable', 1);
                    if (isset($action) && $action) {
                        $action .= ' and enabled';
                    } else {
                        $action = 'enabled';
                    }
                } elseif ($job->action === 'stop') {
                    // stop shairport-sync
                    runelog('service: SHAIRPORT stop');
                    $redis->hSet('airplay', 'enable', 0);
                    sysCmd('systemctl stop shairport-sync');
                    if (isset($action) && $action) {
                        $action .= ' and disabled';
                    } else {
                        $action = 'disabled';
                    }
                }
                $redis->sRem('w_lock', $jobID);
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/wrk_shairport_async.php');
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'AirPlay', 'AirPlay '.$action);
                }
                unset($action);
                break;
            case 'airplaytoggle':
                if ($job->action === 'start') {
                    // switch the player to airplay
                    wrk_startPlayer($redis, 'Airplay');
                    // start rune_SSM_wrk if metadata is enabled
                    if ($redis->hGet('airplay', 'metadata_enabled') == 'yes') {
                        sysCmd('systemctl restart rune_SSM_wrk');
                    }
                    // stop the MPD extra metadata job
                    sysCmd('systemctl stop rune_MPDEM_wrk');
                } elseif ($job->action === 'stop') {
                    // switch the player from airplay
                    wrk_stopPlayer($redis);
                    // stop rune_SSM_wrk
                    sysCmd('pgrep -x rune_SSM_wrk && systemctl stop rune_SSM_wrk');
                }
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/rune_prio nice');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'xorgserver':
                if ($job->action === 'zoomfactor') {
                    // zoomfactor
                    // reformat zoomfactor (characters 0 to 9 and decimal point are valid) and floatval will clean up any second decimal points
                    $zoomfactor = floatval(preg_replace("/[^0-9.]/", "", $job->args));
                    // check range of zoomfactor
                    if (($zoomfactor >= 0.1) && ($zoomfactor <= 10)) {
                        // strip any leading & trailing zero's
                        $zoomfactor = trim($zoomfactor, '0');
                        wrk_xorgconfig($redis, $job->action, $zoomfactor);
                    } else {
                        $redis->sRem('w_lock', $jobID);
                        ui_notifyError($redis, 'Local browser', 'Display zoom factor invalid: '.$job->args.' Enter a value between 0.1 and 10');
                        break;
                    }
                } else {
                    wrk_xorgconfig($redis, $job->action, $job->args);
                }
                $redis->sRem('w_lock', $jobID);
                break;
            case 'backup':
                $redis->hSet('w_msg', $jobID, wrk_backup($redis));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'delbackup':
                $fileName = trim($job->args);
                if (substr($fileName, 0, 6) === '/home/') {
                    // only allow deleting files in the directory '/home/'
                    sysCmd('rm -f '."'".$fileName."'");
                }
                $redis->sRem('w_lock', $jobID);
                break;
             case 'restore':
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, 'Working', 'It takes some time....');
                wrk_restore($redis, $job->args);
                // a reboot will take place after a successful restore, if it comes back here something has gone wrong
                $redis->sRem('w_lock', $jobID);
                break;
            case 'clearimg':
                // Clean IMG
                runelog('Clean IMG');
                $redis->sRem('w_lock', $jobID);
                // send notfy to UI
                ui_notify($redis, 'Clean IMG', 'Started, this can take a while to complete');
                // enable OPcache
                wrk_opcache($redis, 'enable');
                wrk_cleanDistro();
                break;
            case 'debug':
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/debug_collector');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'debug-refresh':
                // this just waits for the debug collector to complete then allows the UI to refresh
                // the debug collector takes between 3 and 15 seconds to run
                if ($redis->get('lock_debug_collector')) {
                    $cnt = 10;
                    while ($redis->get('lock_debug_collector') && ($cnt-- > 0)) {
                        sleep(2);
                    }
                    if ($cnt <= 0) {
                        // this should not happen, run the debug collector again when we get here
                        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/debug_collector');
                    }
                } else {
                    // debug collector had already finished, run it again for the next time
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/debug_collector');
                }
                $redis->sRem('w_lock', $jobID);
                unset($cnt);
                break;
            case 'dlna':
                sysCmd('systemctl stop upmpdcli');
                if (($job->args->name !== $redis->hGet('dlna', 'name')) OR ($job->args->queueowner !== $redis->hGet('dlna', 'queueowner'))) {
                    $redis->hSet('dlna', 'name', $job->args->name);
                    $redis->hSet('dlna', 'queueowner', $job->args->queueowner);
                    // update upmpdcli startup config
                    wrk_upmpdcli($redis, $redis->hGet('dlna', 'name'), $redis->hGet('dlna', 'queueowner'));
                    $action = 'updated';
                }
                // start upmpdcli
                if ($job->action === 'start') {
                    runelog('service: UPMPDCLI start');
                    // start or re-start upmpdcli service
                    sysCmd('systemctl start upmpdcli');
                    $redis->hSet('dlna', 'enable', 1);
                    if (isset($action) && $action) {
                        $action .= ' and enabled';
                    } else {
                        $action = 'enabled';
                    }
                }
                // stop upmpdcli
                if ($job->action === 'stop') {
                    runelog('service: UPMPDCLI stop');
                    $redis->hSet('dlna', 'enable', 0);
                    sysCmd('systemctl stop upmpdcli');
                    if (isset($action) && $action) {
                        $action .= ' and disabled';
                    } else {
                        $action = 'disabled';
                    }
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'UPnP / DLNA', 'UPnP / DLNA '.$action);
                }
                unset($action);
                break;
            case 'gitpull':
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, 'Git pull', ' Starting, please wait...' );
                // Update RuneUI
                runelog('Update RuneUI');
                // stop the player if running
                if (strpos(' '.strtolower(implode("<br>", sysCmd('mpc'))), '[playing]')) {
                    $player_stopped = true;
                    sysCmd('mpc pause');
                    ui_notify($redis, 'Update RuneUI', 'Pausing play, please wait...');
                } else {
                    $player_stopped = false;
                }
                // run the git_pull script
                $retval = sysCmd('/srv/http/command/git_pull.sh');
                $retval = implode("<br>", $retval);
                if (strpos(' '.strtolower($retval),'already up to date')) {
                    $gitupdated = false;
                } else {
                    $gitupdated = true;
                }
                if ($gitupdated) {
                    ui_notify($redis, 'Git pull', $retval);
                    ui_notify($redis, 'Update RuneUI', 'Updated, preparing reboot, please wait...');
                    wrk_sysAcl();
                    sysCmd('/srv/http/db/redis_datastore_setup check');
                    wrk_playernamemenu($redis->get('playernamemenu'));
                    $redis->set('dev', 0);
                    sysCmd('systemctl daemon-reload');
                    // sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
                    ui_notify($redis, 'Update RuneUI', 'Rebooting');
                    wrk_control($redis, 'newjob', $data = array('wrkcmd' => 'reboot'));
                } else {
                    if ($player_stopped) {
                        ui_notify($redis, 'Update RuneUI', "Finished.<br>No changes, already up to date.<br>Restarting play");
                        sysCmd('mpc play');
                    } else {
                        ui_notify($redis, 'Update RuneUI', 'Finished.<br>No changes, already up to date');
                    }
                    ui_notify($redis, 'Update RuneUI', "Don't forget to switch 'dev mode' off");
                }
                unset($retval, $gitupdated, $player_stopped);
                break;
            case 'hostname':
                $redis->sRem('w_lock', $jobID);
                sleep(2);
                ui_notify($redis, 'Settings - Change Hostname', 'It takes some time, please wait...');
                ui_notify($redis, 'Settings - Change Hostname', 'You will need to connect to the player with the new name! http://'.trim($job->args).'.local', '', 1);
                wrk_changeHostname($redis, $job->args);
                $hn = trim(sysCmd('hostname | xargs')[0]);
                if (strtolower($hn) === strtolower(trim($job->args))){
                    $redis->set('hostname', trim($job->args));
                } else {
                    $redis->set('hostname', $hn);
                }
                unset($retval);
                // update hash
                $hash = md5_file('/etc/mpd.conf');
                $redis->set('mpdconfhash', $hash);
                // send notfy to UI
                ui_notify($redis, 'Hostname', 'Hostname changed to:'.$hn);
                break;
            case 'i2smodule':
                if (isset($job->args) && trim($job->args)) {
                    wrk_i2smodule($redis, trim($job->args));
                    // check that MPD only has one output enabled and if not correct it
                    $redis->sRem('w_lock', $jobID);
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/check_MPD_outputs_async.php');
                    // send notification
                    ui_notify($redis, 'I&#178;S kernel module', 'Completed, set to '.$job->args);
                }
                break;
            case 'audio_on_off':
                wrk_audio_on_off($redis, $job->args);
                // check that MPD only has one output enabled and if not correct it
                $redis->sRem('w_lock', $jobID);
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/check_MPD_outputs_async.php');
                // send notification
                if ($job->args) {
                    $action = 'Enabled';
                } else {
                    $action = 'Disabled';
                }
                ui_notify($redis, 'HDMI & 3,5mm jack', $action);
                unset($action);
                break;
            case 'kernelswitch':
                $redis->sRem('w_lock', $jobID);
                runelog('env: SWITCH KERNEL', $job->args);
                if (wrk_kernelswitch($redis, $job->args)) {
                    if ($job->args === 'linux-rune-rpi_3.12.13-rt21_wosa') {
                        $redis->set('ao', 'snd_rpi_wsp_1');
                        $redis->set('i2smodule', 'none');
                        $redis->set('orionprofile', 'OrionV2');
                    }
                    ui_notify($redis, 'Linux Kernel switch', 'Completed, rebooting now...');
                    wrk_control($redis, 'newjob', $data = array('wrkcmd' => 'reboot'));
                } else {
                    ui_notify($redis, 'Linux Kernel switch', 'Failed');
                }
                break;
            case 'lastfm':
                if ($job->action === 'start') {
                    if ($job->args->user != $redis->hGet('lastfm', 'user') OR $job->args->pass != $redis->hGet('lastfm', 'pass')) {
                    // mpdscribble.conf
                    $file = '/etc/mpdscribble.conf';
                    $newArray = wrk_replaceTextLine($file, '', 'username =', 'username = '.$job->args->user, 'last.fm', 2);
                    $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$job->args->pass, 'last.fm', 3);
                    // Commit changes to /etc/mpdscribble.conf
                    $fp = fopen($file, 'w');
                    fwrite($fp, implode("", $newArray));
                    fclose($fp);
                    unset($newArray);
                    // write LastFM auth data to Redis datastore
                    setLastFMauth($redis, $job->args);
                    }
                    // check if spotify is configured
                    if ($redis->hGet('spotify','enable') === '1') {
                        // spopd.conf
                        $file = '/etc/spop/spopd.conf';
                        $newArray = wrk_replaceTextLine($file, '', 'username =', 'username = '.$redis->hGet('lastfm','user'), 'api_endpoint', 1);
                        $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$redis->hGet('lastfm','pass'), 'api_endpoint', 2);
                        $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', 'plugins = scrobble', '### System settings ###', 2);
                        // commit changes to /etc/spop/spopd.conf
                        $fp = fopen($file, 'w');
                        fwrite($fp, implode("", $newArray));
                        fclose($fp);
                        unset($newArray);
                        if ($redis->get('activePlayer') === 'Spotify') {
                            sysCmd('systemctl reload-or-restart spopd || systemctl start spopd');
                        }
                    }
                    sysCmd('systemctl stop mpdscribble');
                    runelog('service: MPDSCRIBBLE start');
                    sysCmd('systemctl start mpdscribble');
                    $redis->hSet('lastfm', 'enable', 1);
                    $action = 'enabled';
                }
                if ($job->action === 'stop') {
                    sysCmd('systemctl stop mpdscribble');
                    // check if spotify is configured
                    if ($redis->hGet('spotify','enable') === '1') {
                        // spopd.conf
                        $file = '/etc/spop/spopd.conf';
                        $newArray = wrk_replaceTextLine($file, '', 'plugins =', '#plugins = scrobble', '### System settings ###', 2);
                        // commit changes to /etc/spop/spopd.conf
                        $fp = fopen($file, 'w');
                        fwrite($fp, implode("", $newArray));
                        fclose($fp);
                        unset($newArray);
                        sysCmd('systemctl reload-or-restart spopd');
                    }
                    $redis->hSet('lastfm', 'enable', 0);
                    $action = 'disabled';
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'Last.FM scrobbling', 'mpdscribble '.$action);
                }
                unset($file, $newArray, $fp, $action);
                break;
            case 'mpdcfg':
                // send notfy to UI
                ui_notify($redis, 'MPD', 'Configuration update started, please wait, it can take a while...');
                if ($job->action === 'update') {
                    wrk_mpdconf($redis, 'update', $job->args, $jobID);
                    wrk_mpdconf($redis, 'restart');
                } else if ($job->action === 'reset') {
                    wrk_mpdconf($redis, 'reset', '', $jobID);
                    wrk_mpdconf($redis, 'restart');
                } else if ($job->action === 'switchao') {
                    wrk_mpdconf($redis, 'switchao', $job->args, $jobID);
                }
                $redis->sRem('w_lock', $jobID);
                // send notfy to UI
                ui_notify($redis, 'MPD', 'Configuration update completed');
                break;
            case 'mpdcfgman':
                $redis->sRem('w_lock', $jobID);
                // send notfy to UI
                ui_notify($redis, 'MPD', 'Configuration update started, please wait, it can take a while...');
                // write mpd.conf file
                $fh = fopen('/etc/mpd.conf', 'w');
                fwrite($fh, $job->args);
                fclose($fh);
                // set redis indicator showing mpd.conf has changed
                $redis->set('mpdconfchange', 1);
                // restart MPD daemon
                wrk_mpdconf($redis, 'restart');
                // send notfy to UI
                ui_notify($redis, 'MPD', 'Configuration update completed');
                unset($fh);
                break;
            case 'mpdrestart':
                wrk_mpdconf($redis, 'restart');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'forcempdrestart':
                wrk_mpdconf($redis, 'forcerestart');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'pl_rem_dup':
                // $job>args contains the playlist name
                // run the job async with a lower priority
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/remove_playlist_duplicates.sh '."'".$job->args."'");
                ui_notify($redis, 'Remove duplicates started for playlist:', $job->args);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'pl_rem_invalid':
                // $job>args contains the playlist name
                // run the job async with a lower priority
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/remove_playlist_invalid.sh '."'".$job->args."'");
                ui_notify($redis, 'Remove invalid entries started for playlist:', $job->args);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'ashufflecheckCF':
                wrk_ashuffle($redis, 'checkcrossfade');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'ashufflereset':
                wrk_ashuffle($redis, 'reset');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'pl_ashuffle':
                // $job>args contains the playlist name
                wrk_ashuffle($redis, 'set', $job->args);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'addrandomtracks':
                // save the number of files to add
                $redis->hSet('globalrandom', 'addrandom', $job->args);
                // call ashuffle to add the specified number of tracks to the queue
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, 'Add random tracks', implode("\n", sysCmd('ashuffle -o '.$job->args)));
                break;
            case 'airplaymetadata':
                if ($job->action === 'start') {
                    if ($redis->hGet('airplay', 'metadataonoff')) {
                        sysCmd('pgrep -x rune_SSM_wrk || systemctl start rune_SSM_wrk');
                    }
                    // stop the MPD extra metadata job
                    sysCmd('systemctl stop rune_MPDEM_wrk');
                } else if ($job->action === 'stop') {
                    sysCmd('pgrep -x rune_SSM_wrk && systemctl stop rune_SSM_wrk');
                }
                $redis->sRem('w_lock', $jobID);
                break;
            case 'spotifyconnectmetadata':
                if ($job->action === 'start') {
                    if ($redis->hGet('spotifyconnect', 'metadata_enabled')) {
                        sysCmd('pgrep -x rune_SDM_wrk || systemctl start rune_SDM_wrk');
                    }
                    // stop the MPD extra metadata job
                    sysCmd('systemctl stop rune_MPDEM_wrk');
                } else if ($job->action === 'stop') {
                    sysCmd('pgrep -x rune_SDM_wrk && systemctl stop rune_SDM_wrk');
                    $redis->del('s_queue');
                    $redis->del('s_queue_fifo');
                }
                $redis->sRem('w_lock', $jobID);
                break;
            case 'sambaonoff':
                if (isset($job->action) && $job->action) {
                    $redis->hSet('samba', 'enable', '1');
                    $action = 'Enabled';
                    if (isset($job->args) && $job->args) {
                        $redis->hSet('samba', 'readwrite', '1');
                        $action .= ' - Read/Write';
                    } else {
                        $redis->hSet('samba', 'readwrite', '0');
                        $action .= ' - Read only';
                    }
                } else {
                    $redis->hSet('samba', 'enable', '0');
                    // switch read/write off when disabled
                    $redis->hSet('samba', 'readwrite', '0');
                    $action = 'Disabled';
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    ui_notify($redis, 'SAMBA', $action);
                }
                if ($redis->get('dev')) {
                    ui_notify($redis, 'SAMBA', 'Dev mode is active, settings override: Enabled - Read/Write');
                }
                wrk_restartSamba($redis);
                unset($action);
                break;
            case 'sambarestart':
                $redis->sRem('w_lock', $jobID);
                if ($redis->get('dev')) {
                    ui_notify($redis, 'SAMBA', 'Dev mode is active, settings override: Enabled - Read/Write');
                }
                wrk_restartSamba($redis);
                break;
            case 'rerninstall':
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, "Install Rern's Addons", 'It takes some time .....');
                sysCmd('systemctl stop addons cronie');
                sysCmd('systemctl disable addons cronie');
                sysCmd('rm -f /etc/systemd/system/addons.service');
                sysCmd('rm -f /etc/sudoers.d/http');
                sysCmd('rm -f /etc/sudoers.d/http-backup');
                sysCmd('rm -fr /home/rern');
                sysCmd('mkdir -m=777 -p /home/rern');
                sysCmd('/usr/local/bin/uninstall_addo.sh');
                sysCmd('rm -f ./install.sh');
                sysCmd('rm -f /usr/local/bin/uninstall_addo.sh');
                sysCmd('rm -f /usr/local/bin/uninstall_enha.sh');
                $redis->del('addons');
                $redis->del('addo');
                sysCmd('wget -vN --no-check-certificate https://github.com/rern/RuneAudio_Addons/raw/master/install.sh --output-file=/home/rern/Rern_Addons.log');
                sysCmd('chmod +x -v ./install.sh  >> /home/rern/Rern_Addons.log');
                sysCmd('./install.sh >> /home/rern/Rern_Addons.log');
                sysCmd('sed -i "s,\x1B\[[0-9;]*[a-zA-Z],,g" /home/rern/Rern_Addons.log');
                $retval = sysCmd('grep -hi -E "installed|please" /home/rern/Rern_Addons.log');
                ui_notify($redis, "Rern's Addons", trim(preg_replace('/[^A-Za-z0-9 ]/', '', implode('\n', $retval))));
                sleep(3);
                ui_notify($redis, "Rern's Addons", 'You may need to reboot...');
                sleep(3);
                unset($retval);
                $redis->hSet('addons', 'update', '0');
                $redis->hSet('addons', 'font', '20170901');
                sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'rernremove':
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, "Remove Rern's Addons", 'It takes some time .....');
                sysCmd('systemctl stop addons cronie');
                sysCmd('systemctl disable addons cronie');
                sysCmd('rm -f /etc/systemd/system/addons.service');
                sysCmd('rm -f /etc/sudoers.d/http');
                sysCmd('rm -f /etc/sudoers.d/http-backup');
                sysCmd('rm -fr /home/rern');
                sysCmd('/usr/local/bin/uninstall_addo.sh');
                sysCmd('rm -f ./install.sh');
                sysCmd('rm -f /usr/local/bin/uninstall_addo.sh');
                sysCmd('rm -f /usr/local/bin/uninstall_enha.sh');
                $redis->del('addons');
                $redis->del('addo');
                ui_notify($redis, "Remove Rern's Addons", 'You may need to reboot...');
                sleep(3);
                $redis->hSet('addons', 'update', '0');
                $redis->hSet('addons', 'font', '20170901');
                sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'extendpartition':
                $retval = sysCmd("echo -e 'd\n2\nn\np\n2\n\n\nt\n2\n83\np\nw' | fdisk /dev/mmcblk0 | grep -i mmcblk0p2");
                sysCmd('partprobe /dev/mmcblk0');
                sysCmd('resize2fs /dev/mmcblk0p2');
                $redis->sRem('w_lock', $jobID);
                ui_notify($redis, "Extend Linux Partition", implode("\n", $retval));
                unset($retval);
                break;
            case 'airplayconfreset':
                sysCmd('cp /srv/http/app/config/defaults//etc/systemd/system/shairport-sync.service /etc/systemd/system/shairport-sync.service');
                sysCmd('cp /srv/http/app/config/defaults//etc/shairport-sync.conf /etc/shairport-sync.conf');
                wrk_sysAcl();
                sysCmd('systemctl daemon-reload');
                $airplay_name = $redis->hGet('airplay', 'name');
                $airplay_enable = $redis->hGet('airplay', 'enable');
                $redis->del('airplay');
                sysCmd('/srv/http/db/redis_datastore_setup check');
                $redis->hSet('airplay', 'name', $airplay_name);
                $redis->hSet('airplay', 'enable', $airplay_enable);
                wrk_getHwPlatform($redis);
                wrk_shairport($redis, $redis->get('ao'), $airplay_name);
                $redis->sRem('w_lock', $jobID);
                unset($airplay_name, $airplay_enable);
                break;
            case 'sambaconfreset':
                // stop samba
                sysCmd('systemctl stop smb nmb winbind');
                sysCmd('systemctl disable smb nmb winbind');
                // reset the config files
                sysCmd('rm -f /etc/samba/*.conf');
                sysCmd('cp /srv/http/app/config/defaults//etc/samba/smb-dev.conf /etc/samba/smb-dev.conf');
                sysCmd('cp /srv/http/app/config/defaults//etc/samba/smb-prod.conf /etc/samba/smb-prod.conf');
                sysCmd('ln -s /etc/samba/smb-prod.conf /etc/samba/smb.conf');
                sysCmd('find /etc/samba -name "*.conf" -exec chmod 644 {} \;');
                // reset the redis varables for samba (set to OFF and Read-Only)
                $redis->del('samba');
                sysCmd('/srv/http/db/redis_datastore_setup check');
                // remove any samba usernames and passwords
                sysCmd('pdbedit -L | grep -o ^[^:]* | smbpasswd -x');
                // restart samba if required (e.g. when in dev mode)
                wrk_restartSamba($redis);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'soxrmpd':
                $redis->set('soxrmpdonoff', $job->action);
                wrk_mpdconf($redis, 'refresh');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'soxrairplay':
                $redis->hSet('airplay', 'soxronoff', $job->action);
                wrk_shairport($redis, $redis->get('ao'));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'metadataairplay':
                $redis->hSet('airplay', 'metadataonoff', $job->action);
                wrk_shairport($redis, $redis->get('ao'));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'artworkairplay':
                $redis->hSet('airplay', 'artworkonoff', $job->action);
                wrk_shairport($redis, $redis->get('ao'));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'airplayoutputformat':
                $redis->hSet('airplay', 'alsa_output_format', $job->args);
                wrk_shairport($redis, $redis->get('ao'));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'airplayoutputrate':
                $redis->hSet('airplay', 'alsa_output_rate', $job->args);
                wrk_shairport($redis, $redis->get('ao'));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'playernamemenu':
                wrk_playernamemenu($job->action);
                $redis->set('playernamemenu', $job->action);
                sysCmd('systemctl restart php-fpm || systemctl start php-fpm');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'netcfg':
                // valid netcfg $job->action values:
                //  boot-initialise, refresh, refreshAsync, saveWifi, enableWifi, disableWifi, saveEthernet,
                //  reconnect, connect, autoconnect-on, autoconnect-off, disconnect, disconnect-delete,
                //  delete & reset
                if (isset($job->args)) {
                    foreach ($job->args as $key => $value) {
                        // convert the sudo-object to a normal array
                        $param[$key] = $value;
                    }
                    wrk_netconfig($redis, $job->action, '', $param);
                } else {
                    wrk_netconfig($redis, $job->action);
                }
                $redis->sRem('w_lock', $jobID);
                unset($key, $value, $param);
                break;
            case 'apcfg':
                if (isset($job->args)) {
                    foreach ($job->args as $key => $value) {
                        // convert the sudo-object to a normal array
                        $param[$key] = $value;
                    }
                }
                if ($job->action === 'reset') {
                    // reset accesspoint configuration to default settings
                    $retval = wrk_apconfig($redis, 'reset', $param);
                    if ($retval === 'reboot') {
                        $action = 'reset, reboot requested';
                    } else {
                        $action = 'reset, a reboot is required to activate the settings';
                    }
                } else if ($job->action === 'config') {
                    // write accesspoint configuration
                    $retval = wrk_apconfig($redis, 'writecfg', $param);
                    if ($retval === 'reboot') {
                        $action = 'changed, reboot requested';
                    } else {
                        $action = 'changed, a reboot is required to activate the settings';
                    }
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    ui_notify($redis, 'AccessPoint', 'Configuration '.$action);
                }
                // check if reboot is needed !!!
                if ($retval === 'reboot') {
                    wrk_control($redis, 'newjob', $data = array('wrkcmd' => 'reboot'));
                }
                unset($key, $value, $param, $retval, $action);
                break;
            case 'btcfg':
                // $job->action is always set, $job->args can also contain information
                if (isset($job->args)) {
                    wrk_btcfg($redis, $job->action, $job->args);
                } else {
                    wrk_btcfg($redis, $job->action);
                }
                $redis->sRem('w_lock', $jobID);
                break;
            case 'ntpserver':
                $redis->set('ntpserver', wrk_NTPsync($job->args));
                $redis->sRem('w_lock', $jobID);
                break;
            case 'opcache':
                // Restart PHP service
                if ($job->action === 'enable') {
                    wrk_opcache($redis, 'enable');
                    runelog('PHP 5.5 OPcache enabled');
                    // restart php-fpm after waiting 5 seconds
                    sysCmdAsync($redis, 'systemctl reload-or-restart php-fpm || systemctl start php-fpm', 5);
                    // wrk_opcache($redis, 'forceprime');
                    $action = 'enabled';
                } else {
                    wrk_opcache($redis, 'disable');
                    runelog('PHP 5.5 OPcache disabled');
                    // restart php-fpm after waiting 5 seconds
                    sysCmdAsync($redis, 'systemctl reload-or-restart php-fpm || systemctl start php-fpm', 5);
                    $action = 'disabled';
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'PHP OpCache', 'Cache '.$action);
                }
                unset($action);
                break;
            case 'orionprofile':
                $hwplatformid = $redis->get('hwplatformid');
                $profile = $job->args." ".$hwplatformid;
                runelog("env: SET KERNEL PROFILE", $profile);
                $redis->set('orionprofile', $job->args);
                $redis->sRem('w_lock', $jobID);
                sysCmd("/srv/http/command/orion_optimize.sh ".$profile);
                ui_notify($redis, 'SoundSignature', 'Profile '.$profile.' applied');
                break;
            case 'phprestart':
                sysCmd('systemctl reload-or-restart php-fpm || systemctl start php-fpm');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'poweroff':
                // save the playback status
                wrk_mpdPlaybackStatus($redis);
                $redis->sRem('w_lock', $jobID);
                // $redis->save();
                // send notfy to UI
                ui_notify($redis, 'Shutdown', 'system shutdown in progress...');
                // $redis->set('shutdownmode', 'poweroff');
                // sysCmd('/srv/http/command/rune_shutdown poweroff');
                // sysCmd('redis-cli shutdown save ; shutdown now --poweroff --no-wall');
                sysCmd('/srv/http/command/rune_shutdown "poweroff" ; shutdown now --poweroff --no-wall');
                break;
            case 'reboot':
                // save the playback status
                wrk_mpdPlaybackStatus($redis);
                $redis->sRem('w_lock', $jobID);
                // $redis->save();
                // send notfy to UI
                ui_notify($redis, 'Reboot', 'system reboot in progress...');
                // $redis->set('shutdownmode', 'reboot');
                // sysCmd('/srv/http/command/rune_shutdown reboot');
                // sysCmd('redis-cli shutdown save ; shutdown now --reboot --no-wall');
                sysCmd('/srv/http/command/rune_shutdown "reboot" ; shutdown now --reboot --no-wall');
                break;
            case 'display_off':
                sysCmd('systemctl stop local-browser');
                sysCmd('export DISPLAY=:0; xset dpms force off');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'security':
                if (!isset($job->args)) {
                    // no password given
                    $job->args = '';
                }
                wrk_security($redis, $job->action, $job->args);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'spotify':
                if ($job->action === 'start') {
                    if ($job->args->user !== $redis->hGet('spotify', 'user') OR $job->args->pass !== $redis->hGet('spotify', 'pass')) {
                    // spopd.conf
                    $file = '/etc/spop/spopd.conf';
                    $newArray = wrk_replaceTextLine($file, '', 'spotify_username =', 'spotify_username = '.$job->args->user, '### Spotify auth settings ###', 2);
                    $newArray = wrk_replaceTextLine('', $newArray, 'spotify_password =', 'spotify_password = '.$job->args->pass, '### Spotify auth settings ###', 3);
                    // check if last.fm is configured
                    if ($redis->hGet('lastfm','enable') === '1') {
                        $newArray = wrk_replaceTextLine('', $newArray, 'username =', 'username = '.$redis->hGet('lastfm','user'), 'api_endpoint', 1);
                        $newArray = wrk_replaceTextLine('', $newArray, 'password =', 'password = '.$redis->hGet('lastfm','pass'), 'api_endpoint', 2);
                        $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', 'plugins = scrobble', '### System settings ###', 2);
                    } else {
                        $newArray = wrk_replaceTextLine('', $newArray, 'username =', '#username = user', 'api_endpoint', 1);
                        $newArray = wrk_replaceTextLine('', $newArray, 'password =', '#password = pass', 'api_endpoint', 2);
                        $newArray = wrk_replaceTextLine('', $newArray, 'plugins =', '#plugins = scrobble', '### System settings ###', 2);
                    }
                    // commit changes to /etc/spop/spopd.conf
                    $fp = fopen($file, 'w');
                    fwrite($fp, implode("", $newArray));
                    fclose($fp);
                    unset($newArray);
                    // write Spotify auth data to Redis datastore
                    $redis->hSet('spotify', 'user', $job->args->user);
                    $redis->hSet('spotify', 'pass', $job->args->pass);
                    }
                    if ($redis->get('activePlayer') === 'Spotify') {
                        sysCmd('systemctl stop spopd');
                        runelog('service: SPOPD start');
                        sysCmd('systemctl start spopd');
                    }
                    $redis->hSet('spotify', 'enable',  1);
                    $action = 'enabled';
                } else if ($job->action === 'stop') {
                    runelog('service: SPOPD stop');
                    sysCmd('systemctl stop spopd');
                    $redis->hSet('spotify', 'enable',  0);
                    $action = 'disabled';
                }
                $redis->sRem('w_lock', $jobID);
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'Spotify', 'Spotify client '.$action);
                }
                unset($file, $newArray, $fp, $action);
                break;
            case 'spotifyconnect':
                if ($job->action === 'start') {
                    // clear the spotify connect last track ID
                    $redis->hSet('spotifyconnect', 'last_track_id', '');
                    // make sure that avahi allows other stacks
                    if (sysCmd("grep -ic '^[[:space:]]*disallow-other-stacks[[:space:]]*=[[:space:]]*yes' /etc/avahi/avahi-daemon.conf")[0] > 0) {
                        sysCmd("sed -i '/^[[:space:]]*disallow-other-stacks/c\disallow-other-stacks=no' /etc/avahi/avahi-daemon.conf");
                        sysCmd('systemctl restart avahi-daemon');
                    }
                    unset($spotifyConnectCache);
                }
                // write Spotify Connect data to Redis datastore
                isset($job->args->autoplay) && $redis->hSet('spotifyconnect', 'autoplay', $job->args->autoplay);
                isset($job->args->bitrate) && $redis->hSet('spotifyconnect', 'bitrate', $job->args->bitrate);
                isset($job->args->device_name) && $redis->hSet('spotifyconnect', 'device_name', $job->args->device_name);
                isset($job->args->enable) && $redis->hSet('spotifyconnect', 'enable', $job->args->enable);
                isset($job->args->metadata_enabled) && $redis->hSet('spotifyconnect', 'metadata_enabled', $job->args->metadata_enabled);
                isset($job->args->normalisation_pregain) && $redis->hSet('spotifyconnect', 'normalisation_pregain', $job->args->normalisation_pregain);
                isset($job->args->password) && $redis->hSet('spotifyconnect', 'password', $job->args->password);
                isset($job->args->save_last_volume) && $redis->hSet('spotifyconnect', 'save_last_volume', $job->args->save_last_volume);
                isset($job->args->timeout) && $redis->hSet('spotifyconnect', 'timeout', $job->args->timeout);
                isset($job->args->username) && $redis->hSet('spotifyconnect', 'username', $job->args->username);
                isset($job->args->volume_normalisation) && $redis->hSet('spotifyconnect', 'volume_normalisation', $job->args->volume_normalisation);
                // stop and/or start spotifyd
                if ($job->action === 'start') {
                    runelog('service: SPOTIFYD start');
                    $redis->hSet('spotifyconnect', 'enable',  1);
                    $action = 'enabled';
                } elseif ($job->action === 'stop') {
                    runelog('service: SPOTIFYD stop');
                    $redis->hSet('spotifyconnect', 'enable',  0);
                    $action = 'disabled';
                } else {
                    $action = 'configured';
                }
                $redis->sRem('w_lock', $jobID);
                if ($redis->get('activePlayer') === 'SpotifyConnect') {
                    wrk_stopPlayer($redis);
                }
                sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/wrk_spotifyd_async.php');
                if (isset($action) && $action) {
                    // send notfy to UI
                    ui_notify($redis, 'Spotify Connect', 'Spotify Connect client '.$action);
                }
                unset($action);
                break;
            case 'artworkSC':
                $redis->hSet('spotifyconnect', 'metadata_enabled', $job->action);
                $redis->sRem('w_lock', $jobID);
                wrk_spotifyd($redis);
                break;
            case 'sourcecfg':
                if (wrk_sourcecfg($redis, $job->action, $job->args)) sysCmd('mpc update');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'switchplayer':
                $redis->sRem('w_lock', $jobID);
                if (wrk_startPlayer($redis, $job->args)) {
                    ui_notify($redis, 'Switch Player Engine', 'Current active player engine: '.$job->args);
                }
                break;
            case 'stopplayer':
                $redis->sRem('w_lock', $jobID);
                if (wrk_stopPlayer($redis)) {
                    ui_notify($redis, 'Switch Player Engine', 'Current active player engine: '.$redis->get('activePlayer'));
                }
                break;
            case 'sysAcl':
                $redis->sRem('w_lock', $jobID);
                wrk_sysAcl();
                break;
            case 'timezone':
                $redis->sRem('w_lock', $jobID);
                if (wrk_setTimezone($redis, $job->args)) {
                    ui_notify($redis, 'Timezone', 'Timezone updated.<br>Current timezone: '.$job->args);
                } else {
                    ui_notifyError($redis, 'Error', 'Timezone update failed.<br>Timezone unchanged');
                }
                break;
            case 'udevil':
                $redis->sRem('w_lock', $jobID);
                if ($job->action === 'start') {
                    runelog('service: UDEVIL start');
                    sysCmd('systemctl enable udevil ; systemctl start udevil');
                    $redis->set('udevil', 1);
                    ui_notify($redis, 'USB-Auto', 'USB-Automount enabled');
                }
                if ($job->action === 'stop') {
                    runelog('service: UDEVIL stop');
                    sysCmd('systemctl disable udevil ; systemctl stop udevil');
                    $redis->set('udevil', 0);
                    ui_notify($redis, 'USB-Auto', 'USB-Automount disabled');
                }
                break;
            case 'webradio':
                $redis->sRem('w_lock', $jobID);
                $mpd = openMpdSocket($redis->hGet('mpdconf', 'bind_to_address'));
                if ($job->action === 'add') {
                    if (addRadio($redis, $mpd, $job->args)) {
                        ui_notify($redis, 'Webradio', $job->args->label.' added to the library');
                    }
                } else if ($job->action === 'edit') {
                    if (editRadio($redis, $mpd, $job->args)) {
                        ui_notify($redis, 'Webradio', $job->args->label.' modified succesfully');
                    }
                } else if ($job->action === 'delete') {
                    if (deleteRadio($redis, $mpd, $job->args)) {
                        ui_notify($redis, 'Webradio', $job->args->label.' deleted');
                    }
                } else if ($job->action === 'rebuild') {
                    sysCmd('/srv/http/command/webradiodb.sh');
                    ui_notify($redis, 'Webradio', 'Library rebuilt');
                }
                ui_libraryHome($redis);
                closeMpdSocket($mpd);
                unset($mpd);
                break;
            case 'wrkrestart':
                // restart worker
                sysCmd('systemctl reload-or-restart '.$job->args);
                $redis->sRem('w_lock', $jobID);
                break;
            // case 'ui_notify':
                // $redis->sRem('w_lock', $jobID);
                // // TODO: rework needed (fix bug in /srv/http/index.php)
                // if (!isset($job->delay_us)) {
                    // $job->delay_us = 1000000;
                // }
                // runelog('delay_us '.$job->delay_us);
                // usleep($job->delay_us);
                // // send notify to RuneUI
                // foreach ($job->args as $raw_notification) {
                     //wrk_notify($redis, 'raw', $raw_notification);
                // }
                // break;
            case 'underclocking':
                if ($job->action === 1) {
                    $redis->set('underclocking', 1);
                } else {
                    $redis->set('underclocking', 0);
                }
                $redis->sRem('w_lock', $jobID);
                if ($job->action === 1) {
                    // switch underclocking on
                    if (sysCmd('grep -hi "Underclocking placeholder" /boot/config.txt')[0]) {
                        if (!sysCmd('grep -hi "Underclocking start" /boot/config.txt')[0]) {
                            sysCmd("sed -i -e '/Underclocking placeholder/r /boot/Archimago_underclocking.txt' /boot/config.txt");
                        }
                        ui_notify($redis, 'Underclocking', 'Enabled');
                    } else {
                        ui_notifyError($redis, 'Failed', 'An image reset is required');
                    }
                } else {
                    // switch underclocking off
                    sysCmd("sed -i '/Underclocking start/,/Underclocking end/d' /boot/config.txt");
                    $redis->set('underclocking', 0);
                    ui_notify($redis, 'Underclocking', 'Disabled');
                }
                break;
            case 'kill_weston':
                sysCmd('pkill -15 weston');
                // ui_notify($redis, 'Kill weston', '');
                $redis->sRem('w_lock', $jobID);
                break;
            case 'replaygain':
                $redis->sRem('w_lock', $jobID);
                if ($job->action === 'addRGtagsFlac') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/add_replaygain_flac_to_local.sh silent continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Add ReplayGain tags for Flac files", 'Job started');
                } else if ($job->action === 'updateRGtagsFlac') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/add_replaygain_flac_to_local.sh silent skip continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Update ReplayGain tags for Flac files", 'Job started');
                } else if ($job->action === 'delRGtagsFlac') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/remove_replaygain_flac_from_local.sh silent continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Remove ReplayGain tags from Flac files", 'Job started');
                } else if ($job->action === 'addRGtagsAll') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/add_replaygain_all_to_local.sh silent continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Add ReplayGain tags for Flac files", 'Job started');
                } else if ($job->action === 'updateRGtagsAll') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/add_replaygain_all_to_local.sh silent skip continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Update ReplayGain tags for Flac files", 'Job started');
                } else if ($job->action === 'delRGtagsAll') {
                    sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/remove_replaygain_all_from_local.sh silent continue > /dev/null 2>&1', 0);
                    ui_notify($redis, "Remove ReplayGain tags from Flac files", 'Job started');
                }
                break;
            case 'ui_render':
                // when $job->action is set to 'seconds', $job->args contains a timestamp in seconds which is the requested start time
                if (($job->action = 'seconds') && is_numeric($job->args)) {
                    $delaySeconds = round($job->args - microtime(true));
                    if ($delaySeconds < 0 ) {
                        $delaySeconds = 0;
                    }
                } else {
                    $delaySeconds = 0;
                }
                sysCmdAsync($redis, '/srv/http/command/ui_update_async '.$delaySeconds);
                unset($delaySeconds);
                $redis->sRem('w_lock', $jobID);
                break;
            case 'llmnrd':
                wrk_llmnrd($redis);
                $redis->sRem('w_lock', $jobID);
                break;
        } // end switch
        // delete processed job from the w_queue
        $redis->hDel('w_queue', $jobID);
        $redis->sRem('w_lock', $jobID);
        // emit endjob notification
        //wrk_notify($redis, 'endjob', '', $jobID);
        runelog('(loop) delete job_queue', $jobID);
    } while ($jobID != ""); // end while loop
    //
    // extra tasks to be carried out based on a timer
    //
    // mount all sources
    if ((!$allmounted) && is_firstTime($redis, 'mount_all_shares')) {
        runelog('wrk_SY: try to mount all shares! - First time');
        // first time, so call directly
        // parameters: wrk_sourcemount($redis, $action, $id = null, $quiet = false, $quick = false)
        $allmounted = wrk_sourcemount($redis, 'mountall', null, true, true);
        $redis->set('allmounted', $allmounted);
        if ($allmounted) {
            runelog('wrk_SY: all shares mounted successfully!');
            // start play if enabled
            if ($redis->get('mpd_autoplay')) {
                $redis->set('mpd_playback_laststate', 'playing');
                wrk_mpdRestorePlayerStatus($redis);
            }
        }
        // this routine will not detect disconnected/unmounted shares which had previously been mounted
        // $retriesmounting sets the number of times mounting is to be retried, 100 @ 4 times per hour = +/-25 hours
        // you can change the number of retries here
        $retriesmounting = 100;
    }
    // If mounting is unsuccessful retry mounting the first time on the 1st cycle, then every +/-1800th cycle (= every +/-15 minutes), first time it is set to zero
    if ($savecpuMnt-- <= 0) {
        $allmounted = $redis->get('allmounted');
        if (!$allmounted) {
            if ($retriesmounting-- >= 0) {
                runelog('wrk_SY: error mounting shares, trying it again! Count: '.$retriesmounting);
                // run asynchronous mount script
                sysCmdAsync($redis, 'nice --adjustment=10 php -f /srv/http/command/mount_async.php');
            }
            $savecpuMnt = 1750 + rand(0, 100);
        }
    }
    // Run refresh_nics periodically, run it first after 24 cycles (+/-12 seconds), and increase the repeat cycle time by 100%
    //  it should run at least once per hour
    //  connman works (should work) in this exponential way of detecting WiFi networks and nics
    if ($savecpuRefreshNics-- <= 0) {
        wrk_netconfig($redis, 'refreshAsync');
        // increase the repeat cycle time by 100% with a maximum of 7200 (= 1 hour, 60 x 60 x 2)
        $savecpuRefreshNics = min(7200, intval($savecpuRefreshNicsPrev*2));
        // calculate the randomiser @5% of the repeat cycle, minimum value of 2, maximum value of 100
        $random = min(100,max(2, intval($savecpuRefreshNics/20)));
        $savecpuRefreshNics = $savecpuRefreshNics - $random + rand(0, $random*2);
        $savecpuRefreshNicsPrev = $savecpuRefreshNics;
        unset($random);
    }
    // One time actions, run first after 30 cycles (+/-15 seconds), then only on every +/-16th cycle (= every +/-8 seconds) until everything is done when it repeats after 10,000,000 cycles (58 days)
    // Several one time actions are managed here, they are run one at a time, one on each cycle
    if ($savecpuOneTimeActions-- <= 0) {
        if (is_firstTime($redis, 'clear_starting_splash') && $redis->hGet('local_browser', 'enable-splash') && !$redis->hGet('local_browser', 'enable')) {
            // clear the screen if splash screens are on and local browser is off
            sysCmd('/usr/bin/ply-image /srv/http/tmp/art/black.png');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'wifi_boot_initialise')) {
            // run boot-initialise for Wi-Fi networks
            wrk_netconfig($redis, 'boot-initialise');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'reset_linux_root_password')) {
            // when requested required set up the Linux root password so that its modification will be prompted in the UI
            wrk_security($redis, 'reset_linux_root_password');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'check_linux_root_password') && !wrk_security($redis, 'check_linux_root_password')) {
            // prompt the UI to change the Linux root password
            $data['id'] = 'modal-security_linux_password';
            ui_render('modal', json_encode($data));
            unset($data);
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'webradio_boot_import') && sysCmd('find /boot/webradios -name "*.pls" | wc -l | xargs')[0]) {
            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/webradiodb.sh');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'redis_datastore_setup_check')) {
            // check that the redis database is up to date
            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/db/redis_datastore_setup check');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'debug_collector')) {
            // run debug collector to initialise the datafile for today
            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/debug_collector');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'changewindow')) {
            // change the window for ahuffle, this helps improve the randomisation
            wrk_ashuffle($redis, 'changewindow');
            // the access point test below needs more time, so delay by +/-2 minutes (=120 seconds, = 240 cycles)
            $savecpuOneTimeActions = 230 + rand(0, 20);
        } else if (wrk_security($redis, 'check_linux_root_password') && !wrk_security($redis, 'check_access_point_password') && is_firstTime($redis, 'check_access_point_password')) {
            // prompt the UI to change the Access Point password, only when linux password has been changed
            $data['id'] = 'modal-security_ap_password';
            ui_render('modal', json_encode($data));
            unset($data);
            // the access point test below needs more time, so delay by +/-15 minutes (= 900 seconds, = 1800 cycles)
            $savecpuOneTimeActions = 1750 + rand(0, 100);
        } else if (is_firstTime($redis, 'check_access_point_password') && !wrk_security($redis, 'check_access_point_password')) {
            // prompt the UI to change the Access Point password, regardless of status of linux password
            $data['id'] = 'modal-security_ap_password';
            ui_render('modal', json_encode($data));
            unset($data);
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else if (is_firstTime($redis, 'ssh_keygen')) {
            // regenerate any missing ssh keys
            sysCmdAsync($redis, 'nice --adjustment=10 ssh-keygen -A');
            $savecpuOneTimeActions = 11 + rand(0, 10);
        } else {
            $savecpuOneTimeActions = 10000000;
        }
    }
    // Random play auto start and stop, run first after 12 cycles (+/-6 seconds), then only on every +/-30th cycle (= every +/-15 seconds)
    // Detect deletion of playlist random file and restart if applicable
    // Start Global Random if enabled - check continually, ashuffle get stopped for lots of reasons, this is the only place where it is started
    if ($savecpuRp-- <= 0) {
        wrk_ashuffle($redis, 'check');
        $savecpuRp = 25 + rand(0, 10);
    }
    // logfile fix, run first after 36 cycles (+/-18 seconds), then repeat on every +/-7200 cycles (+/-1 hour)
    //  make all the log file RW and delete any with a zero size
    if ($savecpuFixLogs-- <= 0) {
        wrk_fixlogs();
        $savecpuFixLogs = 7100 + rand(0, 200);
    }
    // MPD logfile size check, run first after 600 cycles (+/-5 minutes), then repeat on every +/-1200 cycles (+/-10 minutes)
    //  if the mpd log is greater than the parameter value (bytes) a new log will be created and the old one deleted
    //  the only reason a log file gets too big is when a very large music library is updated or rebuilt (it then tends to grow quite quickly)
    //  or when rune runs for days on end without reboot
    //  200000 bytes is enough for about 1500 normal log entries (@ 3mins per song = 3+ days playing time)
    if ($savecpuMpdLog-- <= 0) {
        wrk_mpdLog($redis, $redis->get('mpd_max_logsize'));
        $savecpuMpdLog = 1150 + rand(0, 100);
    }
    // Test to see if an internet connection is available. Disable the artistinfo, lyrics webradios, etc. functions when no internet is available
    // This will resolve freezing problems due to services being unavailable
    // Run refresh_nics periodically, run it first after 240 cycles (+/-2 minutes), and increase the repeat cycle time by 100% (= x2)
    //  it should run at least once each 15 minutes, it is also run once early in the start-up sequence
    if ($savecpuInc-- <= 0) {
        // run the tests and disable/enable the artistinfo & lyrics asynchronously
        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/internet_available_async.sh');
        // increase the repeat cycle time by 100% with a maximum of 1800 (= 15 mins, 15 x 60 x 2)
        $savecpuInc = min(1800, intval($savecpuIncPrev*2));
        // calculate the randomiser @5% of the repeat cycle, minimum value of 2, maximum value of 100
        $random = min(100,max(2, intval($savecpuInc/20)));
        $savecpuInc = $savecpuInc - $random + rand(0, $random*2);
        $savecpuIncPrev = $savecpuInc;
        unset($random);
    }
    // Automatically determine the time-zone
    // Test first after 60 cycles (+/-30 seconds)
    //  then after success every +/-57600 cycles (= every +/-8 hours)
    //  or after failure every +/-240 cycles (= every +/-2 minutes)
    if ($savecpuTimezone-- <= 0) {
        // run the routine, it is here (and not in the start-up routines) because internet needs to be up and be detected
        // it will only change the time-zone when it is set to the initial default value and internet is available
        // it normally does nothing
        $retval = autoset_timezone($redis);
        if ($retval) {
            // success, set to retry in +/-8 hours
            $savecpuTimezone = 57400 + rand(0, 400);
        } else {
            // failed, retry after +/-2 minutes
            $savecpuTimezone = 220 + rand(0, 40);
        }
        unset($retval);
    }
    // S.M.A.R.T. monitoring tools
    //  will test each attached hard disk and tape unit
    //  test only when music is playing
    //  first test after 480 cycles (= +/- 4 minutes) and then at a maximum rate of once per +/-2400 cycles (= +/-20 minutes)
    //  when a disk error is detected reduce the test every +/-180 cycles (= +/-1.5 minutes)
    // Why test only when something is playing?
    //  a) someone needs see the error messages and
    //  b) most hard disks will be usb drives which go to sleep when not in use, let them sleep
    if ($savecpuSmt-- <= 0) {
        if (is_playing($redis)) {
            // something is playing
            // clear the cache otherwise file_exists() returns incorrect values
            clearstatcache(true, '/usr/bin/smartctl');
            if (file_exists('/usr/bin/smartctl')) {
                // monitoring tools software is installed
                // scan for hard disks
                $drive_list = sysCmd('smartctl --scan-open -- -H -i -s on | grep -v aborted');
                if (isset($drive_list) && !empty($drive_list)) {
                    foreach($drive_list as $drive) {
                        // for each connected drive
                        $drive = trim($drive);
                        if ($drive != "") {
                            $command = "smartctl ".$drive." | grep -i -E 'Model:|Capacity:|-health self-|SMART support is'";
                            $self_check = sysCmd($command);
                            // the self_check variable now has 5 lines the 1st line must contain the word 'Available' - 'SMART support is: Available...'
                            If (!empty($self_check)) {
                                $smart_avalable = false;
                                $smart_enabled = false;
                                $smart_result = false;
                                $smart_good = false;
                                foreach ($self_check as $self_check_line) {
                                    $self_check_line = trim($self_check_line);
                                    if ($self_check_line != "") {
                                        // now looking for the lines
                                        // 'SMART support is: Available...' and
                                        // 'SMART support is: Enabled'
                                        if (strpos(' '.$self_check_line, 'SMART support is')) {
                                            if (strpos(' '.$self_check_line, 'Available')) {
                                                $smart_avalable = true;
                                            } else if (strpos(' '.$self_check_line, 'Enabled')) {
                                                $smart_enabled = true;
                                            }
                                        }
                                        // now looking for the line containing something like this:
                                        // 'SMART overall-health self-assessment test result: PASSED'
                                        // actually looking for '-health self-' together with 'OK' or 'PASSED'
                                        if (strpos(' '.$self_check_line, '-health self-')) {
                                            // there is a result
                                            $smart_result = true;
                                            if (strpos(' '.$self_check_line, 'OK')) {
                                                $smart_good = true;
                                            } else if (strpos(' '.$self_check_line, 'PASSED')) {
                                                $smart_good = true;
                                            }
                                        }
                                    }
                                }
                                if ($smart_avalable && $smart_enabled && $smart_result && !$smart_good) {
                                    // SMART is available, enabled, there is a result and it is not good
                                    // display the information
                                    ui_notifyError($redis, 'Disk errors - Action required', implode("\n", $self_check));
                                    // set the disk_error flag to true
                                    $redis->set('disk_error', 1);
                                }
                            }
                        }
                        unset($self_check);
                        unset($command);
                    }
                    unset($drive);
                    unset($drive_list);
                }
            }
        }
        unset($retval);
        if ($redis->get('disk_error')) {
            // set the disk check frequency to +/-180 cycles (= +/-1.5 minutes)
            $savecpuSmt = 170 + rand(0, 20);
        } else {
            // set the disk check frequency to +/-2400 cycles (= +/20 minutes)
            $savecpuSmt = 2350 + rand(0, 100);
        }
    }
    // Restart shairport-sync every 6 hours, but only when it is inactive
    // There is an unresolved problem with shairport-sync which stops broadcasting its name after a number of hours
    // It will normally run correctly for at least 24 hours
    // Restart every +/-43200 cycles (= every +/-6 hours)
    if ($savecpuSps-- <= 0) {
        $savecpuSps = 43100 + rand(0, 200);
        // see which player is active
        if ($redis->get('activePlayer') === 'Airplay') {
            // Airplay is active so try again in after +/-7200 cycles (= +/-1 hour)
            $savecpuSps = 7100 + rand(0, 200);
        } else {
            // Airplay is not running so stop and restart it
            sysCmd('systemctl stop shairport-sync');
            sysCmd('systemctl daemon-reload');
            sysCmd('systemctl start shairport-sync');
        }
    }
    // Restart avahi-daemon initially after 8 seconds and thereafter every 1,5 hours
    // There is an unresolved problem with avahi which stops broadcasting the player name after a number of hours
    //  It looks like it is related to renewing the DHCP lease on the router
    // A second problem is that avahi-daemon uses the file '/etc/resolv.conf' which is a symlink pointing to '/run/connman/resolv.conf'
    //  The file '/run/connman/resolv.conf' is created by connman when it starts, so avahi-daemon should wait until connman has started
    //  However this would delay publishing the zeroconfig runeaudio name. It seems to publish the zeroconfig runeaudio name regardless
    //  of the error about a missing '/etc/resolv.conf'.
    // Reload or restart initially after (+/-8 seconds) then every +/-10800 cycles (+/-1,5 hours)
    if ($savecpuAvd-- <= 0) {
        $savecpuAvd = 10700 + rand(0, 200);
        // restart avahi-daemon
        sysCmdAsync($redis, 'nice --adjustment=10 systemctl restart avahi-daemon');
    }
    // Check opcache every 1 hour (every 7200 cycles)
    // This will add memory to the opcache if required
    if ($savecpuOpCache-- <= 0) {
        $savecpuOpCache = 7100 + rand(0, 200);
        // run the script async
        sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/check_opcache_async.php');
    }
    // Check DNSSEC initially after 20 cycles (+/-10 seconds), then every +/-1800 cycles (= every +/-15 minutes)
    // There is an unresolved problem with systemd resolve in combination with systemd timesync. Systemd resolve
    //  will not resolve URL's with DNSSEC switched on when time has not been syncronised. This causes systemd timesync
    //  to fail becuse the timeserver URL's can not be resolved. This effectivly locks both timesync and resolve out.
    if ($savecpuFixdnssec-- <= 0) {
        $savecpuFixdnssec = 1750 + rand(0, 100);
        if (!sysCmd('systemctl is-active systemd-resolved.service | grep -ic inactive')[0]) {
            // not inactive - systemd-resolved.service is running
            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/dnssec_fix.sh');
        }
    }
    // Check the usb_db_autorebuild_retry variable, when set update the MPD USB library
    if ($redis->get('usb_db_autorebuild_retry')) {
        sysCmd('mpc update USB');
        // unset the variable
        $redis->set('usb_db_autorebuild_retry', 0);
    }
    // unload CPU: 0.5 second sleep
    usleep(500000);
} // end while loop
// --- WORKER MAIN LOOP //
// close Redis connection
$redis->close();
