#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2018 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2018 - janui
 *
 * RuneOS
 * copyright (C) 2018
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *--------------------------------------------------------------------------------------------------------
 * This Airplay section of code includes a heavily modified version of the code used in Moode Audio Player
 * for shairport-sync metadata decoding, see: https://github.com/moode-player/moode
 *
 * Shairport-sync meta data engine
 * Copyright (C) 2016 Andreas Goetz <cpuidle@gmx.de>
 *
 * 2016-06-07 TC 2.6 integrated into Moode Audio Player
 * 2016-08-28 2.7 TC
 * 2018-04-29 janui integrated into RuneAudio
 *--------------------------------------------------------------------------------------------------------
 *
 *  file: command/rune_SSM_wrk
 *  version: 1.5
 *  coder: janui
 *
 */
// common include
ini_set('display_errors', '1');
ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/rune_SSM_wrk.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
error_reporting(E_ALL & ~E_NOTICE);

// decode 'any' strings
function decode($str) {
    $res = "";
    $i = 0;
    while ($i+2 <= strlen($str)) {
        $res .= chr(hexdec(substr($str, $i, 2)));
        $i += 2;
    }
    return $res;
}
// reset worker logfile
sysCmd('echo "--------------- start: rune_SSM_wrk ---------------" > /var/log/runeaudio/rune_SSM_wrk.log');
runelog('WORKER rune_SSM_wrk START');
// reset state
$airplay_handle = FALSE;
$mode = 'any';
// get the album art directory and url dir
$artDir = rtrim(trim($redis->get('albumart_image_dir')), '/');
$artUrl = trim($redis->get('albumart_image_url_dir'), " \n\r\t\v\0/");
if ($redis->hget('airplay', 'metadata_include_cover_art') == 'yes') {
    $metadataIncludeCoverArt = true;
} else {
    $metadataIncludeCoverArt = false;
}
if ($redis->get('remoteSSbigart') === 'album') {
    $albumBig = true;
} else {
    $albumBig = false;
}
$airplayMetadataPipeName =  $redis->hGet('airplay', 'metadata_pipe_name');
$activePlayer = $redis->get('activePlayer');
// get the actual playback information
$sampleRate = trim($redis->hGet('airplay', 'alsa_output_rate'));
$sampleRateK = round($sampleRate / 1000, 1);
if (strlen($sampleRateK) > 4) {
    $sampleRateK = round($sampleRate / 1000, 0);
}
$sampleDepth = preg_replace('/[^0-9]/', '', $redis->hGet('airplay', 'alsa_output_format'));
// initialise the status array
$status = array();
// Example: "44100:16:2";
$status['audio'] = $sampleRate.":".$sampleDepth.":2";
// Example: "44.1";
$status['audio_sample_rate'] = $sampleRateK;
// Example: "16";
$status['audio_sample_depth'] = $sampleDepth;
$status['bitrate'] = "1411";
$status['audio_channels'] = "Stereo";
$status['random'] = "0";
$status['single'] = "0";
$status['consume'] = "0";
$status['playlist'] = "1";
$status['playlistlength'] = "1";
$status['state'] = "play";
$status['time'] = "0";
$status['elapsed'] = "0";
$status['song_percent'] = "0";
$status['currentalbumartist'] = "Airplay";
$status['currentartist'] = "Airplay";
$status['currentalbum'] = "-----";
$status['currentsong'] = "Switching";
$status['actPlayer'] = "Airplay";
$status['radioname'] = null;
$status['OK'] = null;
$status['song_lyrics'] = ' ';
$status['artist_bio_summary'] = ' ';
$status['artist_similar'] = ' ';
$status['mainArtURL'] = $artUrl.'/airplay.png';
$status['smallArtURL'] = $artUrl.'/black.png';
$status['bigArtURL'] = $artUrl.'/black.png';
$status['time_last_elapsed'] = microtime(true);
$status['local_volume_control'] = 0;
// save JSON response for extensions
$redis->set('act_player_info', json_encode($status));
ui_render('playback', json_encode($status));
sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
// --- WORKER MAIN LOOP --- //
while (true) {
    if ($activePlayer !== "Airplay") {
        sleep(3);
    } else {
        do {
            // Open the FiFo metadata file if closed
            if (!$airplay_handle) {
                runelog('rune_SSM_wrk: Open Airplay metadata file: ', $airplayMetadataPipeName);
                $airplay_handle = fopen($airplayMetadataPipeName, 'r');
                if ($airplay_handle) {
                    runelog('rune_SSM_wrk: Airplay metadata file opened: ', $airplayMetadataPipeName);
                    // set stream set blocking to true, fgets will now wait for data
                    stream_set_blocking($airplay_handle, TRUE);
                    sleep(1);
                } else {
                    runelog('rune_SSM_wrk: Airplay metadata file open failed: ', $airplayMetadataPipeName);
                    $airplay_handle = FALSE;
                    sleep(2);
                    break;
                }
            } else {
                runelog('rune_SSM_wrk: Airplay metadata file is already open: ', $airplayMetadataPipeName);
            }
            // read the metadata file
            // fgets() will wait for data
            $airplay_meta_line = fgets($airplay_handle);
            if (!$airplay_meta_line) {
                // there is an error
                // close the metadata file, wait, then loop
                runelog('rune_SSM_wrk: Airplay metadata file read fail, closing the metadata file');
                // maybe shairport-sync has crashed, close the metadata file
                fclose($airplay_handle);
                $airplay_handle = FALSE;
                sleep(2);
                break;
            }
            // decode the metadata
            if ($mode == 'any') {
                if (preg_match('#<item><type>(\w+)</type><code>(\w+)</code><length>(\d+)</length>#', $airplay_meta_line, $matches)) {
                    $type = decode($matches[1]);
                    $code = decode($matches[2]);
                    $buf = '';
                    $length = $matches[3];
                }
                else if (preg_match('#<data encoding="base64">#', $airplay_meta_line)) {
                    $mode = 'data';
                }
            } else if ($mode == 'data') {
                if (preg_match('#^(.*)</data>#', $airplay_meta_line, $matches)) {
                    $buf .= $matches[1];
                    $buf = base64_decode($buf);
                    $mode = 'any';
                }
                else {
                    $data .= $airplay_meta_line;
                }
            }
            if ($redis->get('volume') && !isset($status['volume'])) {
                if (!empty($redis->get('lastmpdvolume'))) {
                    $status['volume'] = $redis->get('lastmpdvolume');
                    $redis->set('act_player_info', json_encode($status));
                }
            }
            if (preg_match('#</item>#', $airplay_meta_line)) {
                // this bit of code detects that the elapsed time greater than the track time (track has therefore finished playing)
                //  it sets the counters to zero and the state to stop, which caused the ui to stop the countdown and display zero's
                //  this is a cosmetic tweak which makes the UI behave as expected, it is required because we do not know the order in which
                //  the information from Airplay is received and therefore cannot make it dependant on receiving a specific metadata item
                $now = microtime(true);
                if (!isset($status['time']) || !$status['time'] || ((($status['elapsed'] + $now - $status['time_last_elapsed']) >= $status['time']))) {
                    // song not yet started or has finished, stop the countdown
                    $status['time'] = 0;
                    $status['elapsed'] = 0;
                    $status['song_percent'] = 0;
                    $status['state'] = 'stop';
                    $status['time_last_elapsed'] = $now;
                    $redis->set('act_player_info', json_encode($status));
                    ui_render('playback', json_encode($status));
                } else {
                    // otherwise, make sure the countdown is running
                    $status['state'] = 'play';
                }
                // metadata is identified by two decoded values: the type and the code depending on the
                // values of the decoded values various actions will take place for specific metadata records
                $tag = $type.' '.$code;
                runelog('rune_SSM_wrk: Airplay tag: ', $tag);
                // debug, set $debugMetadata to true to debug of false
                $debugMetadata = true;
                if ($debugMetadata) {
                    if (($type != 'core') && ($code === 'phbt')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core phbt' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'phb0')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core phb0' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'ofps')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core ofps' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'ofmt')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core ofmt' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'styp')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core styp' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'svna')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core svna' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'ascp')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core ascp' should be '$type $code'\n";
                    } else if (($type != 'xesam') && ($code === 'composer')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'xesam composer' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asdk')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asdk' should be '$type $code'\n";
                    } else if (($type != 'sps') && ($code === 'songdatakind')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'sps songdatakind' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'caps')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core caps' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'astn')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core astn' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'astc')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core astc' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asdn')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asdn' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asdc')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asdc' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asar')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asar' should be '$type $code'\n";
                    } else if (($type != 'xesam') && ($code === 'albumArtist')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'xesam albumArtist' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'astm')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core astm' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asal')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asal' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'minm')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core minm' should be '$type $code'\n";
                    } else if (($type != 'core') && ($code === 'asgn')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'core asgn' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'stal')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc stal' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'mdst')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc mdst' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'mden')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc mden' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'prsm')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc prsm' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'clip')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc clip' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'svip')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc svip' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'snua')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc snua' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'acre')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc acre' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'daid')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc daid' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'dapo')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc dapo' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pend')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pend' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'flsr')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc flsr' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pfls')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pfls' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pbeg')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pbeg' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pcst')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pcst' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pcen')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pcen' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'snam')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc snam' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'pvol')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc pvol' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'prgr')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc prgr' should be '$type $code'\n";
                    } else if (($type != 'ssnc') && ($code === 'PICT')) {
                        echo "rune_SSM_wrk: Incorrect metadata coding, 'ssnc PICT' should be '$type $code'\n";
                    }
                }
                switch ($tag) {
                    case 'ssnc pffr':
                    case 'core ascr':
                        // unknown
                        runelog("rune_SSM_wrk: Unknown '".$type." ".$code."' ", $buf);
                        break;
                    case 'core phbt':
                        // FramePosition
                        // FramePosition/FirstFramePosition metadata is generated only if the progress_interval in the metadata section
                        //  of the configuration file is non-zero. The progress interval can also be set by a new
                        //  SetFramePositionUpdateInterval method in the D-Bus interface.
                        // FramePosition/FirstFramePosition metadata is of the form <RTP Frame number>/<Local Time> where the local time,
                        //  in nanoseconds (a 64-bit number), is the precise time that frame should be played. The metadata is generated
                        //  when the frame is placed in the output buffer, and is thus generated audio_backend_buffer_desired_length_in_seconds
                        //  (usually 0.2 seconds) before the time in question.
                        // $redis->hSet('airplay','Frame_Position', trim($buf));
                        runelog('rune_SSM_wrk: FramePosition: ', $buf);
                        break;
                    case 'core phb0':
                        // FirstFramePosition
                        // FramePosition/FirstFramePosition metadata is generated only if the progress_interval in the metadata section
                        //  of the configuration file is non-zero. The progress interval can also be set by a new
                        //  SetFramePositionUpdateInterval method in the D-Bus interface.
                        // FramePosition/FirstFramePosition metadata is of the form <RTP Frame number>/<Local Time> where the local time,
                        //  in nanoseconds (a 64-bit number), is the precise time that frame should be played. The metadata is generated
                        //  when the frame is placed in the output buffer, and is thus generated audio_backend_buffer_desired_length_in_seconds
                        //  (usually 0.2 seconds) before the time in question.
                        // $redis->hSet('airplay','First_Frame_Position', trim($buf));
                        runelog('rune_SSM_wrk: FirstFramePosition: ', $buf);
                        break;
                    case 'core ofps':
                        // OutputRate
                        $redis->hSet('airplay','Output_Rate', trim($buf));
                        runelog('rune_SSM_wrk: Airplay OutputRate: ', $buf);
                        break;
                    case 'core ofmt':
                        // OutputFormat
                        $redis->hSet('airplay','Output_Format', trim($buf));
                        runelog('rune_SSM_wrk: Airplay OutputFormat: ', $buf);
                        break;
                    case 'core styp':
                        // StreamType
                        $redis->hSet('airplay','Stream_Type', trim($buf));
                        runelog('rune_SSM_wrk: Airplay StreamType: ', $buf);
                        break;
                    case 'core svna':
                        // ServiceName
                        $redis->hSet('airplay','ServiceName', trim($buf));
                        runelog('rune_SSM_wrk: Airplay ServiceName: ', $buf);
                        break;
                    case 'core mper':
                        // persistent ID
                        $redis->hSet('airplay','persistent_ID', trim($buf));
                        runelog('rune_SSM_wrk: Airplay persistent ID: ', $buf);
                        break;
                    case 'core ascp':
                    case 'xesam composer':
                        // composer
                        $status['currentcomposer'] = empty($buf) ? 'Unknown' : trim($buf);
                        runelog('rune_SSM_wrk: Airplay composer: ', $buf);
                        break;
                    case 'core asdk':
                    case 'sps songdatakind':
                        // song data kind
                        // derived from the asdk metadata token, to the metadata bundle presented in the D-Bus interface. If 0 it seems to
                        //  indicate an item of a specific duration such as an audio track; if 1 it seems to mean the stream is of unknown
                        //  duration, for example an internet radio stream.
                        $songDataKind = intval(trim($buf));
                        $redis->hSet('airplay','song_data_kind', $songDataKind);
                        if ($songDataKind) {
                            $status['radioname'] = 'Airplay Radio';
                        } else {
                            unset($status['radioname']);
                        }
                        runelog('rune_SSM_wrk: Airplay song data kind: ', $buf);
                        break;
                    case 'core caps':
                        // ?caps?
                        runelog('rune_SSM_wrk: Airplay ?caps?: ', $buf);
                        break;
                    case 'core astn':
                        // song track number
                        runelog('rune_SSM_wrk: Airplay song track number: ', $buf);
                        break;
                    case 'core astc':
                        // song track count
                        runelog('rune_SSM_wrk: Airplay song track count: ', $buf);
                        break;
                    case 'core asdn':
                        // song track disk number
                        runelog('rune_SSM_wrk: Airplay song track disc number: ', $buf);
                        break;
                    case 'core asdc':
                        // song track disk count
                        runelog('rune_SSM_wrk: Airplay song track disc count: ', $buf);
                        break;
                    case 'core asar':
                    case 'xesam albumArtist':
                        // artist
                        $status['currentalbumartist'] = empty($buf) ? 'Unknown' : trim($buf);
                        $status['currentartist'] = $status['currentalbumartist'];
                        runelog('rune_SSM_wrk: Currentartist: ', $status['currentartist']);
                        break;
                    case 'core astm':
                        // song time in milliseconds - only use it if it is set to a positive value, also see 'ssnc prgr' progress
                        $timeMiliseconds = intval($buf);
                        if ($timeMiliseconds > 0) {
                            $status['time'] = round($timeMiliseconds / 1000);
                        }
                        unset($timeMiliseconds);
                        runelog('rune_SSM_wrk: Song time $buf: ', $buf);
                        break;
                    case 'core asal':
                        // album
                        $status['currentalbum'] = empty($buf) ? 'Unknown' : trim($buf);
                        runelog('rune_SSM_wrk: Currentalbum: ', $status['currentalbum']);
                        break;
                    case 'core minm':
                        // song
                        $status['currentsong'] = empty($buf) ? 'Unknown' : trim($buf);
                        runelog('rune_SSM_wrk: Currentsong: ', $status['currentsong']);
                        break;
                    case 'core asgn':
                        // genre
                        $status['genre'] = empty($buf) ? 'Unknown' : trim($buf);
                        runelog('rune_SSM_wrk: Genre: ', $status['genre']);
                        break;
                    case 'ssnc stal':
                        // Pipe stalled, no arguments
                        runelog('rune_SSM_wrk: Pipe stalled, no arguments - closing the metadata file');
                        // close the pipe, wait and loop
                        fclose($airplay_handle);
                        $airplay_handle = FALSE;
                        sleep(2);
                        break;
                    case 'ssnc mdst':
                        // metadata start
                        runelog('rune_SSM_wrk: Metadata start: ', $buf);
                        $status['song_lyrics'] = ' ';
                        $status['artist_bio_summary'] = ' ';
                        $status['artist_similar'] = ' ';
                        $render = $status;
                        unset($render['elapsed'], $render['song_percent']);
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($render));
                        break;
                    case 'ssnc mden':
                        // metadata end
                        runelog('rune_SSM_wrk: Metadata end: ', $buf);
                        //
                        // now get the artist art and song information (also done after album art - see below)
                        $info = array();
                        $info['artist'] = $status['currentartist'];
                        $info['albumartist'] = $status['currentalbumartist'];
                        $info['song'] = $status['currentsong'];
                        $retval = get_artistInfo($redis, $info);
                        if ($retval) {
                            $info = array_merge($info, $retval);
                        }
                        $retval = get_songInfo($redis, $info);
                        if ($retval) {
                            $info = array_merge($status, $retval);
                        }
                        $status['song_lyrics'] = $info['song_lyrics'];
                        $status['artist_bio_summary'] = $info['artist_bio_summary'];
                        $status['artist_similar'] = $info['artist_similar'];
                        if ($albumBig) {
                            $status['smallArtURL'] = $info['artist_arturl'];
                        } else {
                            $status['bigArtURL'] = $info['artist_arturl'];
                        }
                        if (strpos(' '.$status['smallArtURL'], '/none.png')) {
                            $status['smallArtURL'] = $status['mainArtURL'];
                        }
                        if (strpos(' '.$status['smallArtURL'], '/none.png')) {
                            $status['smallArtURL'] = $status['mainArtURL'];
                        }
                        //
                        // save and post the playback data to the UI
                        $render = $status;
                        unset($render['elapsed'], $render['song_percent']);
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($render));
                        break;
                    case 'ssnc prsm':
                        // play stream resume, no arguments
                        runelog('rune_SSM_wrk: Play stream resume, no arguments');
                        $status['state'] = "play";
                        $render = $status;
                        unset($render['elapsed'], $render['song_percent']);
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($render));
                        break;
                    case 'ssnc clip':
                        // source IP number, can be ipv4 or ipv6
                        $redis->hSet('airplay','source_ip_number', trim($buf));
                        runelog('rune_SSM_wrk: Source IP number: ', $buf);
                        break;
                    case 'ssnc svip':
                        // server IP number
                        $redis->hSet('airplay','server_ip_number', trim($buf));
                        runelog('rune_SSM_wrk: Server IP number: ', $buf);
                        break;
                    case 'ssnc snua':
                        // user agent
                        $redis->hSet('airplay','user_agent', trim($buf));
                        runelog('rune_SSM_wrk: User agent: ', $buf);
                        break;
                    case 'ssnc acre':
                        // source Active-Remote token
                        $redis->hSet('airplay','source_active_remote_token', trim($buf));
                        runelog('rune_SSM_wrk: Source active-Remote token: ', $buf);
                        break;
                    case 'ssnc daid':
                        // source DACP-ID
                        $redis->hSet('airplay','dacp_id', trim($buf));
                        runelog('rune_SSM_wrk: Source DACP-ID: ', $buf);
                        break;
                    case 'ssnc dapo':
                        // source remote control port number
                        $redis->hSet('airplay','source_remote_control_port_number', trim($buf));
                        runelog('rune_SSM_wrk: Source remote control port number: ', $buf);
                        break;
                    case 'ssnc pend':
                        // play stream end, no arguments
                        runelog('rune_SSM_wrk: Play stream end, no arguments - closing the metadata file');
                        // Set up the UI for switching
                        // close the pipe, wait and exit
                        fclose($airplay_handle);
                        $airplay_handle = FALSE;
                        $status['currentalbumartist'] = "Airplay";
                        $status['currentartist'] = "Airplay";
                        $status['currentalbum'] = "-----";
                        $status['currentsong'] = "Switching";
                        $status['state'] = "stop";
                        $render = $status;
                        unset($render['elapsed'], $render['song_percent']);
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($render));
                        break;
                    case 'ssnc flsr':
                        // flush request > pause
                        runelog('rune_SSM_wrk: Flush request: ', $buf);
                        break;
                    case 'ssnc pfls':
                        // play stream flush, no arguments
                        runelog('rune_SSM_wrk: Play stream flush, no arguments');
                        //break;
                    case 'ssnc pbeg':
                        // play stream begin, no arguments
                        runelog('rune_SSM_wrk: Play stream begin, no arguments');
                        sysCmd('rm -f /srv/http/tmp/airplay/airplay-cover.*');
                        //sysCmd('cp /srv/http/assets/img/cover-black.png /srv/http/tmp/airplay/airplay-cover.png');
                        //sysCmd('chown -f http:http /srv/http/tmp/airplay/airplay-cover.*');
                        //sysCmd('chmod 644 /srv/http/tmp/airplay/airplay-cover.*');
                        $status = array();
                        if ($redis->get('volume') && !empty($redis->get('lastmpdvolume'))) {
                            $status['volume'] = $redis->get('lastmpdvolume');
                        }
                        // Example: "44100:16:2";
                        $status['audio'] = $sampleRate.":".$sampleDepth.":2";
                        // Example: "44.1";
                        $status['audio_sample_rate'] = $sampleRateK;
                        // Example: "16";
                        $status['audio_sample_depth'] = $sampleDepth;
                        $status['bitrate'] = "1411";
                        $status['audio_channels'] = "Stereo";
                        $status['random'] = "0";
                        $status['single'] = "0";
                        $status['consume'] = "0";
                        $status['playlist'] = "1";
                        $status['playlistlength'] = "1";
                        $status['state'] = "play";
                        // $status['time'] = "0";
                        // $status['elapsed'] = "0";
                        // $status['song_percent'] = "0";
                        $status['currentalbumartist'] = "Airplay";
                        $status['currentartist'] = "Airplay";
                        $status['currentalbum'] = "-----";
                        $status['currentsong'] = " ----- ";
                        $status['actPlayer'] = "Airplay";
                        $status['radioname'] = null;
                        $status['OK'] = null;
                        $status['song_lyrics'] = ' ';
                        $status['artist_bio_summary'] = ' ';
                        $status['artist_similar'] = ' ';
                        $status['local_volume_control'] = 0;
                        if ($metadataIncludeCoverArt) {
                            $status['mainArtURL'] = $artUrl.'/airplay.png';
                            $status['smallArtURL'] = $artUrl.'/black.png';
                            $status['bigArtURL'] = $artUrl.'/black.png';
                        }
                        // save JSON response for extensions
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($status));
                        //sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                        sysCmdAsync($redis, '/var/www/command/ui_update_async', 0);
                        break;
                    case 'ssnc pcst':
                        // start picture send, no arguments
                        runelog('rune_SSM_wrk: Start picture send, no arguments');
                        break;
                    case 'ssnc pcen':
                        // end picture send, no arguments
                        runelog('rune_SSM_wrk: End picture send, no arguments');
                        // post the playback data to the UI
                        // $render = $status;
                        // unset($render['elapsed'], $render['song_percent']);
                        // $redis->set('act_player_info', json_encode($status));
                        // ui_render('playback', json_encode($render));
                        // sysCmdAsync($redis, '/var/www/command/ui_update_async', 0);
                        break;
                    case 'ssnc snam':
                        // name of user sending device
                        $redis->hSet('airplay','device_name', trim($buf));
                        runelog('rune_SSM_wrk: Name of user sending device: ', $buf);
                        break;
                    case 'ssnc pvol':
                        // volume
                        // The volume is sent as a string -- "airplay_volume,volume,lowest_volume,highest_volume",
                        // where "volume", "lowest_volume" and "highest_volume" are given in dB.
                        // The "airplay_volume" is what's sent by the source (e.g. iTunes) to the player,
                        // and is from 0.00 down to -30.00, with -144.00 meaning "mute". This is linear on the
                        // volume control slider of iTunes or iOS AirPlay
                        $volume = explode(',', $buf);
                        $status['volume'] = round(100 * ($volume[1] - $volume[2]) / ($volume[3] - $volume[2]));
                        $render = $status;
                        unset($render['elapsed'], $render['song_percent']);
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($render));
                        // 'mpc volume' returns the correct volume as long as MPD is running (which it should be)
                        // if ($redis->get('volume')) {
                            // $volume = preg_replace('/[^0-9]/', '', sysCmd('mpc volume | grep volume: | xargs')[0]);
                            // if ($volume) {
                                // $status['volume'] = round($volume);
                            // }
                            // $render = $status;
                            // unset($render['elapsed'], $render['song_percent']);
                            // $redis->set('act_player_info', json_encode($status));
                            // ui_render('playback', json_encode($render));
                        // }
                        // debug
                        // var_dump($volume);
                        // echo "Volume: ".$status['volume']."\n";
                        runelog('rune_SSM_wrk: Volume buf: ', $buf);
                        runelog('rune_SSM_wrk: Volume    : ', $status['volume']);
                        break;
                    case 'ssnc prgr':
                        // progress
                        // This is metadata from AirPlay consisting of RTP timestamps for the start of the current play sequence,
                        // the current play point and the end of the play sequence. The timestamps probabably wrap at 2^32.
                        $progress = explode('/', $buf);
                        // $progress[0] = begin track timestamp
                        // $progress[1] = current track position timestamp = playposition
                        // $progress[2] = end track timestamp
                        // timestamps @ 44,100Htz - divide by 44100 for seconds (round for full seconds)
                        // there can be a delay of 4 to 5 seconds to actually play music, the UI lags the streaming device by this time
                        // if negative results are provided then the timestamp has wrapped so add (2^32)/44100 seconds
                        if ($progress[0] < 0) $progress[0] = $progress[0] + round((2 ** 32) / 44100);
                        if ($progress[1] < 0) $progress[1] = $progress[1] + round((2 ** 32) / 44100);
                        if ($progress[2] < 0) $progress[2] = $progress[2] + round((2 ** 32) / 44100);
                        $status['elapsed'] = round((($progress[1] - $progress[0]) / 44100));
                        $status['time'] = round(($progress[2] - $progress[0]) / 44100);
                        if ($status['elapsed'] < 0) {
                            $status['elapsed'] = 0;
                            $status['time'] = 0;
                            $status['state'] = 'stop';
                        } else {
                            $status['state'] = 'play';
                        }
                        if ($status['time'] == 0) {
                            $status['elapsed'] = 0;
                            $status['song_percent'] = 0;
                        } else if ($status['elapsed'] == 0) {
                            $status['song_percent'] = 0;
                        } else {
                            $status['song_percent'] = min(100, round((100 * $status['elapsed']) / $status['time']));
                        }
                        $status['time_last_elapsed'] = microtime(true);
                        // save and post the playback data to the UI
                        $redis->set('act_player_info', json_encode($status));
                        ui_render('playback', json_encode($status));
                        // debug
                        // var_dump($progress);
                        // echo "status['time'] ".$status['time']."\n";
                        // echo "status['elapsed'] ".$status['elapsed']."\n";
                        // echo "status['state'] ".$status['state']."\n";
                        runelog('rune_SSM_wrk: Progress: ', $buf);
                        runelog('rune_SSM_wrk: Time    : ', $status['time']);
                        runelog('rune_SSM_wrk: Elapsed : ', $status['elapsed']);
                        runelog('rune_SSM_wrk: Percent : ', $status['song_percent']);
                        runelog('rune_SSM_wrk: State   : ', $status['state']);
                        break;
                    case 'ssnc PICT':
                        // artwork
                        // skip this section if cover art is not set
                        if ($metadataIncludeCoverArt) {
                            $bufLen = strlen($buf);
                            // if (($bufLen < 129) || (($bufLen > 8000) && ($bufLen < 9000))) {
                            if ($bufLen < 129) {
                                // a image smaller than 128b is not feasible just use the predefined black image file or
                                // this is a sort of dummy image which airplay sends before sending the real image
                                //  the image has a black background with a white music note on it
                                //  instead of using the note image, just use the predefined black image file
                                // $artFileUrl = $artUrl.'/black.png';
                                // $status['mainArtURL'] = $artFileUrl;
                                // if ($albumBig) {
                                    // $status['bigArtURL'] = $artFileUrl;
                                // } else {
                                    // $status['smallArtURL'] = $artFileUrl;
                                // }
                            } else {
                                // first determine the image file type
                                $tmp = ' '.substr($buf, 0, 32);
                                if (strpos($tmp, 'PNG') !== false) {
                                    $imgtype = 'png';
                                } else if (strpos($tmp, 'JFIF') !== false) {
                                    $imgtype = 'jpg';
                                } else {
                                    $imgtype = 'jpg';
                                }
                                // create a new image file
                                // the order of information supply (metadata > image or image > metadata) seems to be
                                //  random and some images are sent more than once!
                                //  therefore you never know which image belongs to which song, no way to optimise this
                                //  just use a single file name which has a ?<identifier> tag to force a browser reload
                                $random = mt_rand();
                                $formattedArtName = 'Airplay_Image';
                                $artFileName = $artDir.'/'.$formattedArtName.'.'.$imgtype;
                                // note the ?<MD5_of_the_image> which causes the browser to reload an image with the same name when the content changes
                                $artFileUrl = urlencode($artUrl.'/'.$formattedArtName.'.'.$imgtype).'?'.urlencode(md5($buf));
                                if (!file_put_contents($artFileName, $buf)) {
                                    runelog('rune_SSM_wrk: Image file create failed, name: ', $artFileName);
                                    runelog('rune_SSM_wrk: Image file create failed, buffer length: ', strlen($buf));
                                    break;
                                } else {
                                    runelog('rune_SSM_wrk: Image file create created, name: ', $artFileName);
                                    runelog('rune_SSM_wrk: Image file create created, buffer length: ', strlen($buf));
                                    // make sure the image file is readable for the UI (runs as user http)
                                    sysCmd('chown -f http:http "'.$artFileName.'" ; chmod 644 "'.$artFileName.'"');
                                    $status['mainArtURL'] = $artFileUrl;
                                    if ($albumBig) {
                                        $status['bigArtURL'] = $artFileUrl;
                                    } else {
                                        $status['smallArtURL'] = $artFileUrl;
                                    }
                                }
                            }
                            $render = $status;
                            unset($render['elapsed'], $render['song_percent']);
                            $redis->set('act_player_info', json_encode($status));
                            ui_render('playback', json_encode($render));
                            // sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                            //
                            // now get the artist art and song information (also done after metadata end - see above)
                            $info = array();
                            $info['artist'] = $status['currentartist'];
                            $info['albumartist'] = $status['currentalbumartist'];
                            $info['song'] = $status['currentsong'];
                            $retval = get_artistInfo($redis, $info);
                            if ($retval) {
                                $info = array_merge($info, $retval);
                            }
                            $retval = get_songInfo($redis, $info);
                            if ($retval) {
                                $info = array_merge($status, $retval);
                            }
                            $status['song_lyrics'] = $info['song_lyrics'];
                            $status['artist_bio_summary'] = $info['artist_bio_summary'];
                            $status['artist_similar'] = $info['artist_similar'];
                            if ($albumBig) {
                                $status['smallArtURL'] = $info['artist_arturl'];
                            } else {
                                $status['bigArtURL'] = $info['artist_arturl'];
                            }
                            if (strpos(' '.$status['smallArtURL'], '/none.png')) {
                                $status['smallArtURL'] = $status['mainArtURL'];
                            }
                            if (strpos(' '.$status['smallArtURL'], '/none.png')) {
                                $status['smallArtURL'] = $status['mainArtURL'];
                            }
                            $render = $status;
                            unset($render['elapsed'], $render['song_percent']);
                            $redis->set('act_player_info', json_encode($status));
                            ui_render('playback', json_encode($render));
                            // sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                            // clean up the metadata, async and at low priority
                            sysCmdAsync($redis, 'nice --adjustment=10 /srv/http/command/clean_music_metadata_async.php');
                            //sleep(1);
                            //$status['elapsed'] = round($status['elapsed'] + microtime(true) - $status['time_last_elapsed']);
                            //$status['time_last_elapsed'] = microtime(true);
                            //$status['song_percent'] = min(100, round(100*$status['elapsed']/$status['time']));
                            //$redis->set('act_player_info', json_encode($status));
                            //sleep(2);
                            //sysCmdAsync($redis, '/var/www/command/ui_update_async', 0);
                            //sysCmd('curl -s -X GET http://localhost/command/?cmd=renderui');
                        }
                        break;
                    default:
                        if ($debugMetadata) {
                            echo "rune_SSM_wrk: Unknown metadata coding '$type $code'\n";
                        }
                        runelog("rune_SSM_wrk: Undefined '".$type." ".$code."': ", substr($buf, 0, 32));
                        break;
                }
                $buf = '';
                $type = '';
                $code = '';
            }
        } while (($redis->get('activePlayer') === 'Airplay') && ($airplay_handle != FALSE));
        sleep(1);
    }
// --- WORKER MAIN LOOP --- //
// close Redis connection
$redis->close();
}
