#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/cmd_async_queue
 *  version: 1.3
 *  coder: janui
 *  date: January 2022
 *
 */
// common include
ini_set('display_errors', '1');
// ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/cmd_async_queue.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
//
$cycleCommands = array();
//
// maybe a little paranoid, but to prevent anyone just dropping commands into the cmd_queue
//  the commands are deflated, encrypted and then base64_encoded
//  the reverse is used to decode commands
//  its not really secure but should be enough to deter the casual burglar
// variables
// the initialization vector is calculated in the standard way, initially at boot time and after emptying the queue (see below)
if (is_firstTime($redis, 'cmd_queue_encoding')) {
    // use the first cypher in the list of possibles
    $cipher = openssl_get_cipher_methods()[0];
    $redis->hSet('cmd_queue_encoding', 'cipher', $cipher);
    // determine the initialization vector
    $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length($cipher));
    // it must be the same for encoding and decoding, save it
    $redis->hSet('cmd_queue_encoding', 'cipher_iv', $iv);
    // the passphrase is the playerid
    $passphrase = $redis->get('playerid');
    $redis->hSet('cmd_queue_encoding', 'passphrase', $passphrase);
}
$iv = $redis->hGet('cmd_queue_encoding', 'cipher_iv');
$cipher = $redis->hGet('cmd_queue_encoding', 'cipher');
$passphrase = $redis->hGet('cmd_queue_encoding', 'passphrase');
// encode
// $encoded = base64_encode(openssl_encrypt(gzdeflate($command, 9), $cipher, $passphrase, 0, $iv));
// decode
// $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
//
// loop until the command has a length of zero, which indicates that the queue is empty
//  the job stops after this cycle of commands have been processed
do {
    // read the fifo queue
    $encoded = $redis->rPop('cmd_queue');
    // check the length of the output, 0 = end
    $lenCommand = strlen($encoded);
    if (!$lenCommand) {
        // the command is empty, end of fifo queue
        // try to reset the initialization vector
        $ivNew = openssl_random_pseudo_bytes(openssl_cipher_iv_length($cipher));
        if (!$redis->lLen('cmd_queue')) {
            // fifo list still empty
            $redis->hSet('cmd_queue_encoding', 'cipher_iv', $ivNew);
            // this new value will be used for the next queue submission
        } else {
            // the queue got an extra entry before 'cipher_iv' was reset, loop to process it
            $lenCommand = 1;
        }
        continue;
    }
    // decode the encoded command
    $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
    // debug
    runelog('cmd_async_queue - decoded command', $command);
    // echo "Decoded command: ".$command."\n";
    if (strlen($command) && !in_array($command, $cycleCommands)) {
        // debug
        runelog('cmd_async_queue - running command', $command);
        // echo "Running command: ".$command."\n";
        // the command is not empty, and it is not been processed in this processing cycle, run the command
        sysCmd($command);
        // save the command
        $cycleCommands[] = $command;
    }
    unset($command, $encoded);
    // loop for the next entry until the command is empty
} while ($lenCommand);
