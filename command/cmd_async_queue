#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/cmd_async_queue
 *  version: 1.3
 *  coder: janui
 *  date: January 2022
 *
 */
// common include
ini_set('display_errors', '1');
// ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/cmd_async_queue.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
//
// maybe a little paranoid, but to prevent anyone just dropping commands into the cmd_queue
//  the commands are deflated, encrypted and then base64_encoded
//  the reverse is used to decode commands
//  its not really secure but should be enough to deter the casual burglar
// variables
// use the first cypher in the list of possibles
$cipher = openssl_get_cipher_methods()[0];
// the passphrase is a hash of the playerid
$passphrase = $redis->get('playerid');
// the initialization vector is calculated in the standard way, once per boot
if (is_firstTime($redis, 'cipher_iv')) {
    // this is the standard way
    $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length($cipher));
    $redis->set('cipher_iv', $iv);
} else {
    // it must be the same for encoding and decoding, save it
    //  this means that encoding changes after each reboot
    $iv = $redis->get('cipher_iv');
}
// encode
// $encoded = base64_encode(openssl_encrypt(gzdeflate($command, 9), $cipher, $passphrase, 0, $iv));
// decode
// $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
//
// loop until the command has a length of zero, which indicates that the queue is empty
do {
    // reset the lock to 1, do it on each iteration, this helps to prevent extra jobs starting
    $redis->set('lock_cmd_queue', '1');
    // read the fifo queue
    $encoded = $redis->rPop('cmd_queue');
    // check the length of the output, 0 = end
    $lenCommand = strlen($encoded);
    if (!$lenCommand) {
        // the command is empty, end of fifo queue
        // try to reset the initialization vector
        $ivNew = openssl_random_pseudo_bytes(openssl_cipher_iv_length($cipher));
        if (!$redis->lLen('cmd_queue')) {
            // fifo list still empty
            $redis->set('cipher_iv', $ivNew);
            // this new value will be used for the next submission
        }
        continue;
    }
    // decode the encoded command
    $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
    if (strlen($command)) {
        // the command is not empty, run the command
        sysCmd($command);
    }
    unset($command, $encoded);
    // loop for the next entry until the command is empty
} while ($lenCommand);
// unlock the queue
$redis->set('lock_cmd_queue', '0');
