#!/usr/bin/php
<?php
/*
 * Copyright (C) 2013-2014 RuneAudio Team
 * http://www.runeaudio.com
 *
 * RuneUI
 * copyright (C) 2013-2014 - Andrea Coiutti (aka ACX) & Simone De Gregori (aka Orion)
 *
 * RuneOS
 * copyright (C) 2013-2014 - Simone De Gregori (aka Orion) & Carmelo San Giovanni (aka Um3ggh1U)
 *
 * RuneAudio website and logo
 * copyright (C) 2013-2014 - ACX webdesign (Andrea Coiutti)
 *
 * This Program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This Program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with RuneAudio; see the file COPYING. If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.txt>.
 *
 *  file: command/cmd_async_queue
 *  version: 1.3
 *  coder: janui
 *  date: January 2022
 *
 */
// common include
ini_set('display_errors', '1');
// ini_set('error_reporting', -1);
ini_set('error_log', '/var/log/runeaudio/cmd_async_queue.log');
require_once('/srv/http/app/libs/runeaudio.php');
// Connect to Redis backend include
require_once('/srv/http/app/libs/openredis.php');
//
// maybe a little paranoid, but to prevent anyone just dropping commands into the cmd_queue
//  the commands are deflated, encrypted and then base64_encoded
//  the reverse is used to decode commands
//  its not really secure but should be enough to deter the casual burglar
// variables, initially set at boot time and after emptying the queue (see below)
//  the cipher is the first one returned by openssl_get_cipher_methods()
//  the initialization vector is calculated in the standard way
//  the passphrase is the Rune playerID
// if (is_firstTime($redis, 'cmd_queue_encoding')) {
    // // delete any existing command queue entries
    // $redis->del('cmd_queue');
    // // reset the encryption data
    // reset_cmd_queue_encoding($redis);
// }
// encode
//  $encoded = base64_encode(openssl_encrypt(gzdeflate($command, 9), $cipher, $passphrase, 0, $iv));
// decode
//  $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
//
// double loop, the outside loop loops forever, there are two sequential loops inside it
//  the first inside loop loops until there is something to process
//  the second inside loop processes the queue until it it is empty
//  the encryption data is reset (changed) when the queue is empty
//
while (true) {
    // clear the array of commands which have been used in the last cycle
    $cycleCommands = array();
    // loop until there is something to process
    while (!$redis->lLen('cmd_queue')) {
        // a new command queued to an empty queue will start within 2,5 seconds (on average)
        //  subsequent commands in the queue start sequentially without a pause
        sleep(5);
    }
    // at least one entry to process
    while ($redis->lLen('cmd_queue')) {
        // get the encryption data
        $iv = $redis->hGet('cmd_queue_encoding', 'cipher_iv');
        $cipher = $redis->hGet('cmd_queue_encoding', 'cipher');
        $passphrase = $redis->hGet('cmd_queue_encoding', 'passphrase');
        // read the fifo queue
        $encoded = $redis->rPop('cmd_queue');
        // check the length of the output (0 = end), this should never happen
        $lenCommand = strlen($encoded);
        if (!$lenCommand) {
            continue;
        }
        // decode the encoded command
        $command = trim(gzinflate(openssl_decrypt(base64_decode($encoded), $cipher, $passphrase, 0, $iv)));
        // debug
        // echo "Decoded command: ".$command."\n";
        runelog('cmd_async_queue - decoded command', $command);
        if (strlen($command) && !in_array($command, $cycleCommands)) {
            // debug
            runelog('cmd_async_queue - running command', $command);
            // echo "Running command: ".$command."\n";
            // the command is not empty, and it is not been processed within this processing cycle, run the command
            //  duplicate commands in the processing cycle occur during start-up when a backlog of commands builds up
            //  also some unpredictable processing sometimes generates duplicates (e.g. mpd trigger actions)
            //  there is basically no point in processing these
            sysCmd($command);
            // add the command to the cycle commands array
            $cycleCommands[] = $command;
        }
        unset($iv, $cipher, $passphrase, $encoded, $lenCommand, $command);
        // loop for the next entry until the command queue is empty
    }
    // the queue is empty, try to reset the encryption data
    //  it wont be changed if the queue gets new entries while processing
    reset_cmd_queue_encoding($redis);
    // loop forever
}
